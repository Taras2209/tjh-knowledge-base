## **5. Запитання для співбесіди на тему QA Manual & QA Automation**

---

- [1. Що таке тестування](#1)
- [2. Навіщо тестувати програмне забезпечення](#2)
- [3. Які існують етапи тестування](#3)
- [4. Які типи тестування можна назвати](#4)
- [5. Які рівні тестування ви знаєте](#5)
- [6. Які техніки проектування тестів ви знаєте](#6)
- [7. Що таке техніка аналізу класів еквівалентності](#7)
- [8. Що таке техніка аналізу межових значень? В чому цінність цієї техніки](#8)
- [9. Що таке Regression і Confirmation тестування, в чому різниця між ними](#9-regression-confirmation)
- [10. Як часто варто проводити регресійне тестування продукту](#10)
- [11. Які існують види інтеграційного тестування](#11)
- [12. Що таке Configuration testing](#12-configuration-testing)
- [13. Що таке Exploratory testing](#13-exploratory-testing)
- [14. Які існують UI-стандарти](#14-ui-)
- [15. Що таке Black/Grey/White Box Testing](#15-blackgreywhite-box-testing)
- [16. Що таке Performance Testing](#16-performance-testing)
- [17. Що таке Smoke і Sanity тестування і в чому різниця між ними](#17-smoke-sanity)
- [18. Що таке Traceability Matrix](#18-traceability-matrix)
- [19. Що таке Sanity Testing](#19-sanity-testing)
- [20. Що таке End-to-End тест](#20-end-to-end)
- [21. Що таке тестування безпеки](#21)
- [22. Що таке тестування на основі ризиків](#22)
- [23. Що таке динамічне тестування](#23)
- [24. Що таке "парадокс пестициду"](#24)
- [25. Опишіть основні фази STLC? Надайте визначення Entry і Exit Criteria](#25-stlc-entry-exit-criteria)
- [26. Що таке Bug, Error, Failure, Fault](#26-bug-error-failure-fault)
- [27. Які є атрибути звіту про помилку? Які основні поля для заповнення](#27)
- [28. Яка різниця між пріоритетом і серйозністю](#28) 
- [29. Наведіть приклади серйозної, але не пріоритетної помилки](#29) 
- [30. В чому різниця між валідацією і верифікацією](#30) 
- [31. Навіщо потрібна тестова документація і які її види](#31) 
- [32. Що таке тест-план? Які елементи він має](#32-) 
- [33. Яку обов'язкову інформацію має містити тест-план](#33-) 
- [34. Яка різниця між чеклистом і тест-кейсами](#34) 
- [35. Обязанності QA](#35-qa)
- [36. Що знаєте про тестування навантаження? У якому випадку слід проводити таке тестування? На якому етапі готовності продукту](#36)
- [37. Decision table і як її можна використовувати](#37-decision-table)
- [38. Що може бути критеріями запуску і завершення тестування](#38)
- [39. Приклади підходів для тестування локалізації](#39)
- [40. A/B тестування](#40-ab)
- [41. Що таке mock/stub? Які знаєте інструменти для роботи з ними](#41-mockstub)
- [42. Коли потрібно використовувати техніку Pairwise](#42-pairwise)
- [43. Fuzz-тестування і де його використовують](#43-fuzz-)
- [44. REgexp](#44-regexp)
- [45. Як змінюється вартість дефекту під час тестування ПЗ](#45)
- [46. Які шляхи аналізу бізнесу клієнта? Як визначити доцільність того чи іншого функціоналу](#46)
- [47. Яке має бути відсоткове співвідношення між позитивним і негативним тестуванням на проєкті](#47)
- [48. Чи є різниця між bug leakage і bug release](#48-bug-leakage-bug-release)
- [49. Що потрібно покривати тест-кейсами, а що вважається надлишковою витратою часу і грошей? Коли недоцільно писати тест-кейси](#49-)
- [50. Як порахувати Cyclomatic complexity](#50-cyclomatic-complexity)
- [51. У чому основна різниця між defect detection percentage і defect removal efficiency](#51-defect-detection-percentage-defect-removal-efficiency)
- [52. Які моделі risk-based testing ви знаєте](#52-risk-based-testing)
- [53. Тестування API? Інструменти](#53-api)
- [54. Load, Stress та Stability testing? Якими інструментами користуються для їх виконання](#54-load-stress-stability-testing)
- [55. Як ви будуватимете і впроваджуватимете стратегію з автоматизації тестування](#55)
- [56. Як обробляти браузерні повідомлення (alerts)](#56-alerts)
- [57. Концепція дизайну Appium](#57-appium)
- [58. Electron? Як використовувати Selenium для тестування програм на його основ](#58-electron-selenium)
- [59. Що таке і чим відрізняються віртуальна машина, симулятор та емулятор](#59)
- [60. Контейнер і чим він відрізняється від віртуальної машини](#60)
- [61. IaaS та PaaS? Приклади використання](#61-iaas-paas)
- [62. Configuration Management](#62-configuration-management)
- [63. SSH і як ним користуватися](#63-ssh)
- [64. Bash і Batch скрипти? Для чого їх використовують](#64-bash-batch)
- [65. Різниця між авторизацією та автентифікацією](#65)
- [66. Чи може сервер відправити код 400, якщо проблема на його стороні](#66-400)
- [67. Як перевірити обрив з'єднання WebSocket](#67-websocket)
- [68. Основні види вразливості веб-додатків](#68-)
- [69. Які інструменти для тестування Web performance client-side знаєте](#69-web-performance-client-side)
- [70. Cніфери? Які знаєте](#70-c)
- [71. Різниця між DROP та TRUNCATE](#71-drop-truncate)
- [72. Функція CASE](#72-case)
- [73. Що таке collation](#73-collation)
- [74. Що таке схема GraphQL](#74-graphql)
- [75. Різниця між OLTP та OLAP](#75-oltp-olap)
- [76. Типи реплікації в SQL Server?](#76-sql-server)
- [77. Self Join](#77-self-join)
- [78. Що таке тестування](#78)
- [79. Піраміда тестування](#79)
- [80. Навіщо тестувати ПЗ](#80)
- [81. Етапи тестування](#81)
- [82. Типи тестування](#82)
- [83. Рівні тестування](#83)
- [84. Техніки тест-дизайну](#84-)
- [85. Що таке Regression та Confirmation тестування, яка між ними різниця](#85-regression-confirmation)
- [86. Частота регресійного тестування](#86)
- [87. Види інтеграційного тестування](#87)
- [88. Configuration Testing](#88-configuration-testing)
- [89. Exploratory Testing](#89-exploratory-testing)
- [90. Performance Testing](#90-performance-testing)
- [91. Traceability Matrix](#91-traceability-matrix)
- [92. End-to-End тест](#92-end-to-end)
- [93. Тестування безпеки](#93)
- [94. Випробування на основі ризиків](#94)
- [95. Динамічне тестування](#95)
- [96. Основні фази STLC? Дайте визначення Entry та Exit Criteria](#96-stlc-entry-exit-criteria)
- [97. Атрибути баг-репорту? Які основні поля для заповнення](#97-)
- [98. Різниця між пріоритетом і серйозністю](#98)
- [99. Наведіть приклади серйозного, але не пріоритетного бага](#99)
- [100. Навіщо потрібна тестова документація? Які її види](#100)
- [101. Тест-план? Які елементи має](#101-)

---

# **Відповіді - 'Теорія тестування'**

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **1. Що таке тестування**

Тестування - це процес перевірки програмного продукту з метою виявлення помилок, дефектів і недоробок, а також оцінки його якості.  
Воно включає в себе створення і виконання тестових сценаріїв з метою переконатися у відповідності продукту заданим вимогам і очікуванням користувачів.
Ще включає в себе планування, проєктування і, власне, виконання тестів.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **2. Навіщо тестувати програмне забезпечення**
Тестування ПЗ необхідне для забезпечення надійності, якості та функціональності продукту.  
Воно допомагає виявити помилки на ранніх стадіях розробки, знижує ризики неполадок у роботі, покращує користувацький досвід і довіру до продукту.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **3. Які існують етапи тестування**

Загалом виділяють 7 етапів тестування:  

1. **Робота з вимогами.**  
1.1 Знайомство з вимогами замовника. Обговорення, що має являти собою підсумковий продукт
2. **Розробка стратегії тестування.**  
2.1 Оцінка термінів тестування, виявлення середовища тестування, об'єднання всієї інформації, отриманої під час роботи з вимогами.
3. **Створення тестової документації.**  
3.1 Написання сценаріїв, які дадуть змогу перевірити функціонал.
4. **Тестування прототипу.**  
4.1 Тестування основного функціоналу продукту, коригування цілей, додавання фічей.
5. **Основне тестування.**  
5.1 Виконання загальної перевірки продукту.
6. **Стабілізація.**  
6.1 На цьому етапі відбувається робота над усуненням багів.
7. **Експлуатація.**  
7.1 Проводиться регрес-тестування, усунення помилок, які знайшов кінцевий користувач.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **4. Які типи тестування можна назвати**

Залежно від потреб процес тестування повинен бути організований відповідним чином. Отже, ми можемо визначити 4 види тестування програмного забезпечення:

1. функціональне тестування (Functional testing);
2. нефункціональне тестування (Non-functional testing);
3. структурне тестування (Structural testing);
4. тестування змін (Change related testing).


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **5. Які рівні тестування ви знаєте**

Тестування на різних рівнях проводиться протягом усього життєвого циклу розробки і супроводу ПЗ. Рівень тестування визначає те, над чим виробляються тести: над окремим модулем, групою модулів або системою в цілому. Проведення тестування на всіх рівнях системи – це запорука успішної реалізації та здачі проекту.

- Рівні тестування (Testing levels):

    - Компонентне або Модульне тестування (Component testing or Unit testing)
    - Інтеграційне тестування (Integration testing)
    - Системне тестування (System testing)
    - Приймальне тестування (Acceptance testing)


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **6. Які техніки проектування тестів ви знаєте**

- **Техніки, що базуються на досвіді й інтуїції**
    - Спеціалізоване тестування (Ad hoc testing).
    - Дослідне тестування (Exploratory testing)
- **Техніки, що базуються на специфікації**
    - Еквівалентне розділення (Equivalence partitioning).
    - Аналіз граничних значень (Boundary-value analysis).
    - Таблиці прийняття рішень (Decision table)
    - Тести на основі скінченого автомату (Finite-state machine-based)
    - Тестування на основі формальної специфікації (Testing from formal specification)
    - Випадкове тестування (Random testing)
- **Техніки, орієнтовані на код**
    - Тести, що базуються на блок-схемі (Control-flow-based criteria).
    - Тести на основі потоків даних (Data-flow-based criteria)
    - Тестування, орієнтоване на дефекти (Fault-based techniques)
    - Передбачення помилок (Error guessing)
    - Тестування мутацій (Mutation testing).
    - Операційний профіль (Operational profile)
    - Тестування на основі надійності інженерного процессу (Software Reliability Engineered Testing)
    - Техніки, що базуються на природі застосування (Techniques based on the nature of the application)
- **Комбінації технік**
    - Функціональне тестування та структурне тестування (Functional and structural)

Детальніше: https://elib.lntu.edu.ua/sites/default/files/elib_upload/%D0%A2%D0%B5%D1%81%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F/page18.html

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **7. Що таке техніка аналізу класів еквівалентності**

Поділ на класи еквівалентності – це техніка, при якій функціонал (діапазон можливих вхідних значень) розділяється на групи значень еквівалентних за своєю дією на систему.

Нижче розглянемо приклад поділу на класи еквівалентності.

Є поле з допустимим діапазоном значень введення від 1 до 1000. Вводити весь діапазон — досить довгий процес. Тим більше, є ще неприпустимі значення (спецсимволи, негативні числа, букви і та ін.), введення яких потрібно перевірити.

Як говорилося вище, всі значення одного класу еквівалентності однаково впливають на систему, тобто допустимі значення система приймає, а недопустимі – ні. В поле повинно бути заборонено введення неприпустимих значень.

Таким чином, можна виділити два класи еквівалентності:

* Можна вибрати зі значень числа від 1 до 1000.
* Неприпустимі значення: числа від -∞ до 0, від 1001 до + ∞, а також всі інші літери і символи.

Клас з неприпустимими значеннями можна розбити на кілька:

* Від - ∞ до 0.
* Від 1001 до + ∞.
* Спеціальні символи (# @ + - / _:; " 'і т.д.).
* Літери.

В результаті, завдяки класам еквівалентності можна використовувати мінімум 5 тестів для тестування поля введення. Наприклад, в поле ввести наступні дані: 46, -37, 1773, Ім'я, $ _ = #.

Техніку поділу на класи еквівалентності застосовують для скорочення числа тестів, при цьому зберігаючи прийнятне тестове покриття. Дана техніка підходить також для текстових або інших типів даних.

**Кроки застосування техніки поділу на класи еквівалентності наступні:**

1. Визначити класи еквівалентності. Від правильності виконання даного кроку залежить ефективність майбутнього тестування.
2. Вибрати представника кожного класу.
3. Виконати тести.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **8. Що таке техніка аналізу межових значень? В чому цінність цієї техніки**

Ця техніка фокусується на тестуванні в крайніх точках діапазонів даних, таких як мінімальні та максимальні значення. Вона дає змогу виявити помилки, пов'язані з некоректним опрацюванням крайніх випадків.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **9. Що таке Regression і Confirmation тестування, в чому різниця між ними**

> Confirmation testing (re-testing) - Тестування, у якому виконуються тестові сценарії, які були пройдені під час останнього запуску, з метою підтвердити успішність виправлень.

>Регресійне тестування – це набір тестів, спрямованих на виявлення дефектів у вже протестованих модулях додатка.  
Робиться це зовсім не для того, щоб остаточно переконатися у відсутності багів, а для пошуку та виправлення регресійних помилок.  
Регресійні помилки – ті ж баги, але з’являються вони не при написанні програми, а при додаванні в існуючий білд нової частини програми або виправлення інших багів, що і стає причиною виникнення нових дефектів у вже протестованому продукті.

Таким чином, ми можемо сказати, що мета регресійного тестування – переконатися, що виправлення одних багів не стало причиною виникнення інших і що оновлення білду не створило нових дефектів у вже перевіреному коді.

Є кілька видів регресійних тестів:

* Верифікаційні тести. Проводять для перевірки виправлення виявленого та відкритого раніше бага.
* Тестування верифікації версії. Містить принципи димного тестування та тестування зборки: перевірка працездатності основної функціональності програми в кожній новій версії.
* Безпосередньо саме регресійне тестування – повторне виконання всіх тестів, які були написані та проведені раніше. Вони виконуються по вже існуючих тест-кейсам незалежно від того, були в ході їх проходження знайдені баги, чи ні.
* Тестування в новому білді вже виправлених багів в старих білдах. Це виконується для того, щоб перевірити, чи не відновило оновлення білду старих дефектів.

Деякі положення щодо того, як проводити регресійне тестування:

* Даний вид тестування проводиться в кожному новому білді.
* Починати потрібно з верифікації версії (тестування зборки та димне тестування).
* Перевірка виправлених багів.
* Регресійне тестування, в основному, не покриває весь додаток, а тільки ті ділянки, які тим чи іншим способом «стикаються» зі змінами в білді.

Далі тестуються вже закриті раніше баги.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **10. Як часто варто проводити регресійне тестування продукту**

1.Регресійне тестування рекомендується проводити кілька разів (3-5). Тому, з метою економії дорогоцінного часу (і, може бути, для позбавлення від «рутинності») в регресійних тестах активно використовують засоби автоматизації тестування.  
2. Проведення фінального регресійного тестування, для якого відбираються тести по пріоритету, що визначаються найбільшою кількістю знайдених помилок.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **11. Які існують види інтеграційного тестування**

Існує три різні підходи до інтеграційного тестування: 

1. інтеграційне тестування згори вниз
2. інтеграційне тестування знизу вгору 
3. сендвіч-інтеграційне тестування.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **12. Що таке Configuration testing**

Конфігураційне тестування(Configuration Testing) - спеціальний вид тестування, спрямований на перевірку роботи програмного забезпечення при різних конфігураціях системи (заявлених платформах, підтримуваних драйвери, при різних конфігураціях комп'ютерів і т. Д.)

Залежно від типу проекту конфигурационное тестування може мати різні цілі:

1. Проект по профілізації роботи системи. Мета тестування: визначити оптимальну конфігурацію обладнання, що забезпечує необхідні характеристики продуктивності та часу реакції тестованої системи.

2. Проект з міграції системи з однієї платформи на іншу. Мета тестування: Перевірити об'єкт тестування на сумісність з оголошеним в специфікації обладнанням, операційними системами та програмними продуктами третіх фірм.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **13. Що таке Exploratory testing**

Дослідницьке тестування (exploratory testing) – це одночасне вивчення програмного продукту, проєктування тестів і їх виконання. Тестувальник активно контролює проєктування тестів в той час, як ці тести виконуються, і використовує отриману під час тестування інформацію для проєктування нових тестів.

Якщо кожен наступний тест, який виконує тестувальник, вибирається за результатами попереднього тесту, це означає, що ми використовуємо дослідницьке тестування.

Цей підхід можна застосувати до будь-якого виду тестування. Ще один важливий момент полягає в тому, що дослідницьке тестування – це не тільки виконання тестів. Тестувальники можуть застосовувати дослідницький підхід і при розробці нових тестів на початку ітерації, і при аналізі вже завершених тестів. Також, дослідницьке тестування не повинно виконуватися недбало, в поспіху і без підготовки.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **14. Які існують UI-стандарти**

Існує багато різних UI-стандартів, які використовуються для розробки користувацьких інтерфейсів.  
Деякі з них є загальноприйнятими у галузі програмної розробки та дизайну. Ось декілька прикладів таких стандартів:

1. **Material Design**: Розроблений компанією Google, цей стандарт використовує візуальні та рухові ефекти для створення сучасних та легких у використанні користувацьких інтерфейсів. Material Design акцентується на реалістичний вигляд, використання тіней, кольорів та анімацій.

2. **iOS Human Interface Guidelines**: Розроблений компанією Apple, цей стандарт визначає рекомендації та принципи для розробки інтерфейсів додатків для пристроїв Apple. Він ставить акцент на простоту, чіткість та консистентність в дизайні.

3. **Bootstrap**: Це фреймворк для веб-розробки, який надає набір стандартних компонентів та стилів, що допомагають швидше створювати сучасні та адаптивні веб-інтерфейси.

4. **Flat Design**: Цей стиль дизайну характеризується використанням плоских елементів, яскравих кольорів та мінімалістичних деталей. Flat design намагається забезпечити простоту та прямолінійність.

5. **Material Design Lite (MDL)**: Це легка версія Material Design, яка надає компоненти та стилі для швидкої імплементації веб-інтерфейсів.

6. **Windows User Experience Guidelines**: Стандарти розробки інтерфейсів для операційних систем Windows, розроблені компанією Microsoft. Вони надають рекомендації для розробників, як реалізувати інтерфейси, що відповідають стилю Windows.

7. **Semantic UI**: Це ще один фреймворк для веб-розробки, який намагається забезпечити логічний та семантичний підхід до створення інтерфейсів.

8. **Foundation**: Це інший варіант фреймворка для веб-розробки, який надає набір інструментів для швидкого створення адаптивних та дружніх до мобільних пристроїв інтерфейсів.

- Це лише кілька прикладів існуючих UI-стандартів. Вибір стандарту залежить від потреб вашого проекту, цільової аудиторії та інших факторів.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **15. Що таке Black/Grey/White Box Testing**

* *Тестування білої скриньки (white box testing)* - тестування, що базується на аналізі внутрішньої структури компонента або системи та на знанні вихідного коду, до якого тестувальник (як правило, це програміст) має повний доступ.

* *Тестування сірої скриньки (gray box testing)* - тестування, орієнтоване на імітацію роботи користувачів, в умовах, коли частина внутрішньої структури програми відома.

* *Тестування чорної скриньки (black box testing)* - тестування, що базується на аналізі функціональної або нефункціональної специфікації системи, за якого програма розглядається як об'єкт, внутрішня структура якого невідома.

--- 

**Black Box(чорна скринька)**

Summary: Ми не знаємо, як влаштована тестована система.

Тестування методом "чорної скриньки", також відоме як тестування, що ґрунтується на специфікації, або тестування поведінки, - техніка тестування, що ґрунтується на роботі винятково із зовнішніми інтерфейсами тестованої системи.

Згідно з ISTQB:

тестування чорної скриньки - це:

- тестування, як функціональне, так і нефункціональне, що не передбачає знання внутрішнього устрою компонента або системи.

- тест-дизайн, заснований на техніці чорної скриньки - процедура написання або вибору тест-кейсів на основі аналізу функціональної або нефункціональної специфікації компонента або системи без знання її внутрішнього устрою.

Чому саме "чорна скринька"? Програма, що тестується, для тестувальника - як чорний непрозорий ящик, вмісту якого він не бачить. Метою цієї техніки є пошук помилок у таких категоріях:

- неправильно реалізовані або відсутні функції;

- помилки інтерфейсу;

- помилки в структурах даних або організації доступу до зовнішніх баз даних;

- помилки поведінки або недостатня продуктивність системи;

Таким чином, ми не маємо уявлення про структуру і внутрішній устрій системи. Потрібно концентруватися на тому, що програма робить, а не на тому, як вона це робить.

Приклад:

Тестувальник проводить тестування веб-сайту, не знаючи особливостей його реалізації, використовуючи тільки передбачені розробником поля введення та кнопки. Джерело очікуваного результату - специфікація.

Оскільки це тип тестування, за визначенням він може включати інші його види. Тестування чорної скриньки може бути як функціональним, так і нефункціональним. Функціональне тестування передбачає перевірку роботи функцій системи, а нефункціональне - відповідно, загальні характеристики нашої програми.

Техніка чорної скриньки застосовна на всіх рівнях тестування (від модульного до приймального), для яких існує специфікація. Наприклад, під час здійснення системного або інтеграційного тестування, вимоги або функціональна специфікація будуть основою для написання тест-кейсів.

Техніки тест-дизайну, що базуються на використання чорної скриньки, включають:

- класи еквівалентності;

- аналіз граничних значень;

- таблиці рішень;

- діаграми зміни стану;

- тестування всіх пар.

Переваги:

- тестування проводиться з позиції кінцевого користувача і може допомогти виявити неточності та суперечності в специфікації;

- тестувальнику немає необхідності знати мови програмування і заглиблюватися в особливості реалізації програми;

- тестування може здійснюватися фахівцями, незалежними від відділу розробки, що допомагає уникнути упередженого ставлення;

- можна починати писати тест-кейси, щойно готова специфікація.

Недоліки:

- тестується тільки дуже обмежена кількість шляхів виконання програми;

- без чіткої специфікації (а це скоріше реальність на багатьох проєктах) досить важко скласти ефективні тест-кейси;

- деякі тести можуть виявитися надлишковими, якщо вони вже були проведені розробником на рівні модульного тестування;

Протилежністю техніки чорної скриньки є тестування методом білої скриньки, мова про яке піде нижче.

---

**White Box (біла скринька)**

Summary: Нам відомі всі деталі реалізації тестованої програми.

Тестування методом білої скриньки (також: прозорої, відкритої, скляної скриньки; засноване на коді або структурне тестування) - метод тестування програмного забезпечення, який передбачає, що внутрішня структура/пристрій/реалізація системи відомі тестувальнику. Ми вибираємо вхідні значення, ґрунтуючись на знанні коду, який буде їх обробляти. Так само ми знаємо, яким має бути результат цієї обробки. Знання всіх особливостей тестованої програми та її реалізації - обов'язкові для цієї техніки. Тестування білої скриньки - заглиблення у внутрішній устрій системи, за межі її зовнішніх інтерфейсів.

Згідно з ISTQB:

тестування білої скриньки - це:

- тестування, засноване на аналізі внутрішньої структури компонента або системи.

- тест-дизайн, заснований на техніці білої скриньки - процедура написання або вибору тест-кейсів на основі аналізу внутрішнього устрою системи або компонента.

Чому "білий ящик"? Програма, що тестується, для тестувальника - прозора скринька, вміст якої він прекрасно бачить.

Приклад:

Тестувальник, який зазвичай є програмістом, вивчає реалізацію коду поля введення на веб-сторінці, визначає всі передбачені (як правильні, так і неправильні) і не передбачені користувацькі введення, і порівнює фактичний результат виконання програми з очікуваним. При цьому очікуваний результат визначається саме тим, як має працювати код програми.

Тестування методом білої скриньки схоже на роботу механіка, який вивчає двигун машини, щоб зрозуміти, чому вона не заводиться.

Техніка білої скриньки може бути застосована на різних рівнях тестування - від модульного до системного, але головним чином застосовується саме для реалізації модульного тестування компонента його автором.

Переваги:

- тестування може здійснюватися на ранніх етапах: немає необхідності чекати створення користувацького інтерфейсу;

- можна провести більш ретельне тестування, з покриттям великої кількості шляхів виконання програми.

Недоліки:

- для виконання тестування білої скриньки необхідна велика кількість спеціальних знань

- при використанні автоматизації тестування на цьому рівні, підтримка тестових скриптів може виявитися досить накладною, якщо програма часто змінюється.

---

**Grey Box (сіра скринька)**

Summary: Нам відомі тільки деякі особливості реалізації тестованої системи.

Тестування методом сірої скриньки - метод тестування програмного забезпечення, який передбачає комбінацію White Box і Black Box підходів. Тобто, внутрішній устрій програми нам відомий лише частково. Передбачається, наприклад, доступ до внутрішньої структури та алгоритмів роботи ПЗ для написання максимально ефективних тест-кейсів, але саме тестування проводиться за допомогою техніки чорної скриньки, тобто, з позиції користувача.

Цю техніку тестування також називають методом напівпрозорого ящика: щось ми бачимо, а щось - ні.

Приклад:

Тестувальник вивчає код програми для того, щоб краще розуміти принципи її роботи та вивчити можливі шляхи її виконання. Таке знання допоможе написати тест-кейс, який напевно перевірятиме певну функціональність.

Техніка сірої скриньки застосовна на різних рівнях тестування - від модульного до системного, але головним чином застосовується на інтеграційному рівні для перевірки взаємодії різних модулів програми.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **16. Що таке Performance Testing**
Тестування продуктивності (Performance Testing) – визначає наскільки тестований додаток стабільний, а також досліджує показники швидкості реакції програми на зовнішні впливи при різному за характером та інтенсивністю навантаження. Метою тестування є виявлення недоліків і вразливостей в системі, визначення швидкості завантаження даних і їх обробки, надійності програми.

Тестування параметрів роботи системи можна проводити за допомогою:

- визначення допустимої кількості користувачів додатка;
- вимірювання часу виконання тієї чи іншої операції системи;
- визначення допустимих меж продуктивності програми з різними рівнями навантаження.
- Тестування продуктивності можна розділити на наступні підвиди:

- навантажувальне;
- стресове;
- стабільності;
- конфігураційне.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **17. Що таке Smoke і Sanity тестування і в чому різниця між ними**
Smoke Testing - швидке поверхневе тестування основних функцій після складання, щоб переконатися, що система готова для глибшого тестування.
Sanity Testing - перевірка основних функцій і фіксованих дефектів після їх виправлення для переконання, що продукт готовий до більш повного тестування. Основна різниця - фокус і мета тестування.

Переваги димового тестування:

- відразу знаходяться проблеми інтеграції;,
- тестування розкриває проблеми на ранній стадії;
- забезпечує певний рівень впевненості в тому, що зміни в програмному забезпеченні не зробили несприятливої дії на основні області системи;
- збій при димовому тестуванні призводить до негайної відмови від цієї збірки програмного забезпечення.


**Декілька важливих особливостей санітарного тестування:**

- є поверхневим тестуванням з концентрацією на детальному тестуванні деяких вибраних функцій;
- є підмножиною регресійного тестування;
- виконується тоді, коли у тестувальників відсутня достатня кількість часу для детального тестування;
- перевірка працездатності зазвичай не документується;
- є коротким, швидким тестуванням для того, щоб переконатися, що зміни працюють так, як очікувалося, і відповідно до технічних документів;
- тестування працездатності виконується для перевірки виправлення незначних помилок і незначних функціональних змін.

**Переваги санітарного тестування:**

- фокусується тільки на певних функціях програмного забезпечення;
- не виходить на рівень структури проекту, тому розробникам дуже важко зрозуміти, як виправити проблеми, виявлені під час перевірки працездатності;
- виконується тільки для деяких обмежених функцій, тому, якщо є які-небудь проблеми з іншими функціями, їх буде складно відловити;
- перевірка працездатності, як правило, не документується, тому ті ж самі перевірки в майбутньому можуть бути випущені.

Приклади використання димового і санітарного тестування
Розглянемо детальніше ці види тестування на прикладі реальних кейсів.

**Приклад димового тестування. Припустимо, що в тестованому проекті є п'ять модулів, таких як:**

- вхід в систему;
- перегляд користувача;
- сторінка відомостей про користувача;
- створення нового користувача;
- створення завдань і так далі.  

Таким чином, в цих п'ятьох модулях, в першу чергу, розробник виконує димове тестування, виконуючи всі основні функції цих модулів, а саме:

- користувач може увійти з дійсними обліковими даними;
- користувач НЕ може увійти з недійсними обліковими даними;
- після входу може бути створений новий користувач або ні;
- чи доступний для використання створений користувач або ні.  

Такий або подібний набір мінімальних тестів завжди виконується командою розробників перед відправкою білда для повної перевірки тестувальниками.

Приклад санітарного тестування. Знову припустимо, що в нашому проекті є п'ять модулів, таких як:

- вхід в систему;
- перегляд користувача;
- сторінка відомостей про користувача;
- створення нового користувача;
- створення завдань і так далі.  

Під час тестування виявився баг на сторінці входу в систему, наприклад, на сторінці входу в систему поле для введення пароля приймає менше шести символів, що не відповідає вимогам, оскільки у вимогах вказано, що пароль має бути не менше шести символів.

Команда тестування повідомила про помилку команду розробників, щоб вони виправили її. Далі команда розробників виправляє помилку і передає її команді тестування, яка перевіряє також і інші модулі додатка, щоб переконатися, що перевірка виправлення помилки не впливає на функціональність інших модулів. Але завжди слід пам'ятати, що група тестування перевіряє тільки екстремальну функціональність модулів, не заглиблюючись в тестування деталей,через відсутність часу, це і є санітарне тестування.

Санітарне тестування виконується після того, як збірка пройшла Smoke тестування і була прийнята командою QA для подальшого тестування. Sanity перевірка включає перевірку основних функціональних можливостей з найдрібнішими деталями, наприклад, чи виправлена проблема з полем для введення пароля і чи не з'явилися ще якісь помилки, пов'язані з цим полем.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **18. Що таке Traceability Matrix**
Матриця відповідності вимог (Requirement Traceability Matrix) – це документ, який відображає та відстежує вимоги користувача за допомогою тестових випадків (тест-кейсів). Він фіксує всі вимоги, запропоновані клієнтом, та дає можливість відстеження вимог в одному документі, який надається наприкінці життєвого циклу розробки програмного забезпечення. Основна мета матриці відповідності вимог – підтвердити, що всі вимоги перевіряються за допомогою тестових випадків, щоб кожна функціональність була перевірена під час тестування програмного забезпечення.
Матриця відповідності містить вимоги з усіма можливими тестовими сценаріями та випадками, а також їхнім поточним станом. Це допомагає команді тестувальників зрозуміти рівень тестування конкретного продукту.

Які параметри включити в матрицю відповідності вимог?

- Ідентифікатор вимоги.
- Тип і опис вимоги.
- Тестові випадки зі статусом.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **19. Що таке Sanity Testing**
Санітарне тестування: використовується щоразу, коли ми отримуємо відносно стабільний білд ПЗ, щоб визначити працездатність у деталях. Іншими словами, тут відбувається валідація того, що важливі частини функціональності системи працюють згідно з вимогами на низькому рівні.

- Націлене на встановлення факту того, що певні частини AUT так само працюють, як годиться, після мінорних змін або виправлень багів
- Метою є перевірити загальний стан системи в деталях, щоб приступити до більш ретельного тестування
- Перевірка дефектів не є метою Sanity
- Санітарне тестування виконується перед регресійним і після smoke-тестів
- Частіше виконується вручну
- Підмножина приймального тестування
- Санітарне може виконуватися без тест-кейсів, але знання тестованої системи обов'язкове

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **20. Що таке End-to-End тест**
Наскрізне тестування - це методологія тестування програмного забезпечення для перевірки потоку додатків від початку до кінця. Метою наскрізного тестування є імітація реального сценарію користувача та перевірка системи, що перевіряється, та її компонентів для інтеграції та цілісності даних.
Ніхто не хоче, щоб про нього знали своїми помилками та недбалістю, як і у випадку з Тестерами. Коли тестувальникам призначається заявка на тестування, з цього моменту вони беруть на себе відповідальність, і вона також виступає в якості платформи для демонстрації своїх практичних та технічних знань з тестування.

Отже, щоб описати це технічно, щоб забезпечити повне тестування, необхідно виконати  "Тестування наскрізне"

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **21. Що таке тестування безпеки**
Тестування безпеки – комплекс досліджень програмного продукту, спрямований на пошук і виявлення дефектів, пов’язаних із збереженням даних користувача, а саме:

Цілісність. Обмеження кола користувачів, що мають доступ до даних, визначення ступеня шкоди, завданої при втраті тих чи інших даних.

Доступність. Являє собою вимоги до того, що ресурси повинні бути доступні авторизованому користувачеві, внутрішньому об’єкту або пристрою. Як правило, чим більш критичний ресурс – тим вище рівень доступності повинен бути.

Конфіденційність. Приховування певних ресурсів або інформації. Під конфіденційністю можна розуміти обмеження доступу до ресурсу деякої категорії користувачів, або іншими словами, за яких умов користувач авторизований отримати доступ до даного ресурсу.

У ході тестування найчастіше тестувальник грає роль зловмисника та починає маніпулювати різними чином додатком:

- Намагається дізнатися пароль за допомогою зовнішніх засобів.
- Атакує систему за допомогою спеціальних утиліт, які аналізують захист.
- Придушує, приголомшує систему (в надії, що вона відмовиться обслуговувати інших клієнтів).
- Цілеспрямовано введить помилки в надії проникнути в систему в ході відновлення.
- Переглядає несекретні дані в надії знайти ключ для входу в систему

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **22. Що таке тестування на основі ризиків**
Risk based testing — це тестування проекту з увагою на ризики.
Risk based testing — використовує ризики як метод для визначення пріоритетності та виокремлення певних тестів у процесі тест дизайну.

Логіка Тест Дизайну

Виходячи із того, що Ризик — це ймовірність виникнення небажаного результату. І цей результат пов’язаний з впливом. Тестування на основі ризику передбачає в першу чергу тестування функціональностей, які мають найбільший вплив та ймовірність збою. І у найбільш критичних місцях.

Risk-based testing включає аналіз та вимірювання метрик у цих критичних місцях

Також може включати використання аналітичних інструментів, які не зовсім належать до компетенції QA, проте допомагають нам обрати нам більш ефективні тести.

Коли недостатньо часу для тестування всіх функціональних можливостей, ми таким самим чином ПРІОРИТЕЗУЄМО.

Головна ЛОГІКА => зменшити загальний ризик. Зменшити ймовірність виникнення дефектів, особливо багів з високим впливом на систему, які можуть вплинути максимально болісно на неї.

Risk-based testing слід розпочинати на початку проекту та використовувати ці знання у тест-плані.

Мета тестування означає зробити проект не абсолютно безризиковим проектом.

А провести тестування за найкращими методологіями управління ризиками для досягнення результату проекту, який співвідносить ризики з якістю, особливостями, бюджетом та графіком.

Як провести Risk-based testing ? Відповідь: дуже просто!

- Складіть пріоритетний перелік ризиків.
- Проведіть тестування, яке вивчає кожен ризик.
- По мірі “випаровування” ризиків і появи нових, спрямовуйте свої тестові зусилля, щоб фокусуватися на поточному скоупі.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **23. Що таке динамічне тестування**
Динамічне тестування – тип тестування, який передбачає запуск програмного коду. Таким чином, аналізується поведінка програми під час її роботи.

Для виконання динамічного тестування необхідно, щоб програмний код, що тестується, був написаний, скомпільований та запущений. При цьому, може виконуватися перевірка зовнішніх параметрів роботи програми: завантаження процесора, використання пам’яті, час відповіді та т.д. – тобто, її продуктивність.

Динамічне тестування є частиною процесу валідації програмного забезпечення.

Окрім того динамічне тестування може включати різні підвиди, кожен з яких залежить від:

- доступу до коду (тестування методом чорного, білого та сірого ящика);
- рівня тестування (модульне, інтеграційне, системне та прийомочне тестування);
- сфери використання програми (функціональне, навантажувальне, тестування безпеки та ін.).

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **24. Що таке "парадокс пестициду"**
На більшості проєктів трапляються такі ситуації, коли чим більше ми тестуємо продукт, тим більший імунітет виробляється у багів, які ми намагаємося знайти, використовуючи наші тестові набори. Коли одні і ті самі тести повторюються знову та знову, то врешті-решт вони перестають знаходити нові баги. У такій ситуації, навіть детально описаний тест-кейсами, функціонал може бути не протестований досить ретельно і до користувачів можуть потрапити серйозні баги.

Так само як і у комах, у багів ПЗ, що тестується може розвинутися опір до одного і того ж пестициду, тобто сформуватися імунітет до вже існуючих тест-кейсів. Такий феномен і називається ефектом пестициду. Цей термін близько 30 років тому придумав американський інженер Борис Бейзер. Суть цього ефекту полягає в тому, що багатократне застосування однакових методів з часом стає неефективним, оскільки шкідники, що вижили, вже мають імунітет.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **25. Опишіть основні фази STLC? Надайте визначення Entry і Exit Criteria**

**Основні фази Циклу життя тестування програмного забезпечення (STLC) та визначення Entry і Exit Criteria:**

1. **Планування:**
   Першою фазою STLC є планування. На цьому етапі формується стратегія тестування, визначаються завдання, ресурси, графік і бюджет тестування. Визначення Entry Criteria включає збір та аналіз вимог, завдань, ресурсів, плану тестування тощо. Exit Criteria можуть включати схвалення плану тестування та наявність всіх необхідних ресурсів.

   **Приклад Entry Criteria:** План тестування затверджено і узгоджено всіма стейкхолдерами.
   
   **Приклад Exit Criteria:** Створено і затверджено план тестування, зібрані всі необхідні ресурси (людські, матеріальні, технічні).

2. **Аналіз вимог:**
   На цьому етапі тестувальники аналізують вимоги до програмного забезпечення, щоб зрозуміти, як воно повинно працювати. В цьому контексті вони також визначають тести, які слід виконати. Entry Criteria тут може включати наявність документації з вимогами.

   **Приклад Entry Criteria:** Документація з вимогами готова та затверджена.

   **Приклад Exit Criteria:** Всі необхідні тести визначені та документовані.

3. **Дизайн тестових випадків:**
   На цьому етапі розробляються конкретні тестові сценарії на основі аналізованих вимог. Це включає створення тест-кейсів, скриптів тестування та інших необхідних документів. Entry Criteria може вимагати наявності визначених вимог та аналізу.

   **Приклад Entry Criteria:** Вимоги зазначені і проаналізовані.

   **Приклад Exit Criteria:** Створені тест-кейси для всіх вимог.

4. **Виконання тестових випадків:**
   На цьому етапі виконуються тест-кейси згідно з попередньо розробленими сценаріями. Вхідним критерієм може бути наявність розроблених тест-кейсів та налаштованого тестового середовища.

   **Приклад Entry Criteria:** Тест-кейси розроблені.

   **Приклад Exit Criteria:** Всі заплановані тест-кейси виконані.

5. **Аналіз результатів тестування:**
   На цьому етапі аналізуються результати виконання тестових випадків. Виявлені дефекти документуються і відправляються на виправлення. Вхідним критерієм може бути завершене виконання тестових випадків.

   **Приклад Entry Criteria:** Виконання тестових випадків завершено.

   **Приклад Exit Criteria:** Дефекти документовані та вислані для виправлення.

6. **Документування та звітність:**
   На цьому етапі створюються звіти та документація, яка включає в себе результати тестування, дефекти, аналіз продукту тощо. Вхідним критерієм може бути завершення тестування та наявність всіх необхідних даних.

   **Приклад Entry Criteria:** Тестування завершено, результати зібрані.

   **Приклад Exit Criteria:** Створені звіти і документація.

7. **Завершення тестування:**
   На останньому етапі процесу STLC проводиться оцінка того, чи виконані всі задачі, чи досягнуті поставлені цілі та якість тестування. Вхідними критеріями можуть бути завершені звіти та документація.

   **Приклад Entry Criteria:** Створені звіти та документація.

   **Приклад Exit Criteria:** Всі задачі та цілі тестування досягнуті.

Ці фази та критерії входу-виходу допомагають забезпечити систематичний та організований підхід до тестування програмного забезпечення та підтримують високу якість продукту.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **26. Що таке Bug, Error, Failure, Fault**

1. **Bug (дефект):**
    Дефект, також відомий як баг або помилка, є несправністю або неправильним функціонуванням програмного продукту. Дефекти можуть виникнути через помилки в коді, недоліки в проектуванні або неправильне виконання функціональності. Наприклад, якщо веб-сторінка відображає неправильний текст на кнопці або програма зависає при відкритті файлу, це можуть бути приклади дефектів.

2. **Error (помилка):**
    Помилка - це невірна дія або неправильний код, які призводять до некоректної роботи програми. Помилки зазвичай виникають під час розробки, і вони можуть бути виправлені перед випуском продукту. Наприклад, якщо програма видає помилку в результаті некоректного математичного розрахунку, це може бути помилка.

3. **Failure (невдача):**
    Невдача - це некоректна робота програмного продукту в реальних умовах, коли вона не відповідає очікуванням користувача або вимогам. Невдачі спричиняють незадовільний досвід користувача і можуть виникнути через дефекти або помилки. Наприклад, якщо браузерне додаток не завантажується або зависає при взаємодії з користувачем, це може бути невдача.

4. **Fault (дефект):**
    Дефект, відомий також як вада або дефективний модуль, - це конкретний елемент програми, який викликає помилку або невдачу. Дефекти можуть бути вбудовані в код під час розробки і можуть призвести до некоректної роботи в окремих частинах програмного продукту. Наприклад, невірна імплементація функції обчислення суми може бути дефектом.

Узагальнюючи, помилки і дефекти у програмному забезпеченні можуть призводити до невдач і відсутності очікуваного функціонування продукту. Розрізняючи ці терміни, команди тестування можуть точніше ідентифікувати, відслідковувати та виправляти проблеми, що виникають під час розробки та експлуатації програмного забезпечення.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **27. Які є атрибути звіту про помилку? Які основні поля для заповнення**

**Атрибути звіту про помилку та основні поля для заповнення:**

Звіти про помилки (баги) є критично важною частиною процесу тестування програмного забезпечення, оскільки вони допомагають ідентифікувати, документувати та виправляти дефекти, які виявлені під час тестування. Для ефективного та якісного звітування про помилки, необхідно дотримуватися певних атрибутів та заповнювати основні поля звіту.

**Основні атрибути та поля звіту про помилку:**

1 - **Заголовок:**  
   Заголовок звіту повинен бути коротким, але інформативним. Він повинен чітко вказувати на основну проблему або опис помилки.

   *Приклад:* 
   
"Помилка при вході до системи з використанням Google-акаунту."

2 - **Опис помилки:**  
   Це докладний опис помилки або дефекту. Варто вказати всі дії, які призвели до помилки, та описати очікуване поведінка порівняно з фактично спостереженим.

   *Приклад:* 
   
"Після натискання кнопки 'Увійти через Google', замість переходу на сторінку авторизації відбувається перенаправлення на головну сторінку."

3 - **Кроки для відтворення:**  
   Цей розділ містить послідовність кроків, необхідних для відтворення помилки. Чітке і точне описання допоможе розробникам легко знайти та виправити дефект.

   *Приклад:*  

   1. Зайти на сторінку авторизації.
   2. Натиснути кнопку "Увійти через Google".
   3. Спостерегти перенаправлення на головну сторінку.

4 - **Очікуване та фактичне поведінка:**  
   Ці поля вказують на те, яка мала б бути правильна поведінка програми (очікувана) та яка фактично відбувається (фактична). Це допомагає розробникам швидше розібратися в проблемі.

   *Приклад:*
   - Очікуване: Після натискання кнопки "Увійти через Google" користувач має бути перенаправлений на сторінку авторизації.
   - Фактичне: Користувач перенаправляється на головну сторінку.

5 - **Прикріплення файлів:**  
   Якщо можливо, до звіту можна додати скріншоти, відео чи інші файли, що допоможуть розуміти проблему. Це особливо корисно для візуалізації складних або незрозумілих ситуацій.

6 - **Приоритет та серйозність:**  
   Зазвичай помилки мають присвоєні рівні приоритету (важливість для виправлення) та серйозності (вплив на систему). Це допомагає розробникам та тестувальникам спрямовувати зусилля на найбільш важливі аспекти.

   *Приклад:*

   - Приоритет: Високий
   - Серйозність: Критична (помилка блокує доступ до системи)

7 - **Середовище:**  
   Вказати, на якому обладнанні, операційній системі та браузері виявлено помилку. Деякі помилки можуть бути специфічними для певних середовищ.

   *Приклад:*

   - Середовище: Windows 10, Google Chrome 92.

8 - **Версія програмного забезпечення:**  
   Якщо дефект стосується певної версії програми, це важливо вказати.

   *Приклад:*

   - Версія ПЗ: 2.1.0

Коректне та докладне заповнення цих атрибутів та полів допомагає розробникам швидше розібратися в дефекті та виправити

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **28. Яка різниця між пріоритетом і серйозністю**

**Серйозність (Severity)** – це атрибут, що характеризує вплив дефекту на працездатність програми.

**Пріоритет (Priority)** – це атрибут, який вказує на черговість виконання завдання або усунення дефекту. Можна сказати, що це інструмент менеджера з планування робіт. Чим вище пріоритет, тим швидше потрібно виправити дефект.

**Градація серйозних дефектів (Severity)**

- **S1 Блокуюча (Blocker)**
  Блокуюча помилка, що приводить додаток в неробочий стан, в результаті якого подальша робота з тестованою системою або її ключовими функціями стає неможлива. Рішення проблеми необхідно для подальшого функціонування системи.

- **S2 Критична (Critical)**
  Критична помилка, неправильно працює ключова бізнес-логіка, діра в системі безпеки, проблема, яка призвела до тимчасового падіння сервера або приводить в неробочий стан деяку частину системи, без можливості вирішення проблеми, використовуючи інші вхідні точки. Рішення проблеми необхідно для подальшої роботи з ключовими функціями тестируемої системою.

- **S3 Значна (Major)**
  Значна помилка, частина основної бізнес-логіки працює некоректно. Помилка не критична або є можливість для роботи з тестованою функцією, використовуючи інші вхідні точки.

- **S4 Незначна (Minor)**
  Незначна помилка, що не порушує бізнес-логіку частини програми, що тестується, очевидна проблема для користувача інтерфейсу.

- **S5 Тривіальна (Trivial)**
  Тривіальна помилка, яка не стосується бізнес-логіки додатка, погано відтворена проблема, малопомітна за допомогою користувацького інтерфейсу, проблема сторонніх бібліотек або сервісів, проблема, не надає ніякого впливу на загальну якість продукту.

**Градація Пріоритету дефекту (Priority)**

- **P1 Високий (High)**
  Помилка повинна бути виправлена якомога швидше, так як її наявність є критичною для проекту.

- **P2 Середній (Medium)**
  Помилка повинна бути виправлена, її наявність не є критичною, але вимагає обов'язкового вирішення.

- **P3 Низький (Low)**
  Помилка повинна бути виправлена, її наявність не є критичною, і не вимагає термінового вирішення.

**Порядок виправлення помилок з їх пріоритетами:**

```High -> Medium -> Low```


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **29. Наведіть приклади серйозної, але не пріоритетної помилки**

Серйозна помилка, яка не є найвищим пріоритетом, може включати ситуації, де функціональність продукту порушена, але це не критично для його базової роботи або основних функцій. Оцінюючи серйозність помилок, необхідно враховувати вплив на користувачів та важливість конкретної функції.

Один із прикладів може бути специфічний стиль відображення повідомлень про помилки на веб-сайті. Якщо стиль не відповідає вимогам дизайну, це може бути помилкою. Однак, ця помилка не впливає на коректну роботу сайту або його здатність надавати основні функції. Така помилка може бути помічена під час тестування і залишитися для подальшого виправлення.

Інший приклад - некоректний порядок відображення даних у звіті. Ця помилка може вплинути на зручність використання звіту, але якщо інформація все одно доступна, це може бути помилка меншого пріоритету. Наприклад, в адміністративній панелі звіти можуть відображатися у зворотньому хронологічному порядку, але це може не відповідати очікуваному порядку.

Важливо враховувати, що значення "серйозності" та "пріоритету" може відрізнятися в різних контекстах та для різних продуктів. У деяких випадках, навіть якщо помилка не критична, вона може бути важливою для поліпшення користувацького досвіду, тому важливо ретельно аналізувати і оцінювати всі знайдені помилки.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **30. В чому різниця між валідацією і верифікацією**

Верифікація (verification): Підтвердження наданням об’єктивних доказів того, що встановлені вимоги були виконані.
Примітки:

1. Термін “верифікований” використовують для позначення відповідного статусу.
2. Діяльність з підтвердження вимоги може включати в себе:
· Здійснення альтернативних розрахунків;
· Порівняння специфікації на новий проект з аналогічною документацією на проект;
· Проведення випробувань і демонстрацій;
· Аналіз документів до їх випуску.

Валідація (validation): Підтвердження наданням об’єктивних доказів того, що вимоги, призначені для конкретного використання або застосування, виконані.
Примітки:

1. Термін “валідація” використовують для позначення відповідного статусу.
2. Умови застосування можуть бути реальними або змодельованими.

Об’єктивне свідчення (objective evidence): Дані, що підтверджують наявність або істинність чого-небудь.
Вимога (requirement): Потреба або очікування, яке встановлено, зазвичай передбачається чи є обов’язковим
Специфікація (specification): Документ, що встановлює вимоги.
Випробування (test): Визначення однієї або декількох характеристик відповідно до встановленої процедури.
[ГОСТ ISO 9000-2011.]

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **31. Навіщо потрібна тестова документація і які її види**
Тестова документація є важною складовою процесу тестування програмного забезпечення, оскільки вона сприяє ефективній організації та плануванню всіх аспектів тестування. Вона забезпечує структурований підхід до роботи тестувальників, допомагає відстежувати процес та результати тестування, а також забезпечує належний рівень документації для комунікації між всіма учасниками проекту, зокрема між розробниками, тестувальниками та менеджерами.

**Важливість тестової документації:**

1. **Планування та організація:** Тестова документація допомагає визначити стратегію тестування, план роботи, обсяг ресурсів та розподіл обов'язків між командою. Наприклад, Тест-План визначає загальний підхід до тестування та допомагає встановити пріоритети.

2. **Визначення тестових вимог:** Тестова документація допомагає чітко визначити тестові вимоги, які повинні бути випробувані. Це дозволяє переконатися, що продукт відповідає вимогам замовника. 

3. **Структурованість і організація:** Велика кількість тестових випробувань вимагає структурованості та систематичного підходу. Документація допомагає зберігати та відстежувати результати тестування, що спрощує процес знаходження та виправлення помилок.

4. **Відстеження результатів:** Тестова документація дозволяє зберігати і відстежувати результати тестування для кожного етапу. Це допомагає швидше виявляти та усувати недоліки.

**Види тестової документації:**

1. **Тест-План:** Детальний план тестування, який описує стратегію, обсяг, ресурси, ризики та графік тестування. 

2. **Тестові Сценарії:** Конкретні інструкції для проведення тестів. Це можуть бути позитивні та негативні сценарії, що описують очікувані результати.

3. **Тестова Документація до Дефектів:** Звіти про виявлені дефекти, які включають опис проблеми, шаги для відтворення та результати тестування.

4. **Traceability Matrix (Матриця Відстеження):** Відображення взаємозв'язку між вимогами, тестовими випробуваннями та їх результатами.

5. **Тестова Документація до Об'єкта Тестування:** Опис основних характеристик, вимог та очікуваних результатів для кожного об'єкта тестування.

6. **Тест-Сценарій для Автоматизованих Тестів:** Докладний опис того, як автоматизований тест повинен бути виконаний.

7. **Тестові Дати та Завдання:** Розклад тестів, терміни виконання та обсяг завдань для членів команди.

**Приклад:**

Допустимо, ви тестуєте веб-додаток для онлайн-магазину. Ви створюєте Тест-План, де вказуєте, що проведете тестування на різних браузерах, зробите функціональне та інтеграційне тестування. Далі, для кожного тестового сценарію ви пишете докладні інструкції, наприклад, "Валідація корзини покупок". У вас також є Traceability Matrix, де відображено, які вимоги покриває кожен тестовий сценарій.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **32. Що таке тест-план? Які елементи він має**
**Тест-план** - це документ, що описує план тестування для конкретного проекту або продукту. Він визначає стратегію, підходи, ресурси, розклад та оцінки вартості тестування. Тест-план є ключовим інструментом, який допомагає організовувати і впорядковувати процес тестування, а також забезпечує загальне розуміння всіх сторін, як планується провести тестування.

**Елементи тест-плану:**

1. **Вступна інформація:**
   Вказується загальна інформація про документ, дату створення, авторів, ідентифікатор проекту і т.д.

2. **Загальний огляд:**
   Описується характеристика продукту, його призначення, основні функції, а також ціль та обсяг тестування.

3. **Стратегія тестування:**
   Пояснюється, які підходи і методи будуть використані під час тестування. Включає розподіл завдань, обрані техніки та підходи до створення тестових сценаріїв.

4. **Об'єкти тестування:**
   Вказуються компоненти, функціональність та модулі, які будуть перевірятися під час тестування.

5. **Вимоги до тестування:**
   Описуються критерії, на основі яких буде оцінюватися успішність тестування, включаючи якість, продуктивність та інші аспекти.

6. **Розклад тестування:**
   Визначається графік проведення різних етапів тестування, а також вказуються терміни для завершення кожної фази.

7. **Бюджет та ресурси:**
   Вказуються обсяги ресурсів, які будуть виділені для тестування, включаючи людські ресурси, обладнання та програмне забезпечення.

8. **Ризики та припущення:**
   Визначаються можливі ризики, які можуть вплинути на процес тестування, а також зроблені припущення, на яких будується план.

9. **Критерії завершеності:**
   Вказуються умови, які повинні бути виконані для завершення кожної фази тестування та для визначення, коли продукт готовий до випуску.

10. **Вимоги до середовища:**
    Описуються обладнання, програмне забезпечення, середовище та конфігурації, які потрібні для виконання тестування.

11. **Подання результатів:**
    Вказуються методи і формати звітності результатів тестування, а також структура документів, які будуть створені.

12. **Завершення тест-плану:**
    Вказується інформація про учасників, які розробили і переглянули тест-план, а також дати підписання та затвердження документа.

**Приклад тест-плану:**

- **Вступна інформація:** Створено: 23.08.2023, Автор: Іван Іванов, Ідентифікатор проекту: PRJ-123.
- **Загальний огляд:** Тестування веб-додатку "OnlineShop". Продукт призначений для покупців, які можуть вибирати товари, додавати їх у кошик, оформлювати замовлення тощо.
- **Стратегія тестування:** Використовувати комбінацію ручного та автоматизованого тестування. Розподіл завдань між тестувальниками з різними спеціалізаціями.
- **Об'єкти тестування:** Веб-сторінки, форми, функціональні кнопки, кошик, система реєстрації та авторизації.
- **Вимоги до тестування:** Успішне завершення тестів на реєстрацію, вхід, додавання товарів, оформлення замовлення, відображення даних користувача.
- **Розклад тестування:** Фаза 1 - Ручне тестування реєстрації та авторизації (з 25.08 до 28.08), Фаза 2 - Автоматизоване тестування кошика (з 29.08 до 31.08) тощо.
- **Бюджет та ресурси:** 2 тестувальники, 1 автоматизатор. Час відведено 160 годин на ручне тестування, 80 годин на автоматизоване.
- **Ризики та припущення:** Можливі затримки через незаплановані зміни в продукті. Припущено, що тестове середовище буде готове до 25.08.
- **Критерії завершеності:** Успішно пройдено всі тестові сценарії для кожної фази. Більше 95% тестів повинні бути успішними.
- **Вимоги до середовища:** Windows 10, Chrome 90+, Firefox 90+, Python 3.8+, Selenium 3.141.0.
- **Подання результатів:** Звіти про тестування будуть складатися у вигляді XLSX-файлів і завантажуватися на спільний сервер.
- **Завершення тест-плану:** Розробник, Тестувальник, Технічний лідер підписали документ. Дата підписання: 23.08.2023.

Такий докладний тест-план допомагає забезпечити систематичний та структурований підхід до тестування, зменшити ризики та забезпечити якість продукту.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **33. Яку обов'язкову інформацію має містити тест-план**

Test plan – це документ, який описує весь обсяг робіт з тестування, починаючи з опису об'єкта тестування, стратегії, розкладу, критеріїв початку і закінчення тестування, до необхідного в процесі роботи обладнання, спеціальних знань, а також оцінки ризиків з варіантами їх вирішення.

**Тест-план призначений для:**

- Врегулювання процесів тестування.
- Пріоритезації завдань.
- Планування ресурсів.
- Обліку програмного забезпечення та людських ресурсів.

Зазвичай, тест-план складає QA-лід команди тестувальників, але його можуть редагувати також тестувальники.

**Основні елементи тест-плану:**

1. **Що необхідно протестувати?**
   Опис об'єкта тестування, включаючи функціональні блоки, обладнання та браузери для виконання тестів.

2. **Як буде проводитися тестування?**
   Детальний опис стратегії тестування та застосовуваних видів тестів.

3. **Коли буде проводитися тестування?**
   План проведення робіт, включаючи підготовку, тестування та аналіз результатів для кожної фази.

4. **Критерії початку тестування**
   Критерії, які визначають готовність до початку тестування, такі як готовність тестової платформи чи наявність необхідної документації.

5. **Критерії закінчення тестування:**
   Умови, які показують завершеність тестування, такі як кількість відкритих багів, успішність усіх тестів та інші.

Якщо відповісти на ці питання при складанні тест-плану, ви отримаєте чорновий варіант документа. Потім його можна доопрацювати, додавши решту необхідної інформації.

**Типи тест-планів:**

- Майстер тест-план (Master test plan): включає високорівневу інформацію, яка рідко змінюється.
- Детальний тест-план (Test plan): гнучкий документ, що оновлюється з урахуванням реального стану проєкту.
- План приймальних випробувань (Product acceptance plan): описує приймальне тестування.

**Заключення:**

Тест-план – важливий елемент процесу тестування, що допомагає організувати роботу тестувальників та забезпечити якість продукту.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **34. Яка різниця між чеклистом і тест-кейсами**

**Тест кейс** - це послідовність дій, які потрібно перевірити.

**Чек-аркуш** - це коротке позначення напрямку для послідовності дій, які потрібно перевірити.

**Тест кейси** пишуться максимально докладно, щоб було зрозуміло будь-якій людині в команді.

**Чек-листи** описують коротко те, що хочемо протестувати.

Розглянемо відмінності тест кейса від чек листа на прикладі.

Припустимо, ми хочемо покласти товар у кошик.

**Тест кейс** можна написати таким чином (приклад тест кейса):

**Порядковий номер:** 1.

**Назва:** Додавання книги в кошик в інтернет-магазині.

**Кроки:**

1. Перейти на сайт test.com.
2. Перейти в розділ Книги.
3. Натиснути на кнопку "В кошик" біля першої книги.
4. Натиснути кнопку "Перейти в кошик".

**Очікуваний результат:**

Відкриється сторінка "Кошик" з одним доданим товаром.

**Пункт чек-листа** в нашому прикладі може виглядати так (приклад пункту чек-листа):

А. Додати книгу в кошик.

І все, тобто ми не описуємо крок за кроком, куди натиснути, що конкретно зробити, а просто вказуємо напрямок, що потрібно зробити таку-то дію, у цьому випадку - додати товар у кошик. А як ми додамо товар у кошик, звідки додамо, куди переходитимемо до цього - це все на розсуд тестувальника, який проводить тестування за цим пунктом чек-листа.


[Back to top ⬆️](#5-qa-manual-qa-automation)

### **35. Обязанності QA**

* вивчення та уточнення вимог до програми у замовника (у великих проєктах цим можуть займатися бізнес-аналітики)
* написання та подальше доопрацювання сценаріїв тестування
* проведення тестування функціоналу ПЗ
* внесення звітів щодо виявлених недоліків у трекінгову систему
* аналіз результатів і показників проведених тестів
* складання ТЗ на усунення знайдених після тестування недоліків
* моніторинг і відстеження правок
* проведення повторних тестів на відсутність знайдених помилок
* аналіз та оптимізація етапів розробки для усунення причин помилок та уникнення повторної їх появи
* робота з тестовою документацією

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **36. Що знаєте про тестування навантаження? У якому випадку слід проводити таке тестування? На якому етапі готовності продукту**

*Навантажувальне тестування (load testing)* - виконання програми з підвищенням навантаження, аж до досягнення запланованих характеристик, і далі з відстеженням поведінки впродовж усього періоду підвищення завантаження системи. При цьому може відбуватися:

* вимірювання часу виконання обраних операцій за певних інтенсивностей виконання цих операцій
* визначення кількості користувачів, які одночасно працюють із додатком
* визначення меж прийнятної продуктивності при збільшенні навантаження (при збільшенні інтенсивності виконання цих операцій)

Проводиться в таких випадках:

* новий проєкт, який ще не проходив навантажувального тестування і настав час аудиту продуктивності
* впровадили велику зміну, яка суттєво впливає на функціонал
* планується участь у великих маркетингових акціях, які залучать великий трафік
* зміна конфігурації стендів 
* оцінка можливостей наявної системи

Зазвичай проводиться заздалегідь перед релізом або очікуваним збільшенням навантаження.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **37. Decision table і як її можна використовувати**

*Таблиця рішень (Decision Table)* - техніка, що допомагає наочно зобразити комбінаторику умов із ТЗ. Приклад нижче.

> **СІ01. Знайти товар і зробити покупку**

> *Легенда*  
> П - користувач  
> С - система

> *Сценарій використання*

> 1. П відкриває список товарів і фільтрує за категорією.
> 2. С відображає товари обраної категорії.
> 3. П бачить цікавий товар і переходить на його картку.
> 4. С відображає картку товару, оцінку покупців та відгуки.
> 5. П вивчає товар і кладе його в кошик.
> 6. С додає товар у кошик.
> 7. П переходить у кошик і оформляє замовлення.
> 8. С зберігає замовлення, надсилає повідомлення на email.

> *Альтернативні варіанти*

> * 1а П фільтрує список за неіснуючою категорією. Система видає помилку. Завершення сценарію.
> * 2а. Товарів не знайдено. Виведення повідомлення про помилку. Завершення сценарію.
> * 2б. Товарів занадто багато. Система виводить перші 100 і пропонує звузити пошук.
> * 5а. П повертається до покупок. Перехід до кроку 1.

> *Параметри*  
> Категорії товарів: сукні, джинси, светри.  
> Час зберігання товару в резерві: 2 години з моменту додавання в кошик.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **38. Що може бути критеріями запуску і завершення тестування**

Загалом, безглуздо абстрактно говорити про критерії початку або завершення тестування, бо воно починається і завершується разом із початком і кінцем усього проєкту загалом.   
Правильніше говорити про тестування як про підпроцес процесу розробки ПЗ. Цей підпроцес складається з цілої серії діяльностей, кожна з яких пов'язана залежностями з іншими діяльностями, зокрема такими, що не належать до тестування.

Критеріями для початку тестування можуть бути обрані:

* завершення функціоналу, який може бути протестований
* досягнення певного етапу розробки

Критеріями для зупинки/завершення тестування можуть бути обрані:

* закінчення часу
* спустошення бюджету
* всі тест кейси пройдено, знайдені баги виправлено і перевірено ще раз

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **39. Приклади підходів для тестування локалізації**

**За наявності локалі.**  

Беремо локаль і проводимо необхідний комплекс операцій для перевірки її якості.

**За відсутності локалі.**  

*Техніка псевдо-локалізації (Pseudo-localization approach)*. У рамках цього підходу потрібно підготувати псевдо-локаль (зробити це може сам тестувальник), використовуючи будь-яку іншу мову та додавши до файлів необхідні дані, наприклад спец.символи певної мови. Також можна додати більшу кількість символів у рядки, щоб перевірити, чи буде обрізатися текст (truncate), адже текст може стати довшим після перекладу на нову локаль і не вміститися у відведений для нього простір. Ще такий підхід допоможе знайти проблему з об'єднанням рядків (concatenation) і проблеми, пов'язані з відображенням шрифту, якщо такі є. Для того, щоб такі проблеми було простіше знайти, то в початок і кінець рядка можна додати який-небудь символ. Наприклад, Microsoft використовує такий підхід ще з 90-х і вставляє квадратні дужки для позначення початку і закінчення рядка.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **40. A/B тестування**

A/B-тестування - експеримент, який дає змогу порівняти дві версії будь-чого, щоб перевірити гіпотези та визначити, яка версія краща.  
Чи повинні кнопки бути чорними або білими, яка навігація краща, який порядок проходження реєстрації найменше відлякує користувачів...  
Користувачі випадковим чином діляться на сегменти.  
Один із сегментів залишається без змін - це контрольний сегмент "A", на основі даних за цим сегментом ми оцінюватимемо ефект від внесених змін.  
Користувачам із сегмента "B" показуємо змінену версію. Щоб отримати статистично значущий результат, дуже важливо виключити вплив сегментів один на одного.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **41. Що таке mock/stub? Які знаєте інструменти для роботи з ними**

*Тестовий двійник (Test Double)* - це всеосяжний термін, який описує всі види фальшивих (fake) залежностей, непридатних до використання в кінцевому продукті (non-production-ready), у тестах. Така залежність має вигляд і поводиться як її аналог, призначений для production, але насправді є спрощеною версією, яка знижує складність і полегшує тестування.

Видів тестових двійників:

* Пустушка (dummy)
* Стаб (stub)
* Шпигун (spy)
* Мок (mock)
* Фейк (fake)

![image](images/test_double.png)

Моки допомагають імітувати і вивчати вихідні (outcoming) взаємодії. Тобто виклики, що здійснюються тестованою системою (SUT) до її залежностей для зміни їхнього стану.

Стаби допомагають імітувати вхідні (incoming) взаємодії. Тобто виклики, що здійснюються SUT до її залежностей для отримання вхідних даних.

![image](images/mock_stub.png)

**Інструменти**  

*Java*: Mockito, EasyMock, JMockit  
*Python*: pyDoubles, Mox, Mockito-python


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **42. Коли потрібно використовувати техніку Pairwise**

> **Короткий варіант відповіді:**

Коли в нас більша кількість комбінацій тестових даних і ми хочемо забезпечити максимальне покриття, протестувавши всі можливі окремі комбінації кожної пари вхідних параметрів.

> **Детальний варіант відповіді:**

Техніка Pairwise, також відома як тестування з урахуванням всіх можливих комбінацій (All-Pairs Testing), використовується для генерації набору тестових випробувань, який покриває всі можливі комбінації вхідних параметрів з меншею кількістю тестів. Ця техніка особливо корисна в таких випадках:

1. **Складність тестування через багато можливих комбінацій параметрів:** Якщо ваша програма має багато параметрів, які можуть приймати різні значення, то генерація тестових наборів з усіма можливими комбінаціями може бути надто обтяжливою задачею. Техніка Pairwise допомагає зменшити кількість тестів, зберігаючи при цьому важливий покриття.

2. **Оптимізація витрат на тестування:** Якщо у вас обмежені ресурси для виконання тестів (наприклад, обмежена кількість тестових середовищ або обмежений час), техніка Pairwise може допомогти скоротити кількість тестів, не втрачаючи при цьому покриття.

3. **Матричні параметри:** Техніка Pairwise особливо корисна, коли вхідні параметри можна представити у вигляді матриці, де кожен параметр має кілька можливих значень, і важливо перевірити, як ці значення взаємодіють.

4. **Тестування на злам (fuzz testing):** Техніка Pairwise може бути використана для тестування безпеки, де важливо випробовувати програму на невірних або некоректних вхідних даних.

5. **Тестування конфігурацій:** При розробці програм, які повинні працювати на різних конфігураціях (наприклад, різних операційних системах, версіях браузерів), Pairwise допомагає зменшити кількість тестів для покриття всіх можливих комбінацій.

Загалом, техніка Pairwise є потужним інструментом для оптимізації тестування, особливо коли кількість можливих комбінацій параметрів є великою, а ресурси для тестування обмежені.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **43. Fuzz-тестування і де його використовують**

*Fuzz testing (фаззинг)* - методика тестування, за якої на вхід програми подаються невалідні, непередбачені або випадкові дані. Основна ідея такого підходу полягає в тому, щоб випадковим чином "мутувати" очікувані програмою вхідні дані в довільних місцях. Усі фаззери працюють приблизно однаково, даючи змогу задавати деякі обмеження на мутування вхідних даних певними байтами або послідовністю байтів. Широко застосовується там, де потрібен високий ступінь надійності.  
Фаззинг можна застосовувати до будь-яких функцій, які обробляють складні дані. Наприклад, бібліотеки стиснення і розпакування, парсери HTTPS і DNS, різні десеріалізатори, мультимедіа кодеки, криптографічні бібліотеки, запити до баз даних. А також для всього, що приймає дані із зовнішнього світу, тобто з недовірених джерел.

*Основні види*:

* Випадковий фаззинг щоразу генерує повністю випадкові значення, які ніяк не залежать від минулих тестів. Випадкові фаззери є більш простими і більш швидкими. Вони можуть дати хороший результат за малу ціну.
* Фаззинг з урахуванням покриття використовує результати минулих тестів для відстеження і подальшого збільшення покриття коду. Такі фаззери можуть заглиблюватися в тестовані дані і для роботи таких фаззерів потрібні набори даних, що подаються на вхід. Ці дані називаються корпус - це мінімальний набір тестових вхідних даних, які можуть згенерувати максимальне покриття коду.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **44. REgexp**
Регулярні вирази (Regular Expressions/REgexp) - формальна мова, яка використовується для пошуку та здійснення маніпуляцій із підрядками в тексті, заснована на використанні метасимволів (символів-джокерів/wildcard characters). Для пошуку використовується рядок-зразок (pattern/шаблон, маска), що складається з символів і метасимволів і задає правило пошуку.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **45. Як змінюється вартість дефекту під час тестування ПЗ**
Що раніше знайдено дефект, то дешевше нам обходиться його виправлення.  
Згодом, вартість виправлень зростає, в той час як вплив учасників проєкту на процес розробки поступово зменшується.

![image](images/defect_price.jpg)

Якщо серйозний дефект виявляється на пізніх етапах розробки, він може залишитися невиправленим, оскільки вартість внесення змін може виявитися занадто високою.  
Крім того, навіть якщо готова програма відповідатиме специфікації, замовник все одно може відмовитися її приймати, якщо сама специфікація була неправильною.  
Проєктна команда могла розробити точно те, що було описано у вимогах, але якщо вимоги було витлумачено неправильно, замовника результат не влаштує.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **46. Які шляхи аналізу бізнесу клієнта? Як визначити доцільність того чи іншого функціоналу**

![IMG](images/BA.webp)

* Передпроєктні роботи (Discovery/Solution Design) - фаза, на якій проводиться обґрунтування доцільності старту розробки.
* Зрозуміти поточний стан бізнесу, його проблеми або можливості, яких йому не вистачає.
* Зрозуміти, що саме бізнес-хоче отримати за результатами розробки та впровадження рішення.
* Визначити підходи до вирішення виявлених проблем і вибрати з них той, який приносить максимальну цінність для замовника.
* Визначити на високому рівні межі рішення та критерії успіху.

* Проектні роботи - фаза, на якій триває активне розроблення та тестування.
* Виявити, описати та узгодити детальні вимоги до рішення.
* Управляти змінами вимог.
* Проводити пріоритизацію вимог.
* Організувати приймальне тестування.

* Постпроєктні роботи - фаза оцінки отриманої цінності/користі.
* Оцінити отриманий результат.
* Обробити зауваження та пропозиції, отримані за результатами експлуатації.
* Оновити базу знань за проєктом.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **47. Яке має бути відсоткове співвідношення між позитивним і негативним тестуванням на проєкті**

> **Короткий варіант відповіді:**

Усі вимоги мають бути покриті позитивними сценаріями, плюс варто робити мінімум хоча б один-два негативних сценарії на кожну вимогу.

> **Детальний варіант відповіді:**

Відсоткове співвідношення між позитивним (positive testing) і негативним (negative testing) тестуванням на проєкті зазвичай залежить від конкретного проекту, його характеристик, ризиків і вимог. Немає жорсткого правила для точного відсоткового розподілу, але ось кілька рекомендацій:

1. **Залежно від типу проекту:** Тип проекту і сфера його застосування можуть визначити, які види тестування є більш важливими. Наприклад, в критичних застосунках, таких як медичні або фінансові системи, негативне тестування може бути більш важливим, і ви можете приділити більше уваги негативним сценаріям.

2. **Проведення обмеженого негативного тестування:** Зазвичай рекомендується приділяти більше уваги позитивному тестуванню, оскільки його мета - переконатися, що програмний продукт виконує очікувані функції належним чином. Але обмежені негативні тести, які перевіряють некоректні входи або невалідні сценарії, також мають бути виконані.

3. **Ризики та особливості проекту:** Якщо на проєкті існують високі ризики, пов'язані з неправильними входами або невалідними даними, то негативне тестування може бути більш важливим.

4. **Аналіз ризиків та вимог:** Проведіть аналіз ризиків, пов'язаних з проектом, і враховуйте вимоги замовника. Якщо замовник вимагає особливу увагу до певних аспектів (наприклад, безпеки чи надійності), то це може вплинути на розподіл зусиль між позитивним і негативним тестуванням.

5. **Врахування досвіду команди:** Досвід тестерів і розробників може також вплинути на відсотковий розподіл. Досвідчені фахівці можуть бути більш вправні в знаходженні негативних сценаріїв.

Загальною практикою є те, що більшість тестів (приблизно 70-80%) повинні бути позитивними, а решта (20-30%) - негативними. Проте, це тільки загальна рекомендація, і кінцевий розподіл повинен відображати конкретні вимоги та особливості проекту. Важливо мати баланс між обома видами тестування для забезпечення високої якості продукту та забезпечення безпеки та надійності.



[Back to top ⬆️](#5-qa-manual-qa-automation)
### **48. Чи є різниця між bug leakage і bug release**

*Bug release* - баги, які були випущені в реліз і команда розробки про них знає.

*Bug leakage* - невідомі команді розробки, баги, які знаходять користувачі після релізу.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **49. Що потрібно покривати тест-кейсами, а що вважається надлишковою витратою часу і грошей? Коли недоцільно писати тест-кейси**

Насамперед тестами покривається основний функціонал застосунку і далі по низхідній. Однак тест-кейси пишуться з огляду на вимоги бізнесу. Можливо, що вимоги бізнесу до тестування не покриватимуть основний функціонал. У такій ситуації потрібне уточнення вимог у замовника.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **50. Як порахувати Cyclomatic complexity**
Цикломатична складність програми (Cyclomatic Complexity of a Program) - структурна/топологічна міра складності комп'ютерної програми. Розроблена Томасом Дж.Маккейбом у 1976 році.  
Під час обчислення цикломатичної складності використовується граф потоку керування програми. Вузли графа відповідають неподільним групам команд програми, вони з'єднані орієнтованими ребрами, якщо групу команд, що відповідає другому вузлу, може бути виконано безпосередньо після групи команд першого вузла. Цикломатична складність може бути також обчислена для окремих функцій, модулів, методів або класів у межах програми.  
Їй на заміну прийшла Cognitive Complexity розроблена у 2017 році компанією Sonar Source.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **51. У чому основна різниця між defect detection percentage і defect removal efficiency**
*Відсоток виявлення дефектів (Defect Detection Percentage/DDP або Defect Removal Efficiency/DRE)* - відсоток виявлення дефектів показує міру ефективності тестування. Розраховується як відношення дефектів, виявлених до випуску і після випуску ПЗ. DDP можна визначити у вигляді такої формули:

    DDP = (Кількість дефектів на момент випуску версії ПЗ / Загальна кількість дефектів виявлених командою тестування і замовниками) * 100

*Ефективність виявлення дефектів (Defect Detection Efficiency/DDE)* - параметр, який розраховується для забезпечення якості та ефективності ПЗ. Це кількість дефектів або помилок, які були створені і були виявлені на одному етапі розробки, і поділена на загальну кількість помилок, створених на цьому етапі. Відкинуті дефекти не враховуються. DDE можна розрахувати на будь-якому етапі життєвого циклу розробки ПЗ (SDLC), коли дефекти можуть бути створені та виявлені. Фаза, в яку створено дефект, визначається шляхом аналізу. DDE можна визначити у вигляді такої формули:

    DDE = (Кількість дефектів, створених і виявлених на етапі / Загальна кількість дефектів, створених на цьому етапі) * 100

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **52. Які моделі risk-based testing ви знаєте**
*FMEA(Failure Mode and Effect Analysis)* - є найбільш популярним підходом до тестування, що базується на ризиках. Це модель аналізу причин і наслідків відмов системи, яка визначає потенційні дефекти і причини їх виникнення. Робота за такою моделлю передбачає, що команда проєкту намагається визначити всі компоненти, процеси, модулі, в яких може статися збій. Цей збій з різною часткою ймовірності може призвести до погіршення якості ПЗ. Для вимірювання таких збоїв використовують 3 показники: серйозність, пріоритет і ймовірність. Кожному ризику призначається Risk Priority Number (RPN) і залежно від показників закладається глибина тестування.

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **53. Тестування API? Інструменти**
*API (програмний інтерфейс додатка)* - набір процедур, протоколів та інструментів для створення програмних додатків. API визначає, як додаток має взаємодіяти з іншими програмами. 

Тестування API передбачає перевірку правильності цих взаємодій.

**Інструменти**:
Swagger, SoapUI, Postman

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **54. Load, Stress та Stability testing? Якими інструментами користуються для їх виконання**
*Навантажувальне тестування (load testing)* - виконання програми з підвищенням навантаження, аж до досягнення запланованих характеристик, і далі з відстеження поведінки на всьому протязі підвищення завантаження системи.
![IMG](images/load_test.png)

*Стресове тестування (stress testing)* - тестування, що оцінює систему на граничних значеннях робочих навантажень або за їх межами, або ж у стані обмежених ресурсів, таких як пам'ять або доступ до сервера.
![IMG](images/stress_test.png)

*Тестування стабільності (stability testing)* - перевірка працездатності програми при тривалому (багатогодинному) тестуванні із середнім рівнем навантаження. Часи виконання операцій можуть грати у цьому вигляді тестування другорядну роль. У цьому перше місце виходить відсутність витоків пам'яті, перезапусків серверів під навантаженням тощо.
![IMG](images/stability_test.png)

**Інструменти**:
LoadRunner, Apache JMeter, Gatling

---

# **AQA (Automation QA)**

# *Selenium*

---

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **55. Як ви будуватимете і впроваджуватимете стратегію з автоматизації тестування**

https://habr.com/ua/post/275171/

3 варіанти стратегій, характерних для початку розгортання автоматизації.

***1. Стратегія Let's try***

Застосовується в тому випадку, коли АТ ні на проекті, ні в компанії ніколи не було, і планується обережний старт з помірним виділенням ресурсів.

Має сенс застосовувати у разі, коли:

* Відсутні точні цілі автоматизації (покрити 40% коду конкретного модуля до певної дати, зменшення витрат на ручне тестування тощо).
* АТ на проекті раніше ніколи не застосовувалася.
* У тестувальників відсутній (або дуже малий) досвід АТ.
* Виділені ресурси помірні чи низькі.

Опис стратегії:

* Більше уваги приділяти підготовчим етапам тестування (складання тест-планів, тест-кейсів тощо).
* Більше уваги приділяти інструментам, які можна використовувати як допомогу у ручному тестуванні.
* Більше експериментувати з технологіями та методологіями АТ. Ніхто не чекає на термінові результати і можна експериментувати.
* Працювати з проектом, починаючи з верхнього рівня, спочатку не заглиблюючись в автоматизацію конкретних модулів.

***2. Стратегія Here the target***

Особливістю стратегії є орієнтування на конкретний результат. Вибирається/визначається мета нового етапу АТ, і завдання орієнтуються досягнення цього результату.

Має сенс застосовувати у разі, коли:

* Коли на проекті вже проведено попередню роботу, є якийсь бекграунд у вигляді тест-планів, тест-кейсів, автотестів попереднього етапу АТ.
* Є конкретна мета АТ (не глобальна - 80% автотестів за півроку, а скоріше 50% автотестів конкретного модуля за місяць)
* Для виконання конкретної мети обрані конкретні інструменти, оптимально якщо спеціалісти мають певний технічний бекграунд по роботі з інструментами.

Опис стратегії:

* Поступальна стратегія, яка чимось нагадує Agile методології розробки. Рух вперед етапами. Покриття автотестами модуля за модулем, до виконання мета завдань виду (80% за півроку).
* На кожен етап виставляється нова мета (найімовірніше продовжує останню виконану мету, але не обов'язково), і вибираються інструменти для реалізації цієї мети.
* Глибоке фокусування на конкретну мету, написання тест-кейсів, автотестів, не для всього проекту, а виключно під конкретне завдання.

***1.3 Стратегія «Operation Uranum»***

По суті, стратегія — постійна і методична робота над АТ за пріоритетами, що виставляються раз на 2-3 тижні. Оптимально - наявність постійно працює саме над автоматизацією людини, яка не особливо відволікається на сторонні завдання.

Має сенс застосовувати у разі, коли:

* Відсутні конкретні цілі, є лише загальне побажання «щоб усе було добре». Якщо Here the target нагадує за принципом роботи Agile, то дана стратегія близька за духом до методології Waterfall.
* Є ресурс у вигляді хоча б одного постійно діючого на проекті людини, щільно зайнятого завданням автоматизації.
* Немає чітко виражених цілей АТ, проте є побажання (пріоритети), які можна виставити на досить тривалий період часу (дані модулі більш важливі, ніж ті, більше помилок традиційно в бекенді/фронтенді, тому великі зусилля варто спрямувати на нього).

Опис стратегії:

* Ідея стратегії описана вище, постійна та методична робота з урахуванням виставлених пріоритетів.
* На початку потрібен упор у базову частину, оскільки так чи інакше в рамках даної стратегії автоматизується весь проект без повного фокусування на конкретних модулях.

Стратегія може бути представлена як у вигляді традиційно розписаного документа, так і у наочному форматі
![IMG](images/strategy.png)



[Back to top ⬆️](#5-qa-manual-qa-automation)
### **56. Як обробляти браузерні повідомлення (alerts)**

```javascript
Alert alert = driver.switchTo().alert();
alert.getText();
alert.sendkeys(String stringToSend);
alert.accept(); / alert.dismiss();
```

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **57. Концепція дизайну Appium**

Appium - HTTP-сервер, написаний на платформі Node.js, який управляє сесіями iOS та Android, використовуючи дротовий протокол WebSON JSON.  
Отже, перед ініціалізацією сервера Appium Node.js має бути попередньо встановлений у системі.
Коли Appium завантажено та встановлено, на нашому комп'ютері налаштовується сервер, який надає REST API.  
Він отримує запит на підключення та команду від клієнта та виконує цю команду на мобільних пристроях (Android/iOS)  
Він відповідає HTTP-відповідями. Знову ж таки, щоб виконати цей запит, він використовує платформи автоматизації мобільних тестів для управління інтерфейсом додатків.  

Обмеження:

* Інструменти Apple для iOS (інструменти доступні тільки в Xcode 3.0 або пізнішої версії з OS X v10.5 і пізнішої версії)
* Google UIAutomator для Android API рівня 16 або вище
* Selendroid для Android API рівня 15 або нижче


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **58. Electron? Як використовувати Selenium для тестування програм на його основ**

*Electron* — це фреймворк для розробки настільних програм з використанням HTML, CSS та JavaScript. Такі програми можуть працювати на різних платформах. Серед них – Windows, Mac та Linux.
В основі Electron лежать проекти Chromium та Node.js, об'єднані в єдине середовище, що забезпечує роботу програм. Це дає можливість використовувати веб-технології при розробці настільних програм.

*JS приклад для тесту Electron програми з використанням Selenium*:
```js
const webdriver = require('selenium-webdriver')
const driver = new webdriver.Builder()
   // The "9515" є портом зареєстрованим ChromeDriver.
   .usingServer('http://localhost:9515')
   .withCapabilities({
     'goog:chromeOptions': {
       // Тут є шлях до нашого електронного binary.
       binary: '/Path-to-Your-App.app/Contents/MacOS/Electron'
     }
   })
   // note: use .forBrowser('electron') for selenium-webdriver <= 3.6.0
   .forBrowser('chrome')
   .build()
driver.get('http://www.google.com')
driver.quit()
```

# **Тестова інфраструктура**

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **59. Що таке і чим відрізняються віртуальна машина, симулятор та емулятор**

*Віртуалізація* – приховування конкретної реалізації за універсальним стандартизованим методом звернення до ресурсів. Інакше кажучи, це створення абстракції над апаратним забезпеченням.

*Повна емуляція (симуляція)* - віртуальна машина повністю віртуалізує все апаратне забезпечення при збереженні гостьової ОС у постійному вигляді. Такий підхід дозволяє емулювати різні апаратні архітектури. Основний мінус даного підходу полягає у високій ресурсозатратності.

*Часткова емуляція (нативна віртуалізація)* - віртуальна машина віртуалізує лише необхідну кількість апаратного забезпечення, щоб вона могла бути запущена ізольовано. Цей вид віртуалізації дозволяє суттєво збільшити швидкодію гостьових систем, наближаючи його до швидкодії фізичної платформи, за рахунок застосування гіпервізора, що є сполучною ланкою між гостьовими системами та апаратурою.

*Гіпервізор (Virtual Machine Monitor/Монітор віртуальних машин)* - спеціальний «прошарок» між гостьовою ОС та обладнанням, що дозволяє гостьовій системі безпосередньо звертатися до ресурсів апаратного забезпечення.



[Back to top ⬆️](#5-qa-manual-qa-automation)
### **60. Контейнер і чим він відрізняється від віртуальної машини**

*Контейнер* - це абстракція на рівні програми, що поєднує код та залежності. Контейнери реалізуються поверх ядра ОС вузла (яке можна вважати своєрідним фундаментом ОС) і містять лише програми та деякі API-інтерфейси та служби ОС, що працюють у режимі користувача.
На відміну від контейнерів, віртуальні машини працюють під керуванням повноцінної ОС із власним ядром.

**Архітектура контейнера**

![IMG](images/container.svg)

**Архітектура віртуальної машини**

![IMG](images/virtual_machine.svg)


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **61. IaaS та PaaS? Приклади використання**

*IaaS (Infrastructure as a Service/інфраструктура як послуга)*.  
Сюди відносять обчислювальні ресурси: віртуальні сервери, сховища, мережі. Це щось на зразок віртуальних «комп'ютерів», на які можна встановити будь-що: ОС, ПЗ, додатки.

Постачальник IaaS (інфраструктури як сервісу), або хмарний провайдер, вже все купив та зібрав, забезпечив сервери електрикою та інтернетом. Вам залишається лише підключитися до цих обчислювальних потужностей через інтернет та використовувати їх для своїх цілей.

**Приклади IaaS**:

* Перенесення IT-систем у хмару
* Економія на інфраструктурі
* Швидкий запуск бізнесу
* Розширення інфраструктури
* Інфраструктура для компаній з стрибками попиту
* Розробка та тестування

*PaaS (Platform as a Service/платформа як послуга)* - вже налаштовані інструменти (платформи) під різні завдання.

Ключова відмінність PaaS від IaaS в тому, що тут у вас є певні інструменти, наприклад система управління БД, середовище машинного навчання або обробки big data.  
Їх потрібно налаштувати під потреби компанії, але не треба будувати з нуля. Що дозволяє заощаджувати час розробників.  
Наприклад, не потрібно возитися з розробкою БД, можна просто завантажити в неї інформацію та працювати.  

При цьому немає доступу до ОС, налаштувань віртуальних серверів, що лежать в основі PaaS, а також до налаштувань низької рівня самої платформи.  
Провайдер бере на себе їхню оптимальну конфігурацію і знімає з вас необхідність стежити за налаштуваннями, оновленнями, масштабуванням та безпекою.  
Ви отримуєте доступ лише до інтерфейсів самої платформи.

**Приклади PaaS**:

* БД
* Розробка додатків у контейнерах
* Аналітика великих даних
* Машинне навчання

*SaaS (Software as a Service/програмне забезпечення як сервіс)* — повністю налаштована і готова до роботи програма, що виконує певні функції. Єдина відмінність технології SaaS від програми на смартфоні чи комп'ютері в тому, що сам софт знаходиться у хмарі.

**Приклади SaaS**:

* електронна пошта
* CRM-системи
* планувальники завдань
* веб-конструктори для створення сайтів
* платформи для ведення блогів


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **62. Configuration Management**

*Configuration Management (управління конфігурацією проекту)* – ідентифікація, створення, підтримання та контроль конфігурації в ході проекту.

**Основне завдання**: у будь-який час мати доступ до 100% актуальної версії конфігураційного елемента, які необхідно використовувати, і бути впевненим, що жоден конфігураційний елемент не конфліктує з іншими конфігураційними елементами.

**Етапи**:  

1. Ідентифікація конфігурації проекту та створення початкової (базової) конфігурації проекту
    * Початкова конфігурація продукту
    * Початкова конфігурація проекту
2. Розробка плану управління конфігурацією проекту
3. Контроль зміни під час проекту


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **63. SSH і як ним користуватися**

*SSH(Secure Shell)* - протокол віддаленого керування комп'ютером з ОС Linux. В основному ssh використовується для віддаленого керування серверами через термінал, але може використовуватися для доступу до будь-яких пристроїв з Linux.

**Підключитися**:

```shell
$ssh user@host
```


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **64. Bash і Batch скрипти? Для чого їх використовують**

*Bash-скрипти (shell script)* - сценарії командного рядка, написані для оболонки bash для Unix-подібних ОС.

*Batch-файл (пакетний файл/батнік)* — сценарії командного рядка, MS-DOS, OS/2 або Windows.

*Сценарії командного рядка* — набори тих самих команд, які можна вводити з клавіатури, зібрані у файли та об'єднані якоюсь спільною метою. У цьому результати роботи команд можуть бути або самостійну цінність, або бути вхідними даними інших команд. Є потужним способом автоматизації дій, що часто виконуються.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **65. Різниця між авторизацією та автентифікацією**

*Ідентифікація* — процедура, в результаті виконання якої для суб'єкта ідентифікації виявляється його ідентифікатор, який однозначно визначає цього суб'єкта в інформаційній системі.

*Аутентифікація* — процедура автентифікації, наприклад автентифікація користувача шляхом порівняння введеного ним пароля з паролем збереженим у базі даних.

*Авторизація* — надання певній особі чи групі осіб прав виконання певних дій.

**Приклад**:

* Користувач вказує логін -> система розпізнає його як існуючий (***ідентифікація***)
* користувач вводить пароль -> пароль збігся -> система погоджується, що користувач, схоже, дійсно справжній (***аутентифікація***)
* користувач правильно вводить додатковий одноразовий код -> система остаточно погоджується, що це справжній власник облікового запису (***двофакторна аутентифікація***)
* система надасть користувачеві право читати листи у його поштовій скриньці (***авторизація***)

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **66. Чи може сервер відправити код 400, якщо проблема на його стороні**

*400 (Bad Request)* - безпосередньо пов'язані з клієнтом (браузером, наприклад) і натякає те що, що відправлений запит із боку користувача призводить до збою ще до того, як його обробить сервер, по крайнього заходу вважає сам сервер. Найчастіше сервер відправляє цей код, коли несправність не підходить більше ні під одну категорію помилок.

**Через що спливає Bad Request**:

1. Некоректно налаштовані HTTP-заголовки у запиті. Деякі програми та сайти моніторять заголовки щодо наявності в них чогось підозрілого. Якщо запит не відповідає очікуванням сервера, то висока ймовірність появи помилки 400 (це завжди вина користувача).
2. Якщо клієнт намагається завантажити на сервер файл надто великого розміру. На більшості сайтів є обмеження за розміром даних, що завантажуються. Причому обмеження може бути як 2 гігабайти, так і 600 кілобайт.
3. Користувач намагається отримати доступ до неіснуючої сторінки. Тобто в браузер банально ввели посилання з друкарською помилкою, некоректним доменом або піддоменом.
4. Застарілі або змінені файли cookie. Сервер може сприйняти заміну файлів cookie як спробу атакувати або скористатися дірою в безпеці. Такі запити відразу блокуються.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **67. Як перевірити обрив з'єднання WebSocket**

```js

//Властивість
socket.readyState
```

* 0 – CONNECTING - з'єднання ще не встановлено
* 1 - OPEN - обмін даними
* 2 - CLOSING - з'єднання закривається
* 3 – CLOSED - з'єднання закрите


[Back to top ⬆️](#5-qa-manual-qa-automation)

### **68. Основні види вразливості веб-додатків**

* *Ін'єкції*. Вразливості такого класу починаються SQL-ін'єкціями, у різних варіаціях, і замикаються RCE - віддаленим виконанням коду.
* *XSS (Міжсайтовий скриптинг)* - вразливість, що зустрічається на даний момент рідше, ніж раніше, але незважаючи на це не стала менш небезпечною. Особливо для користувачів, адже атака XSS націлена саме на них. Загалом зловмисник впроваджує скрипт у веб-додаток, який спрацьовує для кожного користувача, який відвідав шкідливу сторінку.
* *LFI/RFI*. Уразливості даного класу дозволяють зловмисникам через браузер включати локальні та віддалені файли на сервері у відповідь від веб-програми. Цей пролом є там, де відсутня коректна обробка вхідних даних, якою може маніпулювати зловмисник, інжектувати символи типу path traversal і включати інші файли з веб-сервера.
* *JSON Injection* - Проста ін'єкція JSON на стороні сервера може бути виконана для викрадення cookie.
* *JSON Hijacking (Захоплення JSON)* — атака, в певному сенсі схожа на підробку міжсайтових запитів (CSRF), коли зловмисник намагається перехопити дані JSON, надіслані веб-додатку з веб-сервера.
* *Атака зовнішньої сутності XML (XML External Entity/XXE)* — тип атаки, в якому використовується широко доступна, але рідко використовується функція синтаксичних аналізаторів XML. Використовуючи XXE, зловмисник може викликати відмову в обслуговуванні (DoS), а також отримати доступ до локального та віддаленого контенту та служб. XXE може використовуватися для виконання підробки запитів на стороні сервера (SSRF), змушуючи веб-програму виконувати запити до інших програм. У деяких випадках за допомогою XXE може навіть виконати сканування портів та віддалене виконання коду.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **69. Які інструменти для тестування Web performance client-side знаєте**

Для тестування продуктивності веб-сторінок (client-side performance testing) існують різні інструменти, які допомагають виміряти та аналізувати продуктивність сторінок у веб-браузері. Ось кілька популярних інструментів для тестування продуктивності клієнтської частини:

<ol>
  <li>
    <strong>Lighthouse (Google Chrome DevTools):</strong>
    <ul>
      <li>Lighthouse є вбудованим інструментом у Google Chrome DevTools.</li>
      <li>Він надає звіти про продуктивність веб-сторінки, включаючи оцінки швидкодії, доступність, передові практики та інше.</li>
      <li>Запускається просто у веб-браузері та надає докладну інформацію про різні аспекти продуктивності.</li>
    </ul>
  </li>
  <li>
    <strong>WebPageTest:</strong>
    <ul>
      <li>WebPageTest дозволяє виконувати тести продуктивності з різних точок світу із різними конфігураціями веб-браузерів та мережі.</li>
      <li>Він надає розширені налаштування та дозволяє аналізувати завантаження сторінок у веб-браузері.</li>
    </ul>
  </li>
  <li>
    <strong>GTmetrix:</strong>
    <ul>
      <li>GTmetrix проводить аналіз продуктивності сторінок на основі Lighthouse та PageSpeed Insights в різних браузерах.</li>
      <li>Він надає рейтинги та рекомендації щодо покращення продуктивності.</li>
    </ul>
  </li>
  <li>
    <strong>PageSpeed Insights (Google):</strong>
    <ul>
      <li>PageSpeed Insights - це інструмент від Google, який аналізує швидкодію мобільних та настільних версій веб-сторінок.</li>
      <li>Він надає оцінки та рекомендації щодо оптимізації швидкодії.</li>
    </ul>
  </li>
  <li>
    <strong>YSlow:</strong>
    <ul>
      <li>YSlow - це браузерний плагін, який вимірює різні аспекти продуктивності сторінки та надає рекомендації щодо покращення.</li>
    </ul>
  </li>
  <li>
    <strong>Sitespeed.io:</strong>
    <ul>
      <li>Sitespeed.io - це інструмент командного рядка для тестування продуктивності веб-сайтів.</li>
      <li>Він дозволяє автоматизувати тести, використовуючи різні браузери та конфігурації.</li>
    </ul>
  </li>
</ol>

Ці інструменти дозволяють вам аналізувати різні аспекти продуктивності, такі як час завантаження, кешування, оптимізація зображень, мінімізація файлів CSS та JavaScript, та інші аспекти, що впливають на швидкодію веб-сторінок. Вони можуть бути корисні для виявлення та виправлення можливих проблем продуктивності, які можуть впливати на користувацький досвід.



[Back to top ⬆️](#5-qa-manual-qa-automation)
### **70. Cніфери? Які знаєте**

*Аналізатор трафіку (sniffer/сніфер)* — програма або пристрій для перехоплення та аналізу мережевого трафіку (свого та/або чужого).

**Види**:

* апаратні
* програмні
* апаратно-програмні
* онлайн-аплети

**Відомі сніфери:**

* Wireshark/Ethereal
* ZxSniffer
* IRIS


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **71. Різниця між DROP та TRUNCATE**

**Команди SQL**
https://tproger.ru/translations/sql-recap/

*DROP (DDL команда)* - видалення структури таблиці. Видаляє також всі індекси, рядки, обмеження та тригери таблиці. Функції та процедури, що залежать від таблиці, залишаться, але стануть недійсними. Тригери DML не спрацьовують. Відкат не підтримується. Не можна використовувати з оператором WHERE.

*DELETE (DML команда)* - видаляє одну чи кілька рядків з таблиці чи уявлення, у своїй ця операція завжди повністю реєструється у журналі транзакцій, тобто. кожен віддалений рядок. Виконується з використанням блокування кожного рядка, що видаляється. Може активувати тригер. Підтримка відкату. Може використовуватися з виразом WHERE.

*TRUNCATE (DDL команда)* - видаляє всі рядки в таблиці, не записуючи журнал транзакцій видалення окремих рядків даних. Видалити всі дані в таблиці, але не видалити структуру таблиці. У разі видалення всіх записів блокується вся таблиця. Не може використовуватися з оператором where. Відкат не підтримується.

TRUNCATE TABLE схожа на інструкцію DELETE без пропозиції WHERE, але вона виконується швидше і вимагає менше ресурсів.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **72. Функція CASE**

*CASE* перевіряє істинність набору умов та залежно від результату перевірки може повертати той чи інший результат.

Має два формати (обидва підтримують додатковий аргумент ELSE):

* простий вираз CASE для визначення результату порівнює вираз із набором простих виразів
* пошуковий вираз CASE для визначення результату обчислює набір логічних виразів


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **73. Що таке collation**

*Collation* - параметр вказує SQL серверу, як потрібно сортувати та порівнювати рядки. Наприклад, різні чи ні рядки “Apple” та “apple” залежить від зазначеного Collation.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **74. Що таке схема GraphQL**

*GraphQL Schema* – опис типів даних на сервері, зв'язків між ними та логіки отримання цих самих даних.

**Включає параметри**:

* *query* - для операцій отримання даних
* *mutation* - для операцій зміни даних
* *subscription* - для підписки на події

Обов'язковим параметром є лише query, без нього схема просто не запуститься.

**Стан операцій у GraphQL**:

* *stateless* - всі операції в query і mutation повинні бути без стану, тобто. якщо в кластері багато машин, що обслуговують запити клієнтів, то неважливо на який із серверів прилетів запит. Його може виконати будь-яка нода.
* *statefull* - має бути в операцій subscription, т.к. потрібне встановлення постійного підключення з клієнтом, зберігання даних про підписки, механізм перепідключення та відновлення даних про існуючі підписки. Пакет graphql ніяк не допомагає у вирішенні цих адмінських проблем.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **75. Різниця між OLTP та OLAP**

*OLTP (Online Transaction Processing/оперативна обробка транзакцій)* - метод проведення транзакцій у режимі реального часу з використанням онлайнової БД, яка автоматично оновлюється в міру здійснення транзакцій. Такі підприємства, як банки, готелі та ресторани, часто використовують OLTP, щоб їхні співробітники та клієнти могли одночасно та ефективно виконувати кілька транзакцій у реальному часі, зберігаючи при цьому точність даних. У міру здійснення транзакцій системи OLTP автоматично оновлюють залишки на рахунках і зберігають іншу важливу інформацію, таку як дата і час. Зазвичай це реляційні БД.

*OLAP (Online Analytical Processing/оперативна аналітична обробка)* - сервіс для аналізу великого обсягу даних з кількох вимірів. Тут вимір відноситься до елемента певного набору даних. Наприклад, якщо компанія володіє даними про свої рекламні кампанії, включаючи такі елементи, як вплив на споживачів, тривалість реклами, дохід від продукту та вартість реклами, вона може використовувати OLAP для сортування та аналізу даних по кожному елементу. Підприємства часто використовують OLAP для складних аналітичних розрахунків, інтелектуального аналізу даних, фінансового аналізу, складання бюджету та прогнозування. Зазвичай це багатовимірні БД.

*Нормалізація* - має на увазі зберігання інформації максимально просто і не надмірно.
Максимально просто: не зберігати в одному стовпці ПІБ, а зробити 3 окремі.
Не надмірно: прізвище клієнта має зберігатися лише у довіднику клієнтів, і його не потрібно додавати у зроблені клієнтом замовлення.
*Денормалізація* - процес протилежний нормалізації.

**Ключові відмінності**:

* OLAP – категорія програмних інструментів, які аналізують дані, що зберігаються у БД, тоді як OLTP підтримує орієнтовані на транзакції додатки у трирівневій архітектурі.
* OLAP створює єдину платформу для всіх типів потреб бізнес-аналізу, яка включає планування, бюджетування, прогнозування та аналіз, а OLTP корисний для адміністрування повсякденних транзакцій організації.
* OLAP характеризується великим обсягом даних, тоді як OLTP характеризується великою кількістю коротких онлайн-транзакцій.
* У OLAP сховище даних створюється унікальним чином, щоб у нього можна було інтегрувати різні джерела даних для побудови консолідованої БД, тоді як OLTP використовує традиційні СУБД.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **76. Типи реплікації в SQL Server?**
*Реплікація* - набір технологій копіювання та розповсюдження даних та об'єктів БД між БД, а також синхронізації БД для підтримки узгодженості.

* Реплікація транзакцій - зміни на видавця доставляються передплатнику в міру їх появи (майже в реальному часі). Зміни даних застосовуються на передплатнику у тому порядку й у межах транзакцій, у яких вони виконувались у видавця.
* Реплікація злиттям – дані можна змінювати як на видавці, так і на передплатнику, а також відстежувати за допомогою тригерів. Передплатник синхронізується з видавцем під час підключення до мережі та обмінюється з ним усіма рядками, які змінилися з часу останньої синхронізації видавця та передплатника.
* Реплікація моментальних знімків - моментальний знімок видавця застосовується до передплатника. Дані розповсюджуються точно у тому вигляді, в якому вони були представлені у певний момент часу. Оновлення даних не відстежується. Під час синхронізації формується моментальний знімок і надсилається передплатникам повністю.
* Однорангова реплікація - заснована на реплікації транзакцій, поширює узгоджені лише на рівні транзакцій зміни між кількома екземплярами сервера майже реальному часі.
* Двонаправлена реплікація - являє собою особливу топологію реплікації транзакцій, яка дозволяє двом серверам обмінюватися змінами один з одним: кожен сервер публікує дані, після чого підписується на публікацію з тими самими даними від іншого сервера.
* Попередні підписки - засновані на реплікації транзакцій. Коли дані для оновлюваної передплати оновлюються на передплатнику, вони спочатку поширюються на видавця, а потім на інших передплатників.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **77. Self Join**

*SELF JOIN* - використовується для поєднання таблиці з нею самою таким чином, ніби це дві різні таблиці, тимчасово перейменовуючи одну з них. Потрібен тоді, коли у різних полів однієї таблиці можуть бути однакові значення. Наприклад, той самий учасник музичного гурту може бути і вокалістом, і, наприклад, клавішником.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **78. Що такое тестування**

> **Короткий варіант відповіді:**

*Тестування ПЗ (Software Testing)* - перевірка відповідності між реальною та очікуваною поведінкою програми, що здійснюється на кінцевому наборі тестів, обраному певним чином.

> **Детальний варіант відповіді:**

Тестування (software testing) - це процес перевірки програмного продукту або системи для визначення, чи відповідає вона заданим вимогам і чи працює вона належним чином. Основна мета тестування полягає в виявленні помилок, недоліків та несоответствий у програмному коді, щоб їх виправити та забезпечити високу якість програмного продукту.

Основні аспекти тестування включають:

1. **Виявлення помилок (багів):** Один з головних завдань тестування - це виявлення помилок у програмному коді, таких як програмні помилки, викиди, некоректні результати роботи програми, а також потенційні проблеми безпеки.

2. **Перевірка відповідності вимогам:** Тестування допомагає перевірити, чи відповідає програмний продукт специфікаціям і вимогам, встановленим для нього.

3. **Валідація функціональності:** Тестування включає в себе перевірку функціональності програмного продукту для того, щоб впевнитися, що він виконує свої завдання належним чином.

4. **Перевірка відмовостійкості:** Тестування допомагає визначити, як система веде себе в умовах відмов та перевірити, чи може вона відновитися після них.

5. **Вимірювання продуктивності:** Тестування дозволяє визначити продуктивність системи, її швидкість та реакційність.

6. **Тестування безпеки:** Особливу увагу приділяють тестуванню безпеки для виявлення потенційних вразливостей та заходів щодо їх запобігання.

Тестування може бути проведене як вручну, коли тестери вручну запускають програму з різними вхідними даними та аналізують результати, так і автоматизовано, коли тести виконуються за допомогою спеціалізованих тестових інструментів та скриптів. Тестування є невід'ємною частиною життєвого циклу розробки програмного продукту і допомагає підтримувати високу якість та надійність програмних продуктів.



[Back to top ⬆️](#5-qa-manual-qa-automation)
### **79. Піраміда тестування**
![IMG](images/pyramid.png)

Піраміда тестування - це концептуальна модель, яка відображає структуру і розподіл тестів за їхньою важливістю та часом виконання в процесі розробки програмного продукту. Піраміда тестування допомагає показати співвідношення між різними видами тестів і наголошує на важливості використання автоматизованих тестів на рівні одиниць (unit tests) та інтеграційних тестів (integration tests), а також на розробці функціональних (functional) та навігаційних (UI) тестів. Піраміда тестування складається з таких рівнів:

<ol>
  <li>
    <strong>Одиниці (Unit Tests):</strong>
    <ul>
      <li>Найнижчий рівень піраміди.</li>
      <li>Тести, які перевіряють окремі функції, методи або класи програмного коду.</li>
      <li>Зазвичай виконуються автоматично під час розробки.</li>
      <li>Спрощують виявлення та виправлення програмних помилок на ранніх етапах розробки.</li>
    </ul>
  </li>
  <li>
    <strong>Інтеграція (Integration Tests):</strong>
    <ul>
      <li>Тести, які перевіряють взаємодію між компонентами (наприклад, модулями або сервісами) системи.</li>
      <li>Вони визначають, як компоненти працюють разом і чи відповідають вони заданим вимогам.</li>
      <li>Також можуть бути автоматизовані, але вони частіше вимагають середовища, подібного до реального середовища використання.</li>
    </ul>
  </li>
  <li>
    <strong>Функціональне (Functional Tests):</strong>
    <ul>
      <li>Тести, які перевіряють, чи виконує програма або система функції та функціональність відповідно до специфікацій та бізнес-вимог.</li>
      <li>Ці тести спрямовані на переконання в тому, що програма виконує те, що очікується від неї.</li>
    </ul>
  </li>
  <li>
    <strong>Навігаційне (UI) тестування:</strong>
    <ul>
      <li>Тести, які перевіряють користувацький інтерфейс та навігацію програми або веб-сайту.</li>
      <li>Вони переконуються, що користувач може легко взаємодіяти з програмою і що інтерфейс працює належним чином.</li>
    </ul>
  </li>
</ol>

Кількість тестів зазвичай зменшується знизу вгору піраміди, але при цьому важливо покрити найважливіші функції та частини програмного продукту тестами на всіх рівнях. Нижні рівні (unit і integration tests) допомагають виявляти і виправляти помилки на ранніх етапах, що дозволяє зекономити час і ресурси під час тестування на вищих рівнях.



[Back to top ⬆️](#5-qa-manual-qa-automation)
### **80. Навіщо тестувати ПЗ**

*Мета тестування*:

* Підвищити ймовірність того, що додаток буде працювати правильно за будь-яких обставин.
 
* Підвищити ймовірність того, що програма, буде відповідати всім описаним вимогам.

* Надання актуальної інформації про стан продукту на даний момент.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **81. Етапи тестування**

*Етапи*:

1. Аналіз продукту
2. Робота з вимогами
3. Розробка стратегії тестування та планування процедур контролю якості
4. Створення тестової документації
5. Тестування прототипу
6. Основне тестування
7. Стабілізація
8. Експлуатація


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **82. Типи тестування**

*За цілями*:

* Безпеки
* Функціональне
* Нефункціональне
   * UI
   * Сумісності
   * Продуктивності
     * Навантажувальний
     * Стабільності
     * Стрес

*За знанням системи*:

* Біла скринька
* Сірий ящик
* Чорний ящик

*За хронологією виконання*:

* Вхідний (Smoke/intake)
* Повторне
* Регресійне

*За рівнем автомтизації*

*За виконанням коду*

[Back to top ⬆️](#5-qa-manual-qa-automation)
### **83. Рівні тестування**

* *Модульне/компонентне* (unit/component testing)* - тестування найменших елементів ПЗ, які можуть бути протестовані окремо (модулі, об'єкти, класи, функції).
Завдання модульного тестування – виявлення локалізованих у модулі помилок реалізації алгоритмів, а також визначення ступеня готовності системи до переходу на наступний рівень розробки та тестування.

* *Інтеграційне (integration testing)* - тестування частини системи, що складається з двох і більше модулів.
Завдання інтеграційного тестування – пошук дефектів, пов'язаних з помилками реалізації та інтерпретації інтерфейсної взаємодії між модулями, а також помилок взаємодії з іншими частинами системи (ОС, обладнанням).

* *Системне (system testing)* - процес тестування системи загалом із єдиною метою перевірки те, що вона відповідає встановленим вимогам.
Завдання системного тестування - виявлення дефектів, пов'язаних із загальною роботою системи, таких як неправильне використання ресурсів системи, непередбачені комбінації даних рівня користувача, несумісність з оточенням, непередбачені сценарії використання, відсутня або неправильна функціональність, незручність у застосуванні і т.д.

* *Приймальне (acceptance testing)* - формальний процес тестування, який перевіряє відповідність системи потребам, вимогам та бізнес процесам користувача, та проводиться для винесення рішення замовником (внутрішнім або зовнішнім) або іншою уповноваженою особою приймається додаток чи ні.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **84. Техніки тест-дизайну**
* *Еквівалентний Поділ/Класи еквівалентності (Equivalence Partitioning - EP)*. Як приклад, у вас є діапазон допустимих значень від 1 до 10, ви повинні вибрати одне правильне значення всередині інтервалу, скажімо, 5, і одне неправильне значення поза інтервалом - 0, отримавши таким чином два значення, що відносяться до різних класів.

* *Аналіз Граничних Значень (Boundary Value Analysis - BVA)*. Якщо взяти приклад вище, як значення для позитивного тестування виберемо мінімальну і максимальну межі (1 і 10), і значення більше і менше меж (0 і 11). Аналіз Граничний значень може бути застосований до полів, записів, файлів, або до будь-яких сутностей, що мають обмеження.
*Цінність: помилки часто зустрічаються якраз на межах різних груп значень*.

* *Попарне тестування (Pairwise Testing)* - техніка формування наборів тестових даних. Сформулювати суть можна так: формування таких наборів даних, в яких кожне тестоване значення кожного з параметрів, що перевіряються хоча б один раз поєднується з кожним тестованим значенням всіх інших параметрів, що перевіряються.

* *Причина/Слідство (Cause/Effect - CE)*. Це, як правило, введення комбінацій умов (Причин) для отримання відповіді від системи (Слідство). Наприклад, ви перевіряєте можливість додавати клієнта, використовуючи певну екранну форму. Для цього вам необхідно буде ввести кілька полів, таких як "Ім'я", "Адреса", "Номер Телефону", а потім натиснути кнопку "Додати" - це "Причина". Після натискання кнопки «Додати» система додає клієнта в базу даних і показує його номер на екрані — це «Слідство».

* *Предугадування помилки (Error Guessing - EG)*. Це коли тестувальник використовує свої знання системи та здатність до інтерпретації специфікації щодо того, щоб «передбачити» за яких вхідних умов система може видати помилку. Наприклад, специфікація каже: "користувач повинен ввести код". Тестувальник думатиме: «Що, якщо я не введу код?», «Що, якщо я введу неправильний код? ", і так далі. Це і є передбачання помилки.

* *Вичерпне тестування (Exhaustive Testing - ET)* - крайній випадок. У межах цієї техніки ви повинні перевірити всі можливі комбінації вхідних значень, і в принципі це має знайти всі проблеми. Насправді застосування цього методу неможливо, через велику кількість вхідних значень.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **85. Що таке Regression та Confirmation тестування, яка між ними різниця**
*Повторне/Підтвердне тестування (re-testing/confirmation testing)* - тестування, під час якого виконуються тестові сценарії, що виявили помилки під час останнього запуску, для підтвердження успішності виправлення цих помилок.

*Регресійне тестування (regression testing)* - тестування вже протестованої програми після модифікації для впевненості в тому, що процес модифікації не вніс або не активізував помилки в областях, що не зазнавали змін. Проводиться після змін у коді або його оточення.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **86. Частота регресійного тестування**

Частота регресійного тестування визначається великою мірою контекстом і конкретними потребами проекту або продукту. Регресійні тести виконуються для перевірки того, чи не впливають нові зміни в програмному коді на функціональність, яка вже була розроблена та протестована раніше. Ось деякі загальні рекомендації щодо частоти регресійного тестування:

1. **Після кожного нового кодового коміту:** В ідеальному випадку, регресійні тести повинні бути автоматично запускатися після кожного нового кодового коміту в репозиторії. Це дозволяє вчасно виявляти та виправляти можливі проблеми.

2. **Під час інтеграції змін:** Коли розробники інтегрують свої зміни в основну гілку (наприклад, у гілку "main" або "master"), регресійні тести повинні бути виконані, щоб переконатися, що інтегровані зміни не порушили існуючу функціональність.

3. **За потреби:** Частота регресійного тестування може змінюватися залежно від того, наскільки активно розробляється проект. Якщо розробники часто вносять зміни, регресійні тести повинні виконуватися частіше.

4. **Після кожного релізу або оновлення:** Після кожного релізу або оновлення продукту важливо виконати регресійне тестування для впевненості у тому, що нові функції не вплинули на існуючу функціональність.

5. **За умови критичних змін:** Якщо вносяться критичні зміни або виправлення помилок, регресійні тести слід виконати без зважання на розклад.

Регресійне тестування може бути автоматизовано, що дозволяє ефективно виконувати його при кожній зміні коду або власноруч, якщо це вимагається. Основна мета регресійного тестування полягає в запобіганні введенню нових помилок під час розробки та підтримці програмного продукту.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **87. Види інтеграційного тестування**

* *Знизу вгору (Bottom Up Integration)*. Усі низькорівневі модулі, процедури або функції збираються докупи і потім тестуються. Після чого збирається наступний рівень модулів щодо інтеграційного тестування. Даний підхід вважається корисним, якщо всі або практично всі модулі, що розробляється, готові. Також цей підхід допомагає визначити за результатами тестування рівень готовності програми.

* *Зверху вниз (Top Down Integration)*. Спочатку тестуються всі високорівневі модулі і поступово один за одним додаються низькорівневі. Усі модулі нижчого рівня симулюються заглушками з аналогічною функціональністю, потім у міру готовності заміняються реальними активними компонентами. Таким чином, ми проводимо тестування зверху вниз.

* *Великий вибух («Big Bang» Integration)*. Усі або практично всі розроблені модулі збираються разом у вигляді закінченої системи або її основної частини, а потім проводиться інтеграційне тестування. Такий підхід дуже добрий для збереження часу. Проте якщо тест кейси та його результати записані не так, то сам процес інтеграції сильно ускладниться, що стане перепоною для команди тестування при досягненні основної мети інтеграційного тестування.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **88. Configuration Testing**
*Конфігураційне тестування (configuration testing)* - тестування, спрямоване на перевірку роботи ПЗ при різних конфігураціях системи (заявлених платформах, драйверах, що підтримуються, при різних конфігураціях комп'ютерів і системного ПЗ і т.д.).


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **89. Exploratory Testing**
*Дослідницьке тестування (exploratory testing)* - неформальний метод, у якому тестувальник активно контролює проектування тестів, тоді як ці тести виконуються, і використовує отриману інформацію для проектування нових поліпшених тестів. Таке тестування визначається як одночасне навчання, проектування тесту та його виконання.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **90. Performance Testing**
*Тестування продуктивності (performance testing)* - визначення ступеня, з яким система виконує закладені в неї функції у встановлених рамках на час обробки та пропускну здатність. Досить часто під час тестування продуктивності перевіряється відразу кілька його підвидів.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **91. Traceability Matrix**
*Матриця відповідності вимог (traceability matrix)* — двомірна таблиця, що містить відповідність функціональних вимог (functional requirements) продукту та підготовлених тестових сценаріїв (test cases).
У заголовках колонок таблиці розміщені вимоги, а заголовках рядків — тестові сценарії. На перетині — позначка, що означає, що вимога поточної колонки покрита тестовим сценарієм поточного рядка.
Матриця відповідності вимог використовується QA-інженерами для валідації покриття продукту тестами. МСТ є невід'ємною частиною тест-плану.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **92. End-to-End тест**
End-to-End тести - такі інтеграційні тести, які впливають на систему через її зовнішні інтерфейси і перевіряють очікувану реакцію системи через ці ж інтерфейси.
Чому саме інтеграційні? Тому що це єдине, що можна про них напевно сказати: вони за визначенням не можуть бути модульними тестами. А все інше: чи є вони одночасно приймальними, навантажувальними чи ще якими - залежить тільки від загальних плану/стратегії тестування та тієї ролі, яку ці тести в них відіграють.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **93. Тестування безпеки**
*Тестування безпеки/захищеності (security testing)* – тестування ПЗ з метою визначити його захищеність.
Основні поняття, які мають бути охоплені тестуванням: конфіденційність, цілісність та збереження даних, автентифікація, авторизація та неможливість відмови від авторства.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **94. Випробування на основі ризиків**
*Тестування на основі ризиків/Ризик-тестування (risk-based testing)* — метод тестування програмного забезпечення, який базується на ймовірності ризиків. Їхня ймовірність визначається шляхом аналізу, в якому враховуються складність програми, критичність функції для бізнесу, частота її використання та кількість можливих дефектів. При тестуванні на основі ризиків найбільший пріоритет одержує перевірка найважливіших і потенційно мають недоліки функцій.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **95. Динамічне тестування**
*Динамічне тестування (dynamic testing)* - тестування, яке проводиться під час виконання ПЗ, компонента або системи.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **96. Основні фази STLC? Дайте визначення Entry та Exit Criteria.**
Життєвий цикл тестування (STLC) визначає, які дії виконувати при тестуванні і коли їх виконувати.

**Фази**:
1. Аналіз вимог
2. Планування тестування
3. Дизайн тесту
4. Налаштування тестового середовища
5. Виконання тесту
6. Завершення тесту

*Критерії входу (Entry Criteria)* - містять обов'язкові елементи, які необхідно виконати, перш ніж можна буде розпочати тестування.

*Критерії виходу (Exit Criteria)* - визначають елементи, які мають бути виконані до завершення тестування.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **97. Атрибути баг-репорту? Які основні поля для заповнення**

*Баг Репорт (Bug Report)* — документ, що описує ситуацію або послідовність дій, що призвела до некоректної роботи об'єкта тестування, із зазначенням причин та очікуваного результату.

**Атрибути**:

* Короткий опис (Summary/Title) - вижимання інформації, що явно вказує на причину і тип проблеми.
* Номер версії (Version) - версія на якій було знайдено помилку
* Серйозність (Severity):

   * S1 Блокуючий (Blocker)
   * S2 Критичний (Critical)
   * S3 Значний (Major)
   * S4 Незначний (Minor)
   * S5 Тривіальний (Trivial)
  
* Пріоритет (Priority):

   * P1 Високий (High)
   * P2 Середній (Medium)
   * P3 Низький (Low)
  
* Статус (Status) – поточний статус бага. Залежить від процедури та життєвого циклу бага (bug workflow and life cycle)
* Оточення (Environment) - ОС / Браузер + версія тощо. Інформація про оточення, на якому було знайдено баг.
* Кроки відтворення (Steps to Reproduce) - дії, якими можна легко відтворити ситуацію, що призвела до помилки.
* Фактичний Результат (Actual Result) – результат, отриманий після проходження кроків до відтворення
* Очікуваний результат (Expected Result) - очікуваний правильний результат


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **98. Різниця між пріоритетом і серйозністю**

*Серйозність (Severity)* - атрибут, що характеризує вплив дефекту на працездатність програми.

*Пріоритет (Priority)* - атрибут, що вказує на черговість виконання завдання або усунення дефекту. Більше інструмент менеджера з планування робіт. Чим вищий пріоритет, тим швидше потрібно виправити дефект

Зазвичай Severity виставляється тестувальником, а Priority менеджером, тимлідом або замовником.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **99. Наведіть приклади серйозного, але не пріоритетного бага.**

На Андроїді 4.4 програма при першому запуску падає. У наступні запуски працює нормально. Т.к. користувачів з цією версією ОС у нас близько 0,5%, то пріоретет можна поставити низький або взагалі проігнорувати.


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **100. Навіщо потрібна тестова документація? Які її види**

https://habr.com/ua/company/otus/blog/588923/

*Тестова документація* — набір документів, що створюються перед початком процесу тестування та безпосередньо у процесі. Ці документи описують покриття тестами та процес виконання тестів, у них вказуються необхідні для тестування речі, наводиться основна термінологія тощо. буд. У тестовій документації будь-який член команди може знайти повну інформацію про всі дії, пов'язані з тестуванням (і про вже виконані, та про заплановані). Тестова документація визначає, що для нас важливо і чому, які дії ми маємо виконати і скільки часу ми маємо. Зрештою, у документації зазначено, чого має досягти команда та що сигналізує про закінчення процесу.

Види:

* План тестування (test plan)
* Чекліст (checklist)
* Тестовий сценарій (Test Case)
* Баг-репорт (Bug Report)
* Звіт про тестування (Test Report)
* Інструкція (Manual)


[Back to top ⬆️](#5-qa-manual-qa-automation)
### **101. Тест-план? Які елементи має**

*План тестування (Test Plan)* — документ, що описує весь обсяг робіт із тестування, починаючи з опису об'єкта, стратегії, розкладу, критеріїв початку та закінчення тестування, до необхідного в процесі роботи обладнання, спеціальних знань, а також оцінки ризиків з варіантами їх дозволу.

У стандарті IEEE 829 перераховані пункти, з яких може/має складатися тест-план:
1. Test plan identifier
2. Introduction
3. Test items
4. Features to be tested
5. Features not to be tested
6. Approach
7. Item pass/fail criteria
8. Suspension criteria and resumption requirements
9. Test deliverables
10. Testing tasks
11. Environmental needs
12. Responsibilities
13. Staffing and training needs
14. Schedule
15. Risks and contingencies
16. Approvals
