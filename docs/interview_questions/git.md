## **2. Запитання для співбесіди на тему GIT**

---

- [1. Що таке Git](#1-git)
- [2. Як створити локальний Git репозиторій](#2-git_1)
- [3. Що таке git push](#3-git-push)
- [4. Що робить git commit](#4-git-commit)
- [5. Git merge та rebase](#5-git-merge-rebase)
- [6. Для чого використовують системи контролю версій](#6)
- [7. Що таке Git і GitHub?](#7-git-github)
- [8. Яка різниця між Git і GitHub?](#8-git-github)
- [9. Які основні відмінності між Git і SVN?](#9-git-svn)
- [10. Які переваги використання GIT?](#10-git)
- [11. Яка мова використовується в GIT](#11-git)
- [12. Що таке Git Bash](#12-git-bash)
- [13. Що означає «Індекс» або «Посадкова область» у git (Staging Area)](#13-git-staging-area)
- [14. Що таке тегування в Git (tagging)](#14-git-tagging)
- [15. Що таке forking в Git](#15-forking-git)
- [16. Для чого корисний Git clone](#16-git-clone)
- [17. Який процес створення репозиторію в Git](#17-git)
- [18. Що таке cherry-pick у Git](#18-cherry-pick-git)
- [19. Що таке origin у Git](#19-origin-git)
- [20. Що таке команда git pull](#20-git-pull)
- [21. Яка різниця між git fetch і git pull](#21-git-fetch-git-pull)
- [22. Поясніть git checkout у Git](#22-git-checkout-git)
- [23. Що робить git rebase](#23-git-rebase)
- [24. Яка різниця між git rebase і git merge](#24-git-rebase-git-merge)
- [25. Що таке git revert](#25-git-revert)
- [26. Яка різниця між between resetting and reverting](#26-between-resetting-and-reverting)
- [27. Яка різниця між «git remote» і «git clone»](#27-git-remote-git-clone)
- [28. Що таке GIT stash](#28-git-stash)
- [29. Чим fork, branch, и clone відрізняються один від одного](#29-fork-branch-clone)
- [30. Яка різниця між git reflog і log](#30-git-reflog-log)
- [31. Що таке GIT stash drop](#31-git-stash-drop)
- [32. Як визначити, чи певну гілку було об’єднано в головну](#32)
- [33. Для чого нам потрібні розгалуження в GIT](#33-git)
- [34. Що містять складові об’єкта коміту](#34)
- [35. Що таке HEAD у Git і скільки HEAD можна створити в репозиторії](#35-head-git-head)
- [36. Який звичайний спосіб розгалуження в GIT](#36-git)
- [37. Як ви визначаєте «конфлікт» у git](#37-git)
- [38. Як вирішити конфлікт у Git](#38-git)

---

# **Відповіді - 'GIT'**

[Back to top ⬆️](#2-git)
### **1. Що таке Git**

> **Короткий варіант відповіді:**

Розподілена система управління версіями. Розроблено Лінусом Торвальдсом, для зручної розробки ядра Linux.

> **Детальний варіант відповіді:**

Git - це розподілена система керування версіями, призначена для ведення історії змін у програмному коді та спільної роботи над ним між командами розробників. Вона створена Лінусом Торвальдсом у 2005 році та здобула широку популярність серед розробників програмного забезпечення та команд розробки завдяки своїй ефективності та потужним можливостям.

Основні поняття та можливості Git включають:

1. **Система керування версіями:** Git відстежує всі зміни у програмному коді та зберігає їх історію. Це дозволяє розробникам переглядати, відновлювати та порівнювати різні версії коду.

2. **Розподілена система:** Кожен розробник має повну копію репозиторію Git на своєму комп'ютері. Це дозволяє працювати незалежно, навіть без з'єднання з мережею, та легко спільно працювати над проектами.

3. **Гілки (Branches):** Розробники можуть створювати окремі гілки коду для роботи над конкретними функціями або завданнями. Це сприяє відокремленому розвитку та роботі в команді.

4. **Злиття (Merge) та Перевірка злиття (Pull Request):** Git дозволяє об'єднувати гілки, роблячи зміни з однієї гілки доступними в інших. Перевірка злиття дозволяє переглядати та обговорювати зміни перед їхнім об'єднанням.

5. **Віддалені репозиторії:** Git дозволяє спільно працювати над проектами в команді та зберігати код на віддалених серверах, таких як GitHub, GitLab або Bitbucket.

6. **Історія комітів (Commit History):** Кожен коміт коду містить інформацію про автора, дату та повідомлення про зміни. Це допомагає відстежувати, коли і які зміни були внесені у код.

7. **Гнізда (Stash):** Git дозволяє відкласти незавершені зміни та переключитися на іншу гілку або робочий каталог, а потім повернутися до збережених змін пізніше.

8. **Швидкість та ефективність:** Git дуже швидкий і ефективний у роботі з великими проектами та об'ємами даних.

Git став стандартом в галузі розробки програмного забезпечення і дозволяє розробникам та командам ефективно керувати та відстежувати код, спільно працювати над проектами та забезпечувати стабільність та якість програмного забезпечення.

[Back to top ⬆️](#2-git)
### **2. Як створити локальний Git репозиторій**

> **Короткий варіант відповіді:**

```
git init
```

> **Детальний варіант відповіді:**

Для створення локального Git репозиторію вам потрібно виконати кілька кроків:

1 - **Встановити Git:** Якщо Git ще не встановлено на вашому комп'ютері, вам потрібно встановити його. Ви можете завантажити встановлювач Git для вашої операційної системи з [офіційного веб-сайту Git](https://git-scm.com/downloads) та встановити його за інструкціями.

2 - **Створити папку для репозиторію:** Створіть папку на вашому комп'ютері, в якій ви хочете створити новий Git репозиторій. Наприклад, використовуючи командний рядок, ви можете створити нову папку так:

   ```bash
   mkdir my-git-repo
   cd my-git-repo
   ```

3 - **Ініціалізувати Git репозиторій:** Введіть наступну команду, щоб ініціалізувати новий Git репозиторій в цій папці:

   ```bash
   git init
   ```

   Ця команда створить прихований підкаталог `.git`, де зберігатимуться всі дані про репозиторій.

4 - **Додати файли:** Додайте файли та теки до репозиторію, які ви хочете включити в контроль версій Git. Ви можете додати файли до репозиторію за допомогою команди `git add`:

   ```bash
   git add файл1.txt файл2.txt
   ```

   Або ви можете додати всі файли та теки у поточній директорії до репозиторію, використовуючи:

   ```bash
   git add .
   ```

5 - **Зробити перший коміт:** Зафіксуйте стан репозиторію, зробивши перший коміт (зафіксувати зміни):

   ```bash
   git commit -m "Перший коміт: Додано файли"
   ```

   У вас зараз є локальний Git репозиторій, і ви можете працювати з ним, додавати нові файли, робити коміти, створювати гілки та виконувати інші операції керування версіями.

Якщо ви хочете підключити цей локальний репозиторій до віддаленого сервера, такого як GitHub або GitLab, ви можете створити репозиторій на сервері та використовувати команди `git remote` та `git push`, щоб завантажити свій код на сервер.

[Back to top ⬆️](#2-git)
### **3. Що таке git push**

> **Короткий варіант відповіді:**

Надсилання всіх невідправлених локальних комітів на віддалений сервер репозиторію.

> **Детальний варіант відповіді:**

`git push` - це команда в системі керування версіями Git, яка використовується для відправки (завантаження) змін, які ви зробили в локальному Git репозиторії, на віддалений серверний репозиторій. Коли ви виконуєте `git push`, ви відправляєте свої коміти та гілки на сервер, оновлюючи віддалений репозиторій.

Основні параметри та синтаксис команди `git push` виглядають так:

```
git push [віддалений репозиторій] [гілка]
```

- `[віддалений репозиторій]`: Це ім'я або URL віддаленого репозиторію, на який ви хочете відправити зміни. Зазвичай це ім'я віддаленого репозиторію, яке ви назвали під час клонування (за замовчуванням це "origin"). Але ви можете вказати інше ім'я, якщо у вас є більше одного віддаленого репозиторію.

- `[гілка]`: Це ім'я гілки, яку ви хочете відправити на віддалений репозиторій. Зазвичай це ім'я поточної гілки. Наприклад, якщо ви хочете відправити зміни з гілки "main", ви можете використовувати "main" як параметр.

Приклад використання `git push`:

```bash
git push origin main
```

Ця команда відправляє зміни з гілки "main" вашого локального репозиторію на віддалений репозиторій з ім'ям "origin".

Після виконання `git push`, ваші зміни будуть доступні іншим користувачам, які працюють над тим самим проектом, і вони зможуть синхронізувати свої локальні репозиторії з оновленим віддаленим репозиторієм.

[Back to top ⬆️](#2-git)
### **4. Що робить git commit**

> **Короткий варіант відповіді:**

Фіксує зміни локальних файлів у таймлайні репозиторію. Інакше кажучи, робить "моментальний знімок" репозиторію в даний момент часу, який і є версією.

> **Детальний варіант відповіді:**

Команда `git commit` використовується для фіксації (збереження) змін у вашому локальному репозиторії. Кожний коміт створює нову версію вашого коду та історію змін, які можна відстежувати.

Основний синтаксис команди `git commit` виглядає так:

```bash
git commit -m "Ваше повідомлення коміту"
```

- `-m "Ваше повідомлення коміту"`: Це обов'язковий параметр, який вказує коротке повідомлення, що пояснює, які зміни були зроблені у коміті. Повідомлення коміту має бути коротким і описовим, щоб інші розробники могли легко зрозуміти, що було змінено.

Коли ви виконуєте `git commit`, Git фіксує зміни, які ви раніше додали за допомогою `git add`. Всі додані файли та їхні зміни включаються в новий коміт, і цей коміт отримує унікальний хеш-код, що ідентифікує його в історії репозиторія.

Коміти в Git дозволяють відстежувати розвиток вашого проекту та робити зручний аналіз змін в коді. Важливо робити коміти регулярно та надавати інформативні повідомлення коміту, щоб зробити історію змін зрозумілою та легкою для розуміння для всіх розробників вашого проекту.


[Back to top ⬆️](#2-git)
### **5. Git merge та rebase**

```git merge``` - приймає вміст гілки джерела та об'єднує їх із цільовою гілкою. У цьому процесі змінюється тільки цільова гілка. Історія вихідних гілок залишається незмінною.  
```git rebase``` - ще один спосіб перенести зміни з однієї гілки в іншу. ```Rebase``` стискає всі зміни в один "патч".  

Потім він інтегрує патч у цільову гілку.На відміну від злиття, переміщення перезаписує історію, тому що вона передає завершену роботу з однієї гілки в іншу.У процесі усувається небажана історія.

[Back to top ⬆️](#2-git)
### **6. Для чого використовують системи контролю версій**

**Система контролю версій (Version Control System/VCS)** - дозволяє зберігати кілька версій одного і того ж документа, при необхідності повертатися до більш ранніх версій, визначати, хто і коли зробив ту чи іншу зміну, та багато іншого.  
VCS дозволяє змінювати одні й самі файли декільком розробникам одночасно.  
При цьому всі варіанти змін зберігаються окремо, і можна зробити різні варіанти того самого файлу з урахуванням різних правок від різних людей.  
Якщо ж кілька змін зачіпають той самий фрагмент документа, то система запропонує вибрати потрібний варіант.

[Back to top ⬆️](#2-git)
### **7. Що таке Git і GitHub**

Git — це безкоштовна розподілена система керування версіями з відкритим вихідним кодом, розроблена для швидкої та ефективної обробки проектів будь-якого розміру.

GitHub використовує Git для надання Інтернет-хостингу для контролю версій і розробки програмного забезпечення. Він пропонує функції розподіленого контролю версій і керування вихідним кодом, які є в Git, на додаток до інших унікальних функцій.


[Back to top ⬆️](#2-git)
### **8. Яка різниця між Git і GitHub?**

Git — це система контролю версій, яка використовується для керування історією вихідного коду.  
З іншого боку, GitHub — це хмарна служба хостингу, яка використовується для керування сховищами Git.   
GitHub призначений для кращого керування проектами з відкритим кодом.


[Back to top ⬆️](#2-git)
### **9. Які основні відмінності між Git і SVN?**

| Критерії                | GIT              | SVN       |
|-------------------------|------------------|----------|
| Тип контролю версій     | Розповсюджується | Централізована
| Доступ до мереж         | Не обов'язковий  | Обов'язковий
| Глобальний номер версії | Недоступний      | В наявності
| Зміст                   |Криптографічний хеш SHA-1|Немає хешованого вмісту

Тут ми перелічимо деякі з найважливіших відмінностей між Git і SVN:

- Коли мова йде про обробку великих файлів, Git не є кращим, але SVN може обробляти кілька проектів в одному сховищі
- Git не має «комітів» для кількох гілок, але SVN дозволяє створювати папки в будь-якому місці макета сховища
- Ви не можете внести зміни в Git, але SVN дозволяє створити тег як гілку, і ви можете створити кілька версій під кореневим тегом


[Back to top ⬆️](#2-git)
### **10. Які переваги використання GIT?**

Ось деякі з найважливіших переваг Git:

- Можливе резервування даних і реплікація даних
- Це дуже доступна послуга
- Для одного репозиторію ми можемо мати лише один каталог Git
- Продуктивність мережі та використання диска чудові
- Дуже легко співпрацювати над будь-яким проектом
- Ми можемо працювати над будь-яким проектом у Git

[Back to top ⬆️](#2-git)
### **11. Яка мова використовується в GIT**

C — це мова програмування, яка використовується для створення Git, що гарантує зменшення накладних витрат.


[Back to top ⬆️](#2-git)
### **12. Що таке Git Bash**

> **Короткий варіант відповіді:**

Git Bash — це програма, яка встановлює Bash, Git і кілька утиліт Bash, які зазвичай використовуються в ОС Windows.  
У Git Bash можлива взаємодія з елементами Git і репозиторієм за допомогою різних команд.

> **Детальний варіант відповіді:**

**Git Bash** - це текстовий інтерфейс командного рядка (термінал) для операційної системи Windows, який надає можливість виконувати команди Git та інші команди командного рядка в середовищі Windows. Git Bash зазвичай постачається разом із Git, коли ви встановлюєте Git на свій комп'ютер під Windows.

Основні характеристики Git Bash включають:

1. **Виконання команд Git:** Ви можете використовувати Git Bash для виконання всіх команд Git, таких як `git clone`, `git commit`, `git push`, `git pull` та багатьох інших. Git Bash забезпечує текстовий інтерфейс, в якому ви можете введені команди Git.

2. **Лінія команд:** Git Bash дозволяє вам взаємодіяти з вашим Git-репозиторієм та файловою системою через команди в текстовому вигляді. Ви можете переглядати теки, створювати файли, переміщувати файли та багато інших операцій.

3. **Підтримка UNIX-подібних команд:** Git Bash включає в себе багато команд, які характерні для UNIX-подібних операційних систем, таких як `ls`, `cd`, `mkdir`, `rm` тощо. Це дає можливість виконувати операції в стилі UNIX у середовищі Windows.

4. **Скрипти та автоматизація:** Ви можете створювати скрипти на мові командного рядка в Git Bash, щоб автоматизувати операції над Git-репозиторіями та файлами.

Git Bash допомагає розробникам, які працюють на Windows, працювати з Git у знайомому текстовому середовищі та виконувати всі необхідні операції керування версіями та роботи з файлами через командний рядок.


[Back to top ⬆️](#2-git)
### **13. Що означає «Індекс» або «Посадкова область» у git (Staging Area)**

> **Короткий варіант відповіді:**

Коли ми робимо коміти, ми можемо вносити до нього зміни, форматувати та переглядати його в проміжній області, відомій як «Постанова області» або «Індекс».

> **Детальний варіант відповіді:**

У системі керування версіями Git термін "Індекс" (іноді також використовується термін "Посадкова область" або "Staging Area") вказує на проміжний об'єкт або стан, де розробники можуть підготувати свої зміни перед комітом (фіксацією) їх у репозиторій.

Основні концепції та функції Індекса (Staging Area) в Git включають:

1. **Підготовка змін:** Перш ніж ви зможете зберегти зміни (зробити коміт), ви повинні додати файли або зміни до Індексу. Це означає, що ви вказуєте Git, які зміни ви хочете включити до наступного коміту.

2. **Часткові коміти:** Індекс дозволяє розробникам створювати часткові коміти, додавати та фіксувати зміни в окремих частинах свого проекту, а не всього одразу. Це дозволяє робити більш структуровані та організовані коміти.

3. **Перегляд змін:** Розробники можуть перевіряти стан Індекса, щоб переконатися, що вони додали всі необхідні зміни та файли до наступного коміту перед його фіксацією.

4. **Відміна змін:** Якщо ви випадково додали неправильні файли або зміни до Індексу, ви можете видалити їх з Індексу без втрати даних у вашому робочому каталозі.

5. **Зручний коміт:** Після того як ви підготували свої зміни в Індексі, ви можете виконати коміт, і Git збереже ці зміни разом з повідомленням коміту у вашому репозиторії.

Використання Індексу дозволяє вам бути більш контрольованими і систематичними при роботі з Git, допомагаючи створювати чітку та структуровану історію змін у вашому проекті.


[Back to top ⬆️](#2-git)
### **14. Що таке тегування в Git (tagging)**

> **Короткий варіант відповіді:**

Додавання тегів дозволяє розробникам позначати всі важливі контрольні точки в ході виконання своїх проектів.  
Замість ідентифікаторів комітів можна використовувати назви тегів, коли коміти перевіряються та надсилаються до віддаленого репо.

> **Детальний варіант відповіді:**

Тегування (tagging) в системі керування версіями Git відноситься до процесу присвоєння позначок або тегів певним комітам у репозиторії. Теги використовуються для позначення конкретних комітів або моментів в історії репозиторію, щоб вказати на важливі точки розвитку проекту, такі як версії програми або важливі випуски.

Основні поняття та характеристики тегування в Git:

1. **Створення тегів:** Ви можете створити тег для певного коміту за допомогою команди `git tag`. Тег може бути назвою або номером версії, і його зазвичай обирають так, щоб він був легко зрозумілим та показував на важливу точку в історії проекту.

Наприклад, створення тегу з ім'ям "v1.0" може виглядати так:

```bash
git tag v1.0
```

2. **Легковагість:** Теги не мають впливу на саму історію репозиторію або коміти. Вони є просто покажчиками на певні коміти.

3. **Анотовані теги та легкі теги:** У Git існують два основних типи тегів:
   - **Анотовані теги (annotated tags):** Це теги, які містять додаткову інформацію, таку як ім'я автора, дату створення, повідомлення та інше. Їх рекомендується використовувати для важливих випусків або версій.
   - **Легкі теги (lightweight tags):** Це прості покажчики на коміт без додаткових метаданих. Вони зазвичай використовуються для тимчасових або експериментальних тегів.

4. **Перегляд інформації про теги:** Ви можете переглядати список існуючих тегів у репозиторії за допомогою команди `git tag`. Також, ви можете переглядати інформацію про конкретний тег, вказавши його ім'я з опцією `-l`.

5. **Відправлення та отримання тегів:** При бажанні, ви можете відправити ваші теги на віддалений репозиторій, щоб інші розробники могли їх побачити та використовувати. Для цього використовують команду `git push`.

Тегування в Git допомагає зберігати історію важливих випусків та версій вашого проекту та робить цю інформацію легкою для розуміння та навігації.



[Back to top ⬆️](#2-git)
### **15. Що таке forking в Git**

> **Короткий варіант відповіді:**

Копія сховища називається форком.  
Отже, розгалуження дозволяє експериментувати зі змінами, не турбуючись про оригінальний проект.  
Цей процес ідеально підходить для пропозиції змін до чиїхось проектів.

> **Детальний варіант відповіді:**

**Forking** в Git відноситься до створення копії чужого репозиторію на платформі спільної роботи, такій як GitHub, GitLab або Bitbucket, з метою подальшої роботи над ним, внесення змін та спільної розробки проекту.

Основні поняття і характеристики forking в Git:

1. **Створення копії:** Під час forking ви створюєте власну копію (форк) існуючого репозиторію іншого користувача. Ця копія зберігається на вашому акаунті на платформі спільної роботи.

2. **Незалежність:** Після створення форку, ви можете вносити будь-які зміни до цього репозиторію, незалежно від оригінального репозиторію. Форк стає вашим власним репозиторієм, і ви маєте повний контроль над ним.

3. **Спільна робота та внесення змін:** Ви можете працювати над власним форком, робити зміни у коді, створювати гілки, робити коміти та виконувати інші операції керування версіями. Після цього ви можете пропонувати зміни (pull request) до оригінального репозиторію. Власник оригінального репозиторію може прийняти ваші зміни та об'єднати їх у свій проект.

4. **Спільнота та відкритий код:** Forking є важливою частиною відкритого програмного забезпечення та спільної роботи у великих проектах з відкритим кодом. Він дозволяє розробникам зробити внесок до чужого проекту та сприяє спільній роботі над публічними проектами.

5. **Збереження оригінального репозиторію:** Оригінальний репозиторій залишається незмінним. Форк створює окремий репозиторій, і зміни у форку не впливають на оригінальний проект, поки вони не були об'єднані (merged) у власний проект власником оригінального репозиторію.

Загалом, forking - це потужний механізм для спільної роботи та внеску до проектів на платформах для спільної роботи з Git, таких як GitHub та GitLab.



[Back to top ⬆️](#2-git)
### **16. Для чого корисний Git clone**

> **Короткий варіант відповіді:**

Команда ```git clone``` дозволяє скопіювати існуючий репозиторій Git. Якщо ми хочемо отримати копію центрального репозиторію, то найкращий спосіб зробити це — використовувати «клонування»

> **Детальний варіант відповіді:**

`git clone` - це команда в системі керування версіями Git, яка використовується для створення локальної копії віддаленого Git-репозиторію. Ця команда корисна для багатьох цілей:

1. **Отримання копії проекту:** Користувачі можуть використовувати `git clone`, щоб отримати копію віддаленого Git-репозиторію на свій локальний комп'ютер. Це дозволяє їм отримати доступ до коду та ресурсів проекту для подальшої роботи.

2. **Спільна робота над проектом:** Коли кілька розробників спільно працюють над одним проектом, вони можуть склонувати репозиторій та вносити зміни у власних копіях. Після цього вони можуть пропонувати зміни (pull request) власникам оригінального репозиторію для об'єднання.

3. **Розробка на локальному комп'ютері:** Розробники можуть використовувати `git clone` для створення копії проекту на своєму локальному комп'ютері, де вони можуть працювати над кодом без прямого з'єднання з віддаленим сервером. Це дозволяє розробникам ефективно розробляти та тестувати код.

4. **Спільне використання проектів:** Люди можуть використовувати `git clone`, щоб отримати доступ до відкритих джерел або проектів з відкритим кодом, які доступні на публічних платформах, таких як GitHub, GitLab або Bitbucket. Вони можуть використовувати ці проекти для навчання, аналізу або спільної роботи.

5. **Резервне копіювання:** `git clone` може бути використаний для створення резервної копії віддаленого репозиторію, яка може бути корисною для збереження даних та історії проекту.

Користуючись командою `git clone`, ви можете легко розпочати роботу з віддаленим Git-репозиторієм та отримати доступ до його ресурсів на своєму локальному комп'ютері.

[Back to top ⬆️](#2-git)
### **17. Який процес створення репозиторію в Git**

Створення репозиторію в Git включає в себе декілька кроків:

<ol>
  <li>
    <strong>Встановлення Git:</strong>
    <p>Перш ніж створювати репозиторій, переконайтеся, що Git встановлено на вашому комп'ютері. Ви можете завантажити Git з офіційного веб-сайту Git: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
  </li>
  <li>
    <strong>Ініціалізація репозиторію:</strong>
    <ul>
      <li>
        <strong>Ініціалізація порожнього репозиторію:</strong>
        <p>Якщо ви хочете створити новий порожній репозиторій, перейдіть у каталог, де ви хочете створити репозиторій, та виконайте команду <code>git init</code>. Наприклад:</p>
        <pre><code>cd /шлях/до/нового/репозиторію
git init</code></pre>
      </li>
      <li>
        <strong>Клонування існуючого репозиторію:</strong>
        <p>Якщо ви хочете створити копію існуючого репозиторію, ви можете використовувати команду <code>git clone</code> і вказати URL віддаленого репозиторію. Наприклад:</p>
        <pre><code>git clone https://github.com/користувач/репозиторій.git</code></pre>
      </li>
    </ul>
  </li>
  <li>
    <strong>Додавання файлів:</strong>
    <p>Після ініціалізації репозиторію або клонування існуючого, ви можете почати додавати файли та ресурси до репозиторію за допомогою команди <code>git add</code>. Наприклад:</p>
    <pre><code>git add файл1 файл2 папка/</code></pre>
  </li>
  <li>
    <strong>Фіксація змін (коміт):</strong>
    <p>Після додавання файлів ви можете зробити коміт (фіксацію змін) за допомогою команди <code>git commit</code>. При коміті ви повинні вказати коротке повідомлення, що пояснює, які зміни ви внесли. Наприклад:</p>
    <pre><code>git commit -m "Додано нові файли"</code></pre>
  </li>
  <li>
    <strong>Створення віддаленого репозиторію (необов'язково):</strong>
    <p>Якщо ви хочете робити спільну роботу та синхронізацію з іншими розробниками, ви можете створити віддалений репозиторій на платформі для спільної роботи з Git, такій як GitHub, GitLab або Bitbucket. Після цього ви можете вказати URL цього віддаленого репозиторію за допомогою команди <code>git remote add</code>, і потім відправити ваші зміни на віддалений репозиторій за допомогою команди <code>git push</code>.</p>
  </li>
</ol>



[Back to top ⬆️](#2-git)
### **18. Що таке cherry-pick у Git**

> **Короткий варіант відповіді:**

Git cherry-pick — це команда, яка дозволяє вибирати довільні коміти Git за посиланням і додавати їх до HEAD.  
Cherry-picking — це процес вибору коміту з однієї гілки та застосування його до іншої.  
Це допомагає скасувати зміни.

> **Детальний варіант відповіді:**

`git cherry-pick` - це команда в системі керування версіями Git, яка використовується для вибору і застосування конкретного коміту з одного гілки до іншої. Ця команда корисна, коли вам потрібно взяти лише певні зміни з одного коміту і застосувати їх до іншого коміту або гілки. Вона дозволяє вибирати окремі коміти та об'єднувати їх з поточним станом вашого проекту.

Основні використання команди `git cherry-pick` включають:

1 - **Вибір і застосування окремого коміту:** Ви можете вибрати конкретний коміт і застосувати його зміни до поточної гілки. Наприклад:

   ```bash
   git cherry-pick <SHA-1 коміту>
   ```

   `<SHA-1 коміту>` - це хеш-код SHA-1 обраного коміту.

2 - **Вибір та застосування багатьох комітів:** Ви можете вибрати і застосувати зміни з кількох комітів в потрібному порядку.

   ```bash
   git cherry-pick <SHA-1 коміту1> <SHA-1 коміту2> <SHA-1 коміту3>
   ```

3 - **Вибір і застосування коміту з іншої гілки:** Іншим варіантом використання `git cherry-pick` є вибір і застосування коміту з іншої гілки до поточної гілки. Це може бути корисно, коли вам потрібно взяти окремий коміт з однієї гілки та внести його зміни в іншу гілку.

   ```bash
   git cherry-pick <SHA-1 коміту з іншої гілки>
   ```

Важливо враховувати, що `git cherry-pick` створює новий коміт з вибраними змінами в поточній гілці. Це може призвести до конфліктів при злитті змін, якщо ви вибрали коміт, який вже має конфлікти з поточною гілкою. В такому випадку вам доведеться вирішити конфлікти вручну.


[Back to top ⬆️](#2-git)
### **19. Що таке origin у Git**

У Git термін "origin" використовується для посилання на віддалений репозиторій, з якого ви клонували свій локальний репозиторій. "origin" - це стандартна назва за замовчуванням для віддаленого репозиторію, але ви можете змінити її на іншу, якщо це необхідно.

Коли ви клонуєте репозиторій за допомогою команди `git clone`, Git автоматично налаштовує віддалений репозиторій під ім'ям "origin". "origin" вказує на URL віддаленого репозиторію, з якого був зроблений клон, і це дозволяє вам легко взаємодіяти з цим віддаленим репозиторієм.

Основні дії та операції, які можна виконувати з використанням "origin", включають:

1. **Отримання змін з віддаленого репозиторію:** Ви можете використовувати "origin" для отримання оновлень з віддаленого репозиторію за допомогою команди `git pull origin`.

2. **Відправлення змін на віддалений репозиторій:** Ви можете відправити свої зміни на віддалений репозиторій за допомогою команди `git push origin`.

3. **Перегляд інформації про віддалений репозиторій:** Ви можете переглядати інформацію про "origin", включаючи URL та інші деталі, за допомогою команди `git remote show origin`.

4. **Звернення до гілок віддаленого репозиторію:** Ви можете використовувати "origin" для звернення до гілок, які знаходяться у віддаленому репозиторії. Наприклад, ви можете стягнути віддалену гілку за допомогою команди `git checkout origin/назва-гілки`.

"origin" є зручним посиланням на віддалений репозиторій та використовується для спрощення спільної роботи з віддаленими репозиторіями.


[Back to top ⬆️](#2-git)
### **20. Що таке команда git pull**

> **Короткий варіант відповіді:**

Команда ```git pull``` призначена для отримання та завантаження вмісту з віддаленого сховища та інтеграції його з локальним сховищем.

> **Детальний варіант відповіді:**

Команда `git pull` в системі керування версіями Git використовується для оновлення вашого локального репозиторію до останньої версії змін із віддаленого репозиторію та автоматичного злиття цих змін у вашу поточну робочу гілку.

Основні дії та параметри команди `git pull` включають:

1 - **Загальний синтаксис:**

   ```bash
   git pull [віддалений-репозиторій] [гілка]
   ```

   - `[віддалений-репозиторій]` - це назва віддаленого репозиторію, з якого ви хочете стягнути оновлення. Зазвичай це встановлений віддалений репозиторій з іменем "origin", але можна вказати інше ім'я, якщо у вас є більше одного віддаленого репозиторію.
   - `[гілка]` - це назва гілки віддаленого репозиторію, з якої ви хочете стягнути оновлення. Зазвичай це назва гілки, з якої ви вже працюєте.

2 - **Вибір віддаленого репозиторію та гілки:**

   По замовчуванню, якщо ви не вказуєте `[віддалений-репозиторій]` та `[гілку]`, Git використовуватиме значення, що встановлене для вашої поточної гілки та віддаленого репозиторію (зазвичай "origin" та поточна гілка).

3 - **Синхронізація із віддаленим репозиторієм:**

   Команда `git pull` використовується для синхронізації вашого локального репозиторію з віддаленим. Вона стягує всі оновлення (коміти) з вказаної віддаленої гілки і автоматично зливає їх з вашою поточною гілкою. Це допомагає вам мати доступ до останніх змін з віддаленого репозиторію та зберігати ваш локальний репозиторій актуальним.

4 - **Конфлікти при злитті (merge conflicts):**

   Якщо Git виявляє конфлікти при злитті змін, вам потрібно буде вирішити їх вручну. Git позначатиме конфлікти у файлах, які потребують уваги, і ви повинні внести необхідні зміни та підтвердити злиття, після чого ви можете продовжити виконувати `git pull` для завершення злиття.

Команда `git pull` дозволяє легко отримувати оновлення з віддаленого репозиторію та підтримувати синхронізованим ваш локальний репозиторій з віддаленим, що дуже корисно при спільній роботі над проектом з іншими розробниками.


[Back to top ⬆️](#2-git)
### **21. Яка різниця між git fetch і git pull**

> **Короткий варіант відповіді:**

Git fetch отримує нові дані з віддаленого сховища, але не інтегрує їх у наші робочі файли. Це допомагає перевірити, чи відбулися будь-які зміни у віддаленому сховищі.  
Він не маніпулює та не руйнує нічого в процесі.

```git pull```, з іншого боку, оновлює HEAD останніми змінами з віддаленого сервера та безпосередньо інтегрує його у файли робочої копії.  
Використання ```git pull``` може призвести до конфлікту злиття, оскільки він намагається об’єднати віддалені зміни з локальними.

> **Детальний варіант відповіді:**

<ol>
  <li>
    <strong>git fetch і git pull:</strong>
    <p>Це дві різні команди в системі керування версіями Git, які використовуються для отримання змін з віддаленого репозиторію. Основна різниця між ними полягає в тому, як вони оновлюють ваш локальний репозиторій та поточну гілку:</p>
    <ul>
      <li>
        <strong>git fetch:</strong>
        <p><code>git fetch</code> забирає всі зміни (коміти, гілки, теги) з віддаленого репозиторію, але <strong>не автоматично об'єднує їх із вашим поточним станом робочої гілки</strong>.</p>
        <p>Ця команда оновлює інформацію про віддалені гілки та коміти у вашому локальному репозиторії, але залишає вашу поточну гілку незмінною.</p>
        <p>Ви можете використовувати <code>git fetch</code>, щоб переглянути, які зміни були зроблені в віддаленому репозиторії, і вирішити, які зміни ви хочете стягнути та об'єднати у вашій гілці.</p>
      </li>
      <li>
        <strong>git pull:</strong>
        <p><code>git pull</code> забирає всі зміни з віддаленого репозиторію та <strong>автоматично зливає їх із вашою поточною гілкою</strong>.</p>
        <p>Ця команда виконує те саме, що <code>git fetch</code>, а потім автоматично виконує операцію злиття (merge) змін із віддаленого репозиторію в вашу поточну гілку.</p>
        <p><code>git pull</code> може викликати конфлікти при злитті, якщо зміни в вашій гілці конфліктують зі змінами в віддаленій гілці.</p>
      </li>
    </ul>
    <p>Отже, основна різниця полягає в тому, що <code>git fetch</code> лише завантажує зміни з віддаленого репозиторію та оновлює інформацію про віддалені гілки у вашому локальному репозиторії, але не змінює вашу поточну робочу гілку. З іншого боку, <code>git pull</code> завантажує та автоматично зливає зміни із віддаленого репозиторію в вашу поточну гілку. Вибір між ними залежить від вашого поточного стану та потреби в оновленні вашого локального репозиторію.</p>
  </li>
</ol>



[Back to top ⬆️](#2-git)
### **22. Поясніть git checkout у Git**

```git checkout``` дозволяє перемикати HEAD.  
Його також можна використовувати для відновлення історичних версій файлів. Команда працює з файлами, комітами та гілками.


[Back to top ⬆️](#2-git)
### **23. Що робить git rebase**

<ol>
  <li>
    <strong>git rebase:</strong>
    <p><code>git rebase</code> - це команда в системі керування версіями Git, яка використовується для перенесення (перевідправлення) комітів з однієї гілки на іншу гілку або на поточну гілку. Основною метою команди <code>git rebase</code> є створення більш чистої та структурованої історії комітів, яка легше зрозуміла та підтримувала.</p>
    <p>Основні дії та сценарії, коли використовується <code>git rebase</code>, включають:</p>
    <ul>
      <li>
        <strong>Перенесення комітів з однієї гілки на іншу:</strong>
        <p>- Ви можете використовувати <code>git rebase</code> для перенесення комітів з однієї гілки на іншу. Наприклад, якщо ви створили нову гілку від головної гілки і бажаєте внести зміни з головної гілки в свою нову гілку, ви можете використовувати <code>git rebase</code> для цього:</p>
        <pre><code>git checkout нова-гілка
git rebase головна-гілка</code></pre>
        <p>Це сприяє підтримці актуальності вашої гілки та забезпечує її сумісність з оновленнями головної гілки.</p>
      </li>
      <li>
        <strong>Перепризначення комітів у поточній гілці:</strong>
        <p>- Ви можете використовувати <code>git rebase</code>, щоб перепризначити (перевідправити) коміти в поточній гілці. Це корисно, коли ви хочете упорядкувати, об'єднати або підредагувати історію комітів.</p>
        <pre><code>git rebase базовий-коміт</code></pre>
        <p>В результаті перепризначення ваші коміти будуть застосовані на базовий коміт замість попереднього стану гілки. Це створює більш лінійну та зрозумілу історію.</p>
      </li>
      <li>
        <strong>Вирішення конфліктів при перепризначенні:</strong>
        <p>- Якщо виникають конфлікти під час перепризначення, ви повинні їх вирішити вручну, так само, як при злитті (merge) конфліктів. Після вирішення конфліктів ви можете продовжити команду <code>git rebase --continue</code> для завершення процесу перепризначення.</p>
      </li>
    </ul>
    <p>Команда <code>git rebase</code> дозволяє структурувати та оптимізувати історію комітів вашого репозиторію, але вона також може впливати на історію інших розробників, які спільно працюють над проектом, тому важливо використовувати її обережно, особливо в розподілених командних проектах.</p>
  </li>
</ol>



[Back to top ⬆️](#2-git)
### **24. Яка різниця між git rebase і git merge**

<ol>
  <li>
    <strong>git rebase і git merge:</strong>
    <p><code>git rebase</code> і <code>git merge</code> - це дві різні стратегії об'єднання (злиття) змін історії комітів в системі керування версіями Git. Кожна з цих стратегій має свої особливості і сценарії використання. Основна різниця між ними полягає в тому, як вони об'єднують зміни.</p>
    <ol>
      <li>
        <strong>Git Merge:</strong>
        <p>- <code>git merge</code> використовується для об'єднання (злиття) змін історії комітів іншої гілки в поточну гілку.</p>
        <p>- При використанні <code>git merge</code> створюється новий коміт з двома батьками - одним від поточної гілки та іншим від гілки, яку ви об'єднуєте. Це створює точку об'єднання, в якій обидві гілки зливаються.</p>
        <p>- Цей підхід зберігає історію обох гілок та дозволяє зберегти контекст кожної з них. Граф історії комітів залишається більш складним.</p>
        <pre><code>git checkout поточна-гілка
git merge інша-гілка</code></pre>
      </li>
      <li>
        <strong>Git Rebase:</strong>
        <p>- <code>git rebase</code> використовується для перенесення (перевідправлення) комітів з однієї гілки на іншу гілку або на поточну гілку.</p>
        <p>- При використанні <code>git rebase</code> коміти з однієї гілки переносяться поверх історії комітів іншої гілки, і в результаті утворюється лінійна послідовність комітів.</p>
        <p>- Цей підхід дозволяє створити більш зрозумілу та однорідну історію комітів, але втрачає інформацію про контекст об'єднання двох гілок.</p>
        <pre><code>git checkout поточна-гілка
git rebase інша-гілка</code></pre>
      </li>
    </ol>
    <p>Основна рекомендація полягає в тому, що <code>git merge</code> використовується для збереження історії та контексту об'єднання гілок, тоді як <code>git rebase</code> допомагає створити більш зрозумілу та лінійну історію комітів. Вибір між ними залежить від конкретних потреб проекту і ваших власних вподобань щодо структури історії комітів.</p>
  </li>
</ol>



[Back to top ⬆️](#2-git)
### **25. Що таке git revert**

`git revert` - це команда в системі керування версіями Git, яка використовується для створення нового коміту, який відміняє (відкривається назад) зміни, внесені в попередній коміт або коміти. Іншими словами, вона дозволяє скасувати зміни, які були внесені в минулому, залишаючи історію комітів незмінною.

Основні використання команди `git revert` включають:

1 - **Відміна окремого коміту:**

   Ви можете відмінити зміни, внесені в конкретний коміт, вказавши його хеш-код SHA-1. Новий коміт буде створений, що відмінює зміни, які були внесені в цей коміт.

   ```bash
   git revert <SHA-1 коміту>
   ```

2 - **Відміна багатьох комітів:**

   Ви також можете вказати діапазон комітів для відміни. Наприклад, ви можете відмінити всі зміни між двома конкретними комітами.

   ```bash
   git revert <SHA-1 початкового коміту>..<SHA-1 кінцевого коміту>
   ```

3 - **Відміна останнього коміту:**

   Якщо ви хочете відмінити останній коміт у вашій гілці, ви можете використовувати команду без параметрів.

   ```bash
   git revert HEAD
   ```

4 - **Вирішення конфліктів при відміні:**

   Якщо ви відміняєте зміни, які вже були злиті з іншими гілками і виникають конфлікти при відміні, вам доведеться вирішити їх вручну, подібно до вирішення конфліктів при злитті (merge conflicts).

Після виконання команди `git revert` створюється новий коміт, який відміняє зміни попереднього коміту чи комітів. Цей підхід дозволяє зберегти історію комітів незмінною та відмінити потрібні зміни.


[Back to top ⬆️](#2-git)
### **26. Яка різниця між between resetting and reverting**

> **Короткий варіант відповіді:**

У той час як git reset змінює стан гілки на попередній, видаляючи всі стани після потрібного коміту, git revert робить це шляхом створення нових повертаючих комітів і збереження початкового.

> **Детальний варіант відповіді:**

`git reset` і `git revert` - це дві різні команди в Git, які використовуються для скасування змін, але вони роблять це за різними принципами, і вони мають різний вплив на історію комітів.

Основна різниця між `git reset` і `git revert` полягає в тому, як вони впливають на історію комітів:

1. **Git Reset:**

   - `git reset` використовується для переміщення (зміщення) гілки на інший коміт або в інший стан.
   - Ця команда змінює історію комітів, призводячи до видалення комітів з гілки або зміщення гілки на інший коміт. В результаті коміти, які були скасовані, "зникають" з історії, і ви не можете більше з ними працювати.

2. **Git Revert:**

   - `git revert`, навпаки, створює нові коміти, які відміняють зміни, внесені в конкретний коміт або коміти.
   - Ця команда не видаляє історію комітів. Замість цього вона додає нові коміти, які скасовують (відкривають назад) зміни, що були внесені в попередні коміти. Це дозволяє зберегти історію комітів незмінною та вказати, що певні зміни були скасовані.

![Git Reset](images/git-revert.png)

Таким чином, коли ви використовуєте `git reset`, ви фактично змінюєте історію комітів і видаляєте попередні коміти, тоді як `git revert` додає нові коміти, які скасовують попередні зміни без зміни самої історії. Вибір між ними залежить від потреб вашого проекту та того, як ви бажаєте керувати історією комітів.



[Back to top ⬆️](#2-git)
### **27. Яка різниця між «git remote» і «git clone»**

`git remote` і `git clone` - це дві різні команди в системі керування версіями Git, які використовуються для роботи з віддаленими репозиторіями, але вони виконують різні завдання. Ось їхні основні різниці:

1. **Git Remote:**

   - `git remote` - це команда, яка дозволяє переглянути список віддалених репозиторіїв, які пов'язані з вашим локальним репозиторієм.
   - Вона надає інформацію про віддалені репозиторії, з якими ви можете взаємодіяти, такі як їхні URL-адреси і назви.

   Приклад використання `git remote`:
   
   ```bash
   git remote -v
   ```

   Вивід цієї команди покаже вам список віддалених репозиторіїв, з якими ваш локальний репозиторій взаємодіє.

2. **Git Clone:**

   - `git clone` - це команда, яка використовується для створення копії віддаленого репозиторію на вашому локальному комп'ютері.
   - При використанні `git clone` ви завантажуєте всю історію комітів, гілки та файли з віддаленого репозиторію та створюєте локальну копію цього репозиторію на вашому комп'ютері.

   Приклад використання `git clone`:
   
   ```bash
   git clone <URL-адреса-віддаленого-репозиторію>
   ```

   Після виконання цієї команди у вас буде новий локальний репозиторій, який включатиме всі дані з віддаленого репозиторію.

Отже, `git remote` використовується для роботи з конфігурацією віддалених репозиторіїв у вашому локальному репозиторії, тоді як `git clone` використовується для створення копії віддаленого репозиторію на вашому локальному комп'ютері.


[Back to top ⬆️](#2-git)
### **28. Що таке GIT stash**

Схованка Git візьме робочий каталог у поточному стані та проіндексує його, щоб помістити в стек на пізнішому етапі, щоб отримати чистий робочий каталог.

![IMG](images/GitStash.png)

Це означає, що якщо ми перебуваємо в середині якогось завдання і нам потрібно отримати чистий робочий каталог і водночас ми хочемо зберегти всі наші поточні редагування, тоді ми можемо використати схованку Git.


[Back to top ⬆️](#2-git)
### **29. Чим fork, branch, и clone відрізняються один від одного**

<ol>
  <li>
    <strong>Fork (розділення):</strong>
    <p>"Fork" - це операція, яка стосується віддаленого репозиторію на платформі, такій як GitHub або GitLab. Коли ви "форкуєте" репозиторій, ви створюєте копію цього репозиторію власного користувача або організації.</p>
    <p>Форк робить репозиторій доступним для вашого власного редагування, додавання нових функцій та внесення змін, але ці зміни не впливають на вихідний репозиторій. Ви можете внести зміни в свій форк та подати запит на включення (pull request) цих змін до вихідного репозиторію.</p>
  </li>
  <li>
    <strong>Branch (гілка):</strong>
    <p>"Branch" - це відгалуження в історії розробки в рамках одного репозиторію. Ви можете створити гілку, щоб відділити роботу над певною функцією чи виправленням від основної гілки розробки.</p>
    <p>Гілки дозволяють працювати паралельно над різними функціями чи завданнями без впливу на інші частини проекту. Після завершення роботи над гілкою ви можете об'єднати (злити) її з основною гілкою або іншою гілкою за допомогою операції злиття (merge).</p>
  </li>
  <li>
    <strong>Clone (клонування):</strong>
    <p>"Clone" - це операція, яка виконується на локальному комп'ютері із віддаленим репозиторієм. Коли ви "клонуєте" репозиторій, ви створюєте копію цього репозиторію на своєму комп'ютері.</p>
    <p>Клонування дозволяє вам отримати всі файли та історію комітів з віддаленого репозиторію і працювати з ними локально на своєму комп'ютері. Ви можете внести зміни, створювати гілки та комітувати зміни у своєму клоні репозиторію. Після цього ви можете синхронізувати свої зміни з віддаленим репозиторієм за допомогою операції "push" (відправлення) або "pull" (стягування) змін.</p>
  </li>
</ol>



[Back to top ⬆️](#2-git)
### **30. Яка різниця між git reflog і log**

> **Короткий варіант відповіді:**

Журнал git — це загальнодоступний запис історії комітів для гілки. З іншого боку, Reflog є приватним локальним комітом сховища.

На відміну від reflog, журнал git є частиною сховища Git і реплікується після push, fetch або pull.  
Розробник не може отримати доступ до reflog локального сховища, не маючи доступу до комп’ютера, на якому він розташований.

> **Детальний варіант відповіді:**

<ol>
  <li>
    <strong>git log і git reflog:</strong>
    <p>Це дві різні команди в системі керування версіями Git, які використовуються для перегляду історії комітів та операцій, але вони виконують різні завдання та відображають різну інформацію. Ось їхні основні відмінності:</p>
    <ul>
      <li>
        <strong>Git Log:</strong>
        <p><code>git log</code> - це команда, яка використовується для перегляду історії комітів у поточній гілці.</p>
        <p>Вона виводить список комітів, їхні хеш-коди, авторів, дати, повідомлення про коміт та іншу інформацію, пов'язану з історією комітів.</p>
        <p><code>git log</code> дозволяє вам досліджувати історію проекту, переглядати послідовність змін, а також знаходити інформацію про коміти за різними критеріями, такими як автори, ключові слова і багато іншого.</p>
        <p>Приклад використання <code>git log</code>:</p>
        <pre><code>git log</code></pre>
      </li>
      <li>
        <strong>Git Reflog:</strong>
        <p><code>git reflog</code> - це команда, яка використовується для перегляду історії референсів (посилань) у вашому репозиторії, таких як гілки і головний вказівник (HEAD).</p>
        <p>Вона виводить список операцій, які змінювали референси, такі як переміщення гілок, створення та видалення гілок, коміти та інші дії.</p>
        <p><code>git reflog</code> дозволяє вам відстежувати, як змінювалися посилання в історії вашого репозиторію, і використовується для відновлення стану репозиторію в разі втрати чи помилкових операцій.</p>
        <p>Приклад використання <code>git reflog</code>:</p>
        <pre><code>git reflog</code></pre>
      </li>
    </ul>
    <p>Отже, основна різниця між <code>git log</code> і <code>git reflog</code> полягає в тому, що <code>git log</code> відображає історію комітів у гілці, тоді як <code>git reflog</code> відображає історію змін референсів і може бути використаною для відновлення даних чи гілок після неправильних операцій.</p>
  </li>
</ol>



[Back to top ⬆️](#2-git)
### **31. Що таке GIT stash drop**

> **Короткий варіант відповіді:**

Коли ми закінчимо роботу над схованим елементом або захочемо видалити список, ми можемо використати схованку Git.  
Це гарантує, що останній доданий елемент за замовчуванням або будь-який окремий елемент можна видалити з аргументу.

> **Детальний варіант відповіді:**

`git stash drop` - це команда в системі керування версіями Git, яка використовується для видалення (викидання) одного або кількох збережених стешей (stash) з вашого робочого репозиторію. Стеш - це механізм Git, який дозволяє тимчасово зберегти зміни в невикористаному коміті, щоб ви могли переключитися на іншу гілку або виконати інші операції без комітування змін.

Синтаксис команди `git stash drop` виглядає так:

```bash
git stash drop <stash_name>
```

Основний параметр `stash_name` - це індекс або ім'я стеша, який ви хочете видалити.

Наприклад, якщо ви маєте декілька збережених стешей і ви хочете видалити один з них, ви можете використовувати `git stash list`, щоб переглянути список стешів та їхні індекси, і потім використовувати `git stash drop` для видалення конкретного стеша за його індексом або ім'ям.

Наприклад, щоб видалити стеш з індексом 0:

```bash
git stash drop stash@{0}
```

Після виконання цієї команди відповідний стеш буде видалено з репозиторію, і його зміни будуть втрачені. Будьте обережні, коли видаляєте стеші, оскільки вони призначені для тимчасового зберігання змін, і видалення може призвести до втрати цих змін, які не були ще закомічені.


[Back to top ⬆️](#2-git)
### **32. Як визначити, чи певну гілку було об’єднано в головну**

**```git branch –merged master```** – показує всі гілки, які об’єднано в головний

**```git branch –merged```** – показує всі гілки, які об’єднані в голову

**```git branch –no-merged```** – показує всі гілки, які не об’єднані


[Back to top ⬆️](#2-git)
### **33. Для чого нам потрібні розгалуження в GIT**

Розгалуження (branches) в системі керування версіями Git - це важливий механізм, який дозволяє розробникам працювати над різними функціями чи завданнями паралельно та організовувати робочий процес. Вони є невід'ємною частиною гнучкості та функціональності Git. Ось кілька ключових використань розгалужень в Git:

1 - **Розробка функціональності паралельно:**

   - Розгалуження дозволяють кільком розробникам працювати над різними функціями чи завданнями у власних гілках без впливу на головну робочу гілку (зазвичай головну або іншу стабільну гілку). Кожен розробник може створити свою гілку для вирішення конкретного завдання, і робота в цих гілках не конфліктує між собою.

2 - **Сегментація робочого процесу:**

   - Розгалуження дозволяють сегментувати робочий процес на окремі гілки для розробки, тестування та виправлення помилок. Наприклад, ви можете мати окремі гілки для нового функціоналу, гарячих виправлень помилок та документації, і кожна гілка буде виконувати свої завдання без втручання в інші.

3 - **Запобігання впливу помилок:**

   - Розгалуження дозволяють вам експериментувати та вносити зміни в код на окремій гілці, не боячись впливу цих змін на головний код. Якщо новий код виявиться непрацездатним або з помилками, ви можете просто видалити або відхилити гілку без впливу на інші гілки.

4 - **Збереження стабільності головної гілки:**

   - Головна (або стабільна) гілка може залишатися стабільною та вільно виправлятися, оскільки всі нові функції та зміни спочатку розробляються в окремих гілках. Це дозволяє вести стабільну версію продукту, яка може бути випущена безпечно.

5 - **Легше об'єднання змін:**

   - Коли розробники закінчують роботу над своїми гілками, зміни можна об'єднати (злити) з головною гілкою. Це робиться за допомогою операції злиття (merge) або перебазування (rebase). Розгалуження спрощують процес об'єднання та дозволяють зберігати чітку історію комітів.

6 - **Експерименти та відгалуження на версію:**

   - Ви можете створювати тимчасові гілки для експериментів та створення різних версій продукту. Це корисно для вирішення проблеми або розробки функцій, які можуть бути потенційно корисні в майбутньому.

Загалом, розгалуження в Git дозволяють ефективно керувати процесом розробки, підвищують безпеку роботи з кодом та дозволяють розробникам працювати над різними аспектами проекту незалежно одне від одного.


[Back to top ⬆️](#2-git)
### **34. Що містять складові об’єкта коміту**

> **Короткий варіант відповіді:**

- Cтан проекту в даний момент часу міститься в наборі файлів
- Посилання на фіксацію батьківського об’єкта
- Рядок із 40 символів, який однозначно ідентифікує об’єкт коміту під назвою SHAI

> **Детальний варіант відповіді:**

Об'єкт коміту в системі керування версіями Git містить інформацію про конкретний коміт, включаючи в себе такі складові:

1. **Хеш-код (SHA-1):** Унікальний ідентифікатор коміту, який генерується на основі вмісту коміту та інших метаданих. Цей хеш-код служить для однозначної ідентифікації коміту.

2. **Автор та коміттер:** Інформація про автора коміту (ім'я та електронна адреса) та інформація про коміттера (зазвичай, це той самий автор).

3. **Дата та час:** Дата та час створення коміту.

4. **Повідомлення коміту:** Короткий опис змін, внесених у коміті, який додається при створенні коміту. Це повідомлення допомагає розробникам зрозуміти, які зміни були внесені.

5. **Вказівка на батьківські коміти:** Коміт може вказувати на один або декілька батьківських комітів. У більшості випадків, це один коміт, але в разі об'єднання гілок чи створення коміту злиття, може бути декілька батьківських комітів.

6. **Зміни (дерево коміту):** Список файлів та їхніх хеш-кодів, які були включені у коміт. Ця інформація дозволяє визначити, які файли були змінені у даному коміті.

7. **Хеш-код дерева:** Хеш-код, який вказує на дерево (tree object), що містить інформацію про структуру файлів та папок у коміті. Кожен коміт має вказівку на дерево, яке представляє стан проекту на момент створення коміту.

Об'єкти коміту в Git є не змінними і мають унікальний ідентифікатор (хеш-код), що дозволяє зберігати та відстежувати історію комітів в репозиторії. Кожен новий коміт створює новий об'єкт коміту з посиланням на попередній стан проекту та зберігається у репозиторії.


[Back to top ⬆️](#2-git)
### **35. Що таке HEAD у Git і скільки HEAD можна створити в репозиторії**

- Посилання на об'єкт коміту називається HEAD.  
- Кожен репозиторій має «Головний», який є головним за замовчуванням.  
- У сховищі може бути кілька голів.

![IMG](images/GitHead.png)
![IMG](images/GitBranching.png)


[Back to top ⬆️](#2-git)
### **36. Який звичайний спосіб розгалуження в GIT**

Один зі звичайних способів розгалуження в Git - це створення нової гілки. Ось кроки для створення та роботи з новою гілкою:

1 - **Створення нової гілки:**
   Використовуйте команду `git branch` для створення нової гілки з поточної гілки. Наприклад, якщо ви хочете створити гілку з назвою "feature-branch", виконаєте таку команду:

   ```bash
   git branch feature-branch
   ```

   Або можна одразу створити і перейти на нову гілку за допомогою команди `git checkout -b`:

   ```bash
   git checkout -b feature-branch
   ```

2 - **Робота з новою гілкою:**
   Після створення нової гілки ви можете вносити зміни у ваш проект, комітувати їх і виконувати всі необхідні операції в межах цієї гілки. Всі зміни, які ви внесете, будуть відображені лише в рамках цієї гілки.

3 - **Переключення між гілками:**
   Ви можете переключатися між гілками за допомогою команди `git checkout`. Наприклад, щоб повернутися до головної гілки, виконайте:

   ```bash
   git checkout main
   ```

   Щоб повернутися на вашу створену гілку "feature-branch", виконайте:

   ```bash
   git checkout feature-branch
   ```

4 - **Об'єднання гілок:**
   Після того, як ви закінчите роботу над функціоналом або виправленням на вашій гілці, ви можете об'єднати її з іншими гілками, використовуючи команду `git merge` або `git rebase`. Це дозволить вам включити зміни з вашої гілки в іншу гілку.

5 - **Видалення гілки (необов'язково):**
   Після об'єднання вашої роботи з іншими гілками, якщо ви більше не потребуєте створеної гілки "feature-branch", ви можете її видалити за допомогою команди `git branch -d`:

   ```bash
   git branch -d feature-branch
   ```

   Або, якщо гілка ще не була об'єднана і ви хочете видалити її не зважаючи на статус, використовуйте `-D`:

   ```bash
   git branch -D feature-branch
   ```

Це основний спосіб розгалуження в Git, і він дозволяє розробникам працювати над різними аспектами проекту паралельно та об'єднувати їхні зміни при необхідності.


[Back to top ⬆️](#2-git)
### **37. Як ви визначаєте «конфлікт» у Git**

> **Короткий варіант відповіді:**

Якщо ми хочемо об’єднати коміт, є зміна в одному місці, і така сама зміна вже існує, тоді під час об’єднання Git не зможе передбачити, яка саме зміна має бути пріоритетною.

> **Детальний варіант відповіді:**

У системі керування версіями Git, термін "конфлікт" (conflict) відноситься до ситуації, коли Git не може автоматично об'єднати зміни з двох різних гілок або гілки та її батьківського коміту під час операції злиття (merge) або перебазування (rebase). Конфлікт виникає, коли Git виявляє, що одна частина коду була змінена в одній гілці, а також в іншій, і він не може визначити, яка версія повинна бути використана в результаті операції об'єднання.

Основні ознаки конфлікту в Git включають наступне:

1. **Змінні розділені між гілками:** В одному гілці були внесені певні зміни до певної частини файлу, а в іншому - також були внесені зміни до цієї самої частини файлу.

2. **Спеціальні маркери конфлікту:** Git вставляє спеціальні маркери, щоб показати, де відбувся конфлікт. Зазвичай це виглядає так:

   ```
   <<<<<<< HEAD
   Зміни з гілки HEAD (поточна гілка)
   =======
   Зміни з іншої гілки (або батьківського коміту)
   >>>>>>> branch-name
   ```

   Де `HEAD` - це поточна гілка або коміт, з яким ви працюєте, і `branch-name` - назва іншої гілки чи коміту, з яким ви спробуєте об'єднати зміни.

3. **Відмова від автоматичного об'єднання:** Git не може автоматично вирішити конфлікт і потребує втручання від користувача для вирішення, яка зміна має залишитися і яка має бути видалена або виправлена.

Для вирішення конфліктів в Git розробники повинні відредагувати файл так, щоб вибрати правильну версію або поєднати зміни вручну. Після цього вони повинні видалити маркери конфлікту та додати виправлені файли до індексу за допомогою команди `git add`. Після вирішення всіх конфліктів можна продовжити операцію злиття чи перебазування за допомогою команд `git merge --continue` або `git rebase --continue`.


[Back to top ⬆️](#2-git)
### **38. Як вирішити конфлікт у Git**

Для вирішення конфлікту у Git, вам потрібно виконати кілька кроків:

1. **Виявлення конфлікту:**
   Спершу вам потрібно виявити, в якому файлі виник конфлікт. Git покаже вам спеціальні маркери, що вказують на місце конфлікту в файлах. Відкрийте цей файл в текстовому редакторі.

2. **Редагування файлу:**
   Відредагуйте файл так, щоб вибрати правильну версію коду або поєднати зміни вручну. Видаліть маркери конфлікту і залиште лише той код, який ви бажаєте залишити.

3. **Збереження файлу:**
   Збережіть зміни у відредагованому файлі.

4. **Видалення маркерів конфлікту:**
   Видаліть маркери конфлікту з файлу. Зазвичай це виглядає так:
   
   ```plaintext
   <<<<<<< HEAD
   // Зміни з гілки HEAD (поточна гілка)
   =======
   // Зміни з іншої гілки (або батьківського коміту)
   >>>>>>> branch-name
   ```

   Залишіть лише правильний код та видаліть всі маркери.

5. **Додавання виправлених файлів до індексу:**
   Після виправлення конфлікту додайте виправлені файли до індексу за допомогою команди `git add`.

6. **Завершення операції злиття (merge) або перебазування (rebase):**
   Якщо ви вирішуєте конфлікт під час операції злиття, використовуйте команду `git merge --continue`, якщо ж під час перебазування, то `git rebase --continue`.

7. **Завершення операції коміту (необов'язково):**
   Якщо операція злиття чи перебазування була виконана за допомогою коміту, то після завершення конфлікту потрібно буде зробити коміт, використовуючи команду `git commit`.

Після виконання цих кроків конфлікт буде вирішено, і ви зможете продовжити роботу з вашим репозиторієм.