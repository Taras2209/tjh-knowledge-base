## **10. Запитання для співбесіди на тему Загальні питання (general questions)**

---

- [1. Які знаєте Web elements](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#1-які-знаєте-web-elements)
- [2. Для чого необхідні інструменти розробника в браузері (Chrome DevTools) і як вони допомагають у тестуванні](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#2-для-чого-необхідні-інструменти-розробника-в-браузері-chrome-devtools-і-як-вони-допомагають-у-тестуванні)
- [3. Що таке кеш](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#3-що-таке-кеш)
- [4. Що таке сесія](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#4-що-таке-сесія)
- [5. Навіщо потрібні cookies](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#5-навіщо-потрібні-cookies)
- [6. iFrame і як з ним працювати в Selenium](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#6-iframe-і-як-з-ним-працювати-в-selenium)
- [7. Що таке HTML/CSS/JavaScript](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#7-що-таке-html-css-javascript)
- [8. Яку структуру має веб-сторінка](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#8-яку-структуру-має-веб-сторінка)
- [9. Навіщо чистити кеш](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#9-навіщо-чистити-кеш)
- [10. Що таке AJAX](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#10-що-таке-ajax)
- [11. Що таке ADB](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#11-що-таке-adb)
- [12. Які є HTTP-методи](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#12-які-є-http-методи)
- [13. Розшифрування CRUD](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#13-розшифрування-grud)
- [14. Як відбувається шифрування](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#14-як-відбувається-шифрування)
- [15. Які способи взаємодії з API існують? У чому різниця між ними](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#15-які-способи-взаємодії-з-api-існують-у-чому-різниця-між-ними)
- [16. Як можна протестувати API, що там потрібно перевіряти](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#16-як-можна-протестувати-api-що-там-потрібно-перевіряти)
- [17. Формати передачі даних](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#17-формати-передачі-даних)
- [18. Відмінності між XML та JSON](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#18-відмінності-між-xml-та-json)
- [19. Клієнт-серверна архітектура](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#19-клієнт-серверна-архітектура)
- [20. Для чого потрібні TestNG, JUnit](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#20-для-чого-потрібні-testng-junit)
- [21. Які інструкції використовуються в TestNG, JUnit](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#21-які-інструкції-використовуються-в-testng-junit)
- [22. Які assertions є в TestNG, JUnit](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#22-які-assertions-є-в-testng-junit)
- [23. Як виконувати тести паралельно TestNG, JUnit](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#23-як-виконувати-тести-паралельно-testng-junit)
- [24. 2 способи, що дозволяють автоматизувати капчу](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#24-2-способи-що-дозволяють-автоматизувати-капчу)
- [25. Що таке Selenium Grid](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#25-що-таке-selenium-grid)
- [26. Драйвер браузера](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#26-драйвер-браузера)
- [27. Які види локаторів сторінки існують? Які їх переваги та недоліки](https://github.com/tendil/interview_questions_qa_python_js_java/blob/main/README.md#27-які-види-локаторів-сторінки-існують-які-їх-переваги-та-недоліки)

--- 

## **Відповіді - 'Загальні питання'**

[Back to top ⬆️](#10-general-questions)
### **1. Які знаєте Web elements**

Веб-елементи - це різні складові, які використовуються на веб-сторінках для створення інтерфейсу та взаємодії з користувачем. Ось деякі з основних веб-елементів:

1. **Текстове поле (Text Input):** Використовується для введення тексту, такий як ім'я, електронна пошта або пароль.

2. **Кнопка (Button):** Використовується для спровокування певної дії або події при кліку на неї.

3. **Випадаючий список (Dropdown List):** Дозволяє користувачам вибирати один варіант зі списку опцій.

4. **Прапорець (Checkbox):** Використовується для вибору одного або декількох варіантів із численного списку.

5. **Перемикач (Radio Button):** Користується для вибору одного варіанта зі списку, але користувач може вибрати лише один варіант.

6. **Посилання (Link):** Використовується для навігації між різними сторінками веб-сайту або для відкриття інших веб-ресурсів.

7. **Зображення (Image):** Дозволяє вставляти графічні елементи на веб-сторінку.

8. **Текстова область (Text Area):** Використовується для введення багаторядкового тексту, такого як коментарі або повідомлення.

9. **Таблиця (Table):** Використовується для відображення даних у вигляді рядків і стовпців.

10. **Форма (Form):** Використовується для збору та надсилання даних на сервер.

11. **Список (List):** Використовується для відображення списку елементів, таких як навігаційні меню або списки товарів.

12. **Слайдер (Slider):** Дозволяє користувачам вибирати значення в діапазоні, пересуваючи повзунок.

13. **Картка (Card):** Використовується для структурування контенту та відображення інформації у вигляді карток або блоків.

14. **Меню (Menu):** Використовується для навігації по веб-сайту та доступу до різних розділів.

15. **Поля для завантаження файлів (File Upload):** Дозволяє користувачам вибирати та завантажувати файли на сервер.

16. **Відеоплеєр (Video Player) та Аудіоплеєр (Audio Player):** Використовуються для відтворення відео- та аудіоконтенту.

Це лише кілька прикладів веб-елементів, існує багато інших, і вони можуть комбінуватися та налаштовуватися для створення різноманітних інтерфейсів на веб-сторінках.


[Back to top ⬆️](#10-general-questions)
### **2. Для чого необхідні інструменти розробника в браузері (Chrome DevTools) і як вони допомагають у тестуванні**

* Перевизначення геолокації та підміна User-Agent
* Визначення JS шляху до рядка
* Зміна HTML-коду та стилів CSS у елементів
* Тестування продуктивності та невикористовуваних CSS та Javascript у верстці
* Debug JavaScript
* Імітація повільного мережевого з'єднання
* Моніторинг мережевих запитів
* Інформація про cookies у вкладці applications


[Back to top ⬆️](#10-general-questions)
### **3. Що таке кеш**

*Кеш* — проміжний буфер із швидким доступом до нього, що містить інформацію, яка може бути запитана з найбільшою ймовірністю. Доступ до даних у кеші здійснюється швидше, ніж вибірка вихідних даних з повільнішої пам'яті або віддаленого джерела, проте його обсяг істотно обмежений порівняно зі сховищем вихідних даних.

*Кеш браузера* - буфер між браузером та інтернетом, у якому зберігаються відвідані користувачем сторінки. Замість того, щоб завантажувати їх із інтернету, браузер може «дістати» сторінки з кешу, що значно скорочує швидкість завантаження сторінок. Проблема може виникнути, якщо на сервері оновиться сторінка, а браузер продовжить підвантажувати стару версію з кешу.


[Back to top ⬆️](#10-general-questions)
### **4. Що таке сесія**

*Сесія* - механізм, що дозволяє однозначно ідентифікувати браузер і створює для цього браузера файл на сервері, де зберігаються змінні сеансу.

> **Другий варіант відповіді:**

Сесія в інформаційній та комп'ютерній термінології має декілька різних значень, але основний зміст зазвичай залежить від контексту. В основних сенсах сесія може означати:

1. **Сесія веб-сайту:** У веб-розумінні сесія - це період активності користувача на веб-сайті з моменту входу на сайт до виходу або завершення сеансу (наприклад, у разі виходу з облікового запису). Під час сесії можуть зберігатися дані про користувача, такі як облікові дані або стан кошика для покупок.

2. **Сесія в програмуванні:** У програмуванні сесія - це тимчасовий контекст або область пам'яті, яка зберігає дані, доступ до яких обмежений певним користувачем або процесом. Сесії використовуються для зберігання стану програми або даних, які можуть бути використані під час виконання програми.

3. **Сесія в обміні даними:** В контексті обміну даними між комп'ютерами чи програмами сесія може вказувати на період, протягом якого встановлюється та підтримується з'єднання між двома пристроями чи програмами для передачі даних. Зазвичай, під час сесії обміну даними встановлюються правила, протоколи та параметри для зв'язку.

У кожному випадку сесія служить для визначення тимчасового контексту та управління обміном інформацією між сторонами.


[Back to top ⬆️](#10-general-questions)
### **5. Навіщо потрібні cookies**

*Cookies* - текстові файли невеликого розміру зі службовою інформацією для браузера. Часто в таких файлах зберігається статистика відвідувань, логін та пароль від сайтів чи сервісів, індивідуальні налаштування користувача – регіон, дизайн оформлення та інше.

> **Другий варіант відповіді:**

Cookies (кукі) - це невеликі тексти, які веб-сайти зберігають на комп'ютері користувача через його веб-браузер. Вони виконують кілька важливих функцій, які сприяють покращенню взаємодії між користувачами та веб-сайтами. Ось деякі з найважливіших цілей та функцій cookies:

1. **Збереження стану сесії:** Cookies дозволяють веб-сайту пам'ятати інформацію про користувача під час його сесії на сайті. Наприклад, це може включати дані про авторизацію, які створюють сесію користувача, або вміст кошика для покупок.

2. **Запам'ятовування налаштувань:** Cookies можуть зберігати налаштування та вибори користувача на сайті. Наприклад, мовні налаштування, теми оформлення або інші персоналізовані параметри.

3. **Аналітика та відстеження:** Cookies дозволяють веб-сайтам відстежувати поведінку користувачів, збирати аналітичні дані та статистику. Це допомагає вдосконалювати веб-сайти, розуміти, як користувачі взаємодіють із контентом та функціями сайту.

4. **Рекламна таргетинг:** Cookies використовуються для відстеження інтересів користувачів та відображення релевантної реклами. Наприклад, після перегляду товарів на веб-сайті користувач може побачити рекламу цих товарів на інших веб-сайтах.

5. **Захист безпеки:** Cookies можуть бути використані для захисту веб-сайту від певних видів зловживання або атак, таких як атаки переповнення буфера.

6. **Зручність для користувачів:** Cookies сприяють полегшенню взаємодії користувача з веб-сайтом, забезпечуючи зручність і персоналізацію.

Незважаючи на користь cookies, важливо також враховувати питання приватності.  
Деякі користувачі можуть бути обурені збереженням даних про свою активність на веб-сайтах.  
Тому веб-сайти зазвичай повинні інформувати користувачів про свою політику використання cookies і надавати можливість відмовитися від їх використання, якщо користувач так вибере.


[Back to top ⬆️](#10-general-questions)
### **6. iFrame і як з ним працювати в Selenium**

*Фрейм (Frame/iFrame)* — самостійний документ, який відображається в окремому вікні браузера і є повністю закінченою HTML-сторінкою. Простими словами, кадр - роздільник браузерних вікон на окремі області.

Способи перемикатися на iframe:

* За індексом ```driver.switchTo().frame(i);```
* На ім'я або ідентифікатор ```driver.switchTo().frame("a077aa5e");```
* За веб-елементом
```driver.switchTo().frame(driver.findElement(By.cssSelector("#modal>iframe"));```


[Back to top ⬆️](#10-general-questions)
### **7. Що таке HTML/CSS/JavaScript**

*HTML (HyperText Markup Language/мова гіпертекстової розмітки)* — стандартизована мова розмітки документів для перегляду веб-сторінок у браузері.

*CSS (Cascading Style Sheets/каскадні таблиці стилів)* — формальна мова опису зовнішнього вигляду документа (веб-сторінки), написаного з використанням мови розмітки (найчастіше HTML або XHTML). Також може застосовуватися до будь-яких XML-документів, наприклад SVG або XUL.

*JavaScript* — мультипарадигмова мова програмування. Підтримує об'єктно-орієнтований, імперативний та функціональний стилі. Часто використовується як вбудована мова для програмного доступу до об'єктів програм. Найширше застосування знаходить у браузерах як мову сценаріїв для надання інтерактивності веб-сторінок.


[Back to top ⬆️](#10-general-questions)
### **8. Яку структуру має веб-сторінка**

> **Короткий варіант відповіді:**

* Заголовок: ```<header>```
* Навігаційне меню: ```<nav>```
* Основний вміст: ```<main>```, з різними підрозділами вмісту, представленими елементами ```<article>, <section> та <div>```
* Бічна панель: ```<aside>```, зазвичай розташовується всередині ```<main>```
* Нижній колонтитул: ```<footer>```

> **Детальний варіант відповіді:**

Веб-сторінка має структуру, яка визначається мовою розмітки HTML (Hypertext Markup Language). HTML використовується для створення структури та вмісту веб-сторінок. Основними компонентами структури веб-сторінки є наступні:

1. **Елемент `<html>`:** Кожна веб-сторінка починається з елемента `<html>`, який визначає початок HTML-документу.

2. **Елемент `<head>`:** Елемент `<head>` містить мета-інформацію про сторінку, таку як заголовок (за допомогою `<title>`), підключені таблиці стилів (CSS), підключені скрипти JavaScript і інші налаштування.

3. **Елемент `<body>`:** Елемент `<body>` містить вміст сторінки, такий як текст, зображення, відео та інші елементи, які відображаються на веб-сторінці.

4. **Заголовки (`<h1>`, `<h2>`, ..., `<h6>`):** Заголовки використовуються для визначення структури сторінки та ії рівнів заголовків. `<h1>` - це найбільший заголовок, а `<h6>` - найменший.

5. **Параграфи (`<p>`):** Елемент `<p>` використовується для відображення текстових абзаців.

6. **Зображення (`<img>`):** Елемент `<img>` вставляє зображення на сторінку і використовує атрибути, такі як `src` (шлях до зображення) та `alt` (альтернативний текст, який відображається, якщо зображення не завантажується).

7. **Посилання (`<a>`):** Елемент `<a>` створює гіперпосилання на інші веб-сторінки або ресурси та використовує атрибут `href` для вказівки URL-адреси.

8. **Таблиці (`<table>`):** Елемент `<table>` використовується для створення таблиць з даними на сторінці. Він містить рядки (`<tr>`), які в свою чергу містять комірки (`<td>`) або заголовки комірок (`<th>`).

9. **Списки (`<ul>`, `<ol>`, `<li>`):** Елементи `<ul>` (ненумерований список) і `<ol>` (нумерований список) використовуються для створення списків, а елемент `<li>` вказує окремі елементи списку.

Це лише базова структура веб-сторінки. Вона може бути розширена і вдосконалена за допомогою додаткових HTML-елементів та стилів CSS для надання сторінці бажаного вигляду і поведінки. Крім того, для додавання функціональності і взаємодії на сторінці часто використовуються JavaScript та інші технології.

[Back to top ⬆️](#10-general-questions)
### **9. Навіщо чистити кеш**

> **Короткий варіант відповіді:**

Веб-сторінки можуть відображатися некоректно через те, що в них були внесені зміни, а браузер продовжує використовувати застарілі дані з кешу. Також застарілий кеш може займати місце на залізниці.

> **Детальний варіант відповіді:**

Чищення кешу (cache) може бути корисною дією в різних ситуаціях для покращення продуктивності та усунення проблем на комп'ютері чи веб-переглядачі. Ось деякі з основних причин, чому користувачі та адміністратори систем часто виконують цю операцію:

1. **Оновлення сторінок та додатків:** Кеш зберігає копії ресурсів (зображень, стилів, скриптів тощо), щоб зменшити час завантаження сторінок та покращити продуктивність. Проте, іноді старі версії ресурсів можуть призвести до некоректного відображення веб-сторінок або роботи додатків. Чистка кешу допомагає завжди завантажувати оновлені ресурси.

2. **Усунення проблем з відображенням:** Деякі проблеми на веб-сайтах можуть виникати через неправильно збережений кеш. Чистка кешу може допомогти усунути такі проблеми, такі як неправильне відображення або зависання сторінок.

3. **Звільнення дискового простору:** Кеш може займати значну кількість дискового простору на комп'ютері або мобільному пристрої. Його чистка може допомогти звільнити місце на диску для інших даних та програм.

4. **Конфіденційність і безпека:** Кеш може зберігати чутливу інформацію, таку як паролі або особисті дані. Якщо інші особи мають доступ до вашого пристрою, чищення кешу може бути важливою дією для захисту конфіденційності даних.

5. **Вирішення проблем з додатками:** У разі, якщо програми на вашому пристрої працюють некоректно або відмовляються запускатися, чистка кешу може допомогти у вирішенні цих проблем. Кеш додатків може містити тимчасові файли, які заважають нормальній роботі.

6. **Покращення продуктивності:** Чистка кешу може покращити швидкість роботи комп'ютера чи мобільного пристрою, оскільки завантаження сторінок та додатків може відбуватися швидше після очищення застарілих даних.

Зазвичай чистку кешу рекомендується виконувати періодично, особливо якщо ви стикаєтесь із зазначеними вище проблемами. Однак будьте уважними, оскільки чистка кешу може призвести до тимчасової втрати деяких даних, наприклад, збережених паролів чи історії перегляду.

[Back to top ⬆️](#10-general-questions)
### **10. Що таке AJAX**

*AJAX (Asynchronous JavaScript and XML/асинхронний JavaScript і XML)* - технологія, яка описує як можна отримувати дані з сервера у фоновому режимі та використовувати їх для оновлення сторінки (без перезавантаження). Основна мета AJAX – зробити сайти та веб-додатки більш зручними, швидкими та чуйними.

Асинхронний тому, що дія виконується у фоні (не в основному потоці), таким чином, що вона не заважає користувачеві взаємодіяти зі сторінкою.
JavaScript відповідає за створення та налаштування запиту, надсилання його на сервер, отримання відповіді та його розбір, оновлення сторінки.

Переваги використання AJAX:

* зниження трафіку (зменшення обсягу переданих даних між клієнтом та сервером)
* Зменшення навантаження на сервер (перегенерується тільки частина сторінки, яку потрібно оновити)
* збільшення швидкодії та чуйності (немає необхідності у повному перезавантаженні сторінки, достатньо оновити вміст окремих блоків)
* підвищення інтерактивності (за допомогою AJAX можна відразу відображати результати та зробити ресурс більш зручним для користування)


[Back to top ⬆️](#10-general-questions)
### **11. Що таке ADB**

*ADB (Android Debug Bridge)* - клієнт-серверна програма, яка надає доступ до працюючого емулятора або пристрою. З його допомогою можна копіювати файли, встановлювати скомпільовані програмні пакети та запускати консольні команди.

Складається з трьох компонентів:

* фонової служби (демона), що працює в емуляторі
* сервісу, запущеного на комп'ютері розробника
* клієнтської програми (на зразок DDMS), яка зв'язується зі службою через Сервіс


[Back to top ⬆️](#10-general-questions)
### **12. Які є HTTP-методи**

**GET** - запитує інформацію із зазначеного джерела та не впливає на його вміст. Запит доступний для кешування даних та додавання до закладок.

**POST** - використовується для надсилання даних, що може впливати на вміст ресурсу. На відміну від методу GET, запити POST не можуть бути кешовані, вони не залишаються в історії браузера і їх не можна додати до закладок.

**HEAD** - аналогічний методу GET, проте у відповіді сервера міститься лише заголовок, без тіла. Зазвичай застосовується для того, щоб перевірити, чи існує ресурс за вказаною адресою, а також чи не змінився з моменту останнього звернення.

**PUT** - Завантажує вміст запиту на вказаний у запиті URI. Якщо за заданим URI ресурсу немає, сервер створює його, повертаючи статус 201 (Created).

**PATCH** - Використовується для часткової зміни ресурсу. У PATCH вкладений об'єкт містить набір інструкцій, що описують, як ресурс, має бути модифікований створення нової версії. А в PUT міститься нова версія ресурсу цілком.

**DELETE** - Видаляє вказаний ресурс.

**OPTIONS** - Використовується для опису параметрів комунікації між клієнтом та сервером.

**CONNECT** - Перетворює з'єднання запиту на прозорий TCP/IP-тунель.


[Back to top ⬆️](#10-general-questions)
### **13. Розшифрування CRUD**

> **Короткий варіант відповіді:**

*CRUD* — акронім, що означає чотири базові функції, що використовуються під час роботи з постійними сховищами даних: створення (create), читання (read), модифікація (update), видалення (delete).

> **Детальний варіант відповіді:**

CRUD - це абревіатура, яка використовується для позначення основних операцій, які можуть бути виконані над даними в системах управління базами даних та програмних додатках. Кожна літера в абревіатурі представляє одну з основних операцій:

1. **C - Create (створення):** Операція створення використовується для додавання нових записів або об'єктів до бази даних або системи. Під час операції "створення" нові дані вводяться в систему.

2. **R - Read (читання):** Операція читання використовується для отримання інформації або даних з бази даних чи системи. Ця операція дозволяє користувачам переглядати вже існуючі дані.

3. **U - Update (оновлення):** Операція оновлення дозволяє коригувати або змінювати існуючі дані в базі даних або системі. Зазвичай ця операція використовується для внесення змін у вже існуючі записи.

4. **D - Delete (видалення):** Операція видалення використовується для видалення даних або записів з бази даних чи системи. Ця операція забирає інформацію або об'єкти з системи.

CRUD є однією з основних моделей або методологій для роботи з даними в інформаційних системах. Вона використовується в різних типах програм, включаючи веб-додатки, мобільні додатки, системи управління базами даних та інші. Ця модель визначає основні способи взаємодії з даними та дозволяє здійснювати різноманітні операції з ними.

[Back to top ⬆️](#10-general-questions)
### **14. Як відбувається шифрування**

*Симетричне* - використовується лише один пароль/ключ.

У системі шифрування передбачений математичний алгоритм. На його цифровий "вхід" подається вихідний ключ та вихідні дані. Далі інформація шифрується та надсилається.
При отриманні спрацьовує зворотний алгоритм і проходить процедура дешифрування з використанням того самого ключа.
Якщо знати ключ, то безпека симетричного шифрування прямує до нуля. Тому ключ повинен бути максимально складним та заплутаним. Незважаючи на певні обмеження, симетричне шифрування дуже поширене через простоту та швидкодію.

*Асиметричне* - використовуються два ключі: відкритий/публічний та закритий/приватний. Перевага асиметричного шифрування в тому, що один із ключів завжди залишається на пристрої і не передається.

Схема передачі між двома суб'єктами (А і Б) виглядає так:

* Суб'єкт А генерує пару ключів, публічний та приватний.
* Суб'єкт А передає публічний ключ суб'єкту Б. Передача може здійснюватися незахищеними каналами.
* Суб'єкт Б шифрує пакет даних за допомогою отриманого публічного ключа і передає його А. Передача може здійснюватися незахищеними каналами.
* Суб'єкт А розшифровує отриману від Б інформацію з допомогою приватного ключа.


[Back to top ⬆️](#10-general-questions)
### **15. Які способи взаємодії з API існують? У чому різниця між ними**

* *SOAP (Simple Object Access Protocol)* - Простий Протокол Доступу до Об'єктів. Клієнт та сервер обмінюються повідомленнями за допомогою XML. Це менш гнучкий API, який був більш популярним у минулому.

* *RPC (Remote Procedure Call)* - Видалений Виклик Процедур. Клієнт виконує функцію (або процедуру) на сервері, і сервер надсилає результат назад клієнту.

* Websocket - сучасна розробка web API, яка використовує об'єкти JSON для передачі даних. WebSocket підтримує двосторонній зв'язок між клієнтськими програмами та сервером. Сервер може надсилати повідомлення зворотного дзвінка підключеним клієнтам, що робить його ефективнішим, ніж REST.

* REST - на сьогоднішній день це найпопулярніші та гнучкіші API-інтерфейси в Інтернеті. Клієнт надсилає запити на сервер у вигляді даних. Сервер використовує це введення клієнта для запуску внутрішніх функцій і повертає вихідні дані назад клієнту.


[Back to top ⬆️](#10-general-questions)
### **16. Як можна протестувати API, що там потрібно перевіряти**
Переконатися, що API працює правильно, можна за допомогою функціонального тестування.
Основні завдання:

* переконатися, що реалізація API працює правильно, як і очікувалося
* гарантувати, що реалізація API працює відповідно до специфікації вимог
* запобігти регресії між написаним кодом та релізом

Перевірка специфікації:

* Ендпоінти правильно іменовані
* ресурси та його типи правильно відбивають об'єктну модель
* немає відсутньої або дублюючої функціональності
* відносини між ресурсами правильно відображаються в API

**Етапи тестування API**

Кожен тест складається з атомарних дій, які мають виконуватися у кожному потоці тестування API. Для кожного запиту API тест повинен виконати такі дії:

1. Коригування коду стану HTTP (створення ресурсу має повертати 201 CREATED, а заборонені запити повинні повертати 403 FORBIDDEN і т.д.)
2. Корисне навантаження відповіді (правильність тіла JSON, імен, типів та значень полів відповіді, у тому числі у відповідях на помилкові запити)
3. Заголовки відповіді (заголовки HTTP-сервера впливають як на безпеку, так і на продуктивність)
4. Правильність стану програми (застосовується в основному до ручного тестування або коли інтерфейс користувача або інший інтерфейс можна легко перевірити)
5. Базова працездатність (якщо операція була завершена успішно, але зайняла невиправдано багато часу, тест не пройдено)


[Back to top ⬆️](#10-general-questions)
### **17. Формати передачі даних**

* **JSON (JavaScript Object Notation)** - текстовий формат обміну даними, заснований на JavaScript, але при цьому незалежний від JS.
* **XML (eXtensible Markup Language/розширювана мова розмітки)** - використовується для зберігання та передачі даних. формат рекомендований Консорціумом Всесвітньої павутини (W3C), тому часто використовується передачі даних по API. Єдино можливий формат вхідних та вихідних даних у SOAP.
* **CSV (Comma-Separated Values/значення, розділені комами)** – текстовий формат, призначений для представлення табличних даних з фіксованою кількістю стовпців. Кожен рядок файлу – це один рядок таблиці.
* **YAML (YAML Ain't markup language/YAML не мова розмітки; раніше Yet Another Markup Language)** - мова для серіалізації даних, яка дозволяє зберігати складноорганізовані дані в компактному та читаному форматі. Схожий на XML і JSON, але використовує більш мінімалістичний синтаксис для збереження аналогічних можливостей.


[Back to top ⬆️](#10-general-questions)
### **18. Відмінності між XML та JSON**

**XML** - мова розмітки.

**JSON** - формат обміну даними, зазвичай реалізований, як масив даних.

**Ключові відмінності**:

* Об'єкт JSON має тип, тоді як об'єкти XML не містять типів
* У JSON простіше отримати об'єкт ніж у XML (дані XML повинні бути проаналізовані)
* Читабельність JSON файлу вище в порівнянні з XML
* JSON не забезпечує підтримку простору імен, в той час як XML забезпечує
* JSON не має можливостей відображення, тоді як XML має таку можливість
* JSON менш захищений, тоді як XML більш безпечний у порівнянні з JSON
* JSON підтримує лише кодування UTF-8, тоді як XML підтримує різні кодування


[Back to top ⬆️](#10-general-questions)
### **19. Клієнт-серверна архітектура**

![IMG](images/client_server.png)

- **У проміжках можуть бути балансувальники, якщо використовується кілька серверів або БД.**

Клієнт-серверна архітектура є однією з основних архітектурних парадигм у розробці програмного забезпечення та мережевих систем. У цій архітектурі система поділяється на дві основні компоненти: клієнта і сервера. Кожен з цих компонентів виконує свої функції та взаємодіє з іншими, створюючи розподілену систему. Основні характеристики клієнт-серверної архітектури включають:

1. **Клієнт:** Клієнт - це програма або пристрій, який відправляє запити до сервера та обробляє відповіді. Клієнти зазвичай відповідають за відображення інтерфейсу користувача та взаємодію з користувачем. Вони можуть бути веб-браузерами, мобільними додатками, настільними програмами і т. д.

2. **Сервер:** Сервер - це програма або обладнання, яке обробляє запити від клієнтів, виконує обчислення, доступ до даних та інші операції, і повертає відповіді клієнтам. Сервери зазвичай мають велику потужність і призначені для обробки багатьох запитів в один і той же час.

3. **Комунікація:** Клієнти та сервери взаємодіють між собою через мережу, використовуючи комунікаційні протоколи, такі як HTTP, TCP/IP, FTP і багато інших. Запити передаються від клієнтів до серверів, і відповіді передаються назад до клієнтів.

4. **Розподілена обробка:** В клієнт-серверній архітектурі функції системи розподіляються між клієнтами та серверами. Клієнти зазвичай відповідають за інтерфейс користувача та обробку деяких завдань, а сервери - за зберігання та обробку даних, а також виконання складних обчислень.

5. **Масштабованість:** Системи клієнт-сервер можуть бути легко масштабовані, дозволяючи додавати більше клієнтів та серверів за необхідності, щоб впоратися з більшим обсягом роботи.

6. **Безпека:** Важливим аспектом є забезпечення безпеки взаємодії між клієнтами та серверами. Заходи безпеки можуть включати в себе аутентифікацію, авторизацію, шифрування даних і багато інших методів.

Клієнт-серверна архітектура використовується в різних сферах, таких як веб-розробка, мережеві системи, розробка додатків та багато інших, і вона дозволяє створювати розподілені системи, які можуть бути ефективними та масштабованими.


[Back to top ⬆️](#10-general-questions)
### **20. Для чого потрібні TestNG, JUnit**

> **Короткий варіант відповіді:**

Це фреймворки автоматичного тестування.  
Потрібні щоб не писати свій велосипед для тих самих завдань конфігурування тестів, анотацій для них, дата-провайдерів і т.д.

> **Детальний варіант відповіді:**

TestNG і JUnit є двома популярними фреймворками для написання і виконання автоматизованих тестів в мовах програмування Java та Kotlin. Вони використовуються для тестування програмного забезпечення і мають ряд корисних функцій і можливостей для забезпечення високої якості коду та програми. Основні цілі та використання TestNG і JUnit включають наступне:

1. **Автоматизоване тестування:** Обидва фреймворки дозволяють розробляти і виконувати автоматизовані тести, які перевіряють, чи працює програмне забезпечення відповідно до очікуваних результатів. Це допомагає виявляти помилки та проблеми в програмному коді на ранніх стадіях розробки.

2. **Структура тестів:** TestNG і JUnit надають зручний спосіб організації тестових наборів, запуску тестів у певному порядку і категоризації тестів за допомогою аннотацій чи анотаційних міток.

3. **Параметризовані тести:** Обидва фреймворки дозволяють виконувати однакові тести з різними вхідними даними, що сприяє більш широкому покриттю функціональності програми.

4. **Асерти та перевірка відповідності:** TestNG і JUnit надають різноманітні методи для перевірки відповідності очікуваних результатів і фактичних результатів виконання тесту.

5. **Звітність і логування:** Обидва фреймворки генерують звіти, які допомагають ідентифікувати, які тести були виконані та чи були помилки. Вони також підтримують логування для відстеження дій, які відбуваються під час виконання тестів.

6. **Паралельне виконання тестів:** Обидва фреймворки надають можливість виконувати тести паралельно, що зменшує час виконання тестів у великих проектах.

7. **Інтеграція з іншими інструментами:** TestNG і JUnit можуть легко інтегруватися з іншими інструментами для автоматизованого тестування, такими як Selenium (для веб-тестування), Appium (для мобільного тестування), Jenkins (для CI/CD), і багатьма іншими.

TestNG і JUnit є потужними фреймворками для забезпечення якості програмного забезпечення, і вибір між ними зазвичай залежить від ваших вподобань і потреб в конкретному проекті.

[Back to top ⬆️](#10-general-questions)
### **21. Які інструкції використовуються в TestNG, JUnit**

*TestNG*:

* @BeforeSuite / @AfterSuite
* @BeforeTest / @AfterTest
* @BeforeClass / @AfterClass
* @BeforeGroups / @AfterGroups
* @BeforeMethod / @AfterMethod
* @Test
* @DataProvider
* @Factory
* @Parameters
* @Listener

*jUnit 5*:

* @BeforeAll / @AfterAll
* @BeforeEach / @AfterEach
* @Test
* @Disable
* @Nested
* @Tag
* @TestFactory
* @Suite / @SelectClasses / @SelectPackages / @IncludePackages / @ExcludePackages
* @IncludeClassNamePatterns / @ExcludeClassNamePatterns / @IncludeTags / @ExcludeTags


[Back to top ⬆️](#10-general-questions)
### **22. Які assertions є в TestNG, JUnit**

*TestNG*:

* assertEquals() / assertNotEquals()
* assertTrue() / assertFalse()
* assertNull() / assertNotNull()
* assertSame() / assertNotSame()
* assertEqualsNoOrder()
* fail()


*jUnit 5*:

* assertTrue() / assertFalse()
* assertEquals() / assertNotEquals()
* assertArrayEquals()
* assertIterableEquals()
* assertLinesMatch()
* assertNull() / assertNotNull()
* assertSame() / assertNotSame()
* assertTimeout() / assertTimeoutPreemptively()
* assertThrows()
* fail()


[Back to top ⬆️](#10-general-questions)
### **23. Як виконувати тести паралельно TestNG, JUnit**

Виконання тестів паралельно в TestNG і JUnit може значно збільшити швидкість виконання тестових наборів і зменшити час тестування. Якщо вам потрібно виконати тести паралельно, ось кілька кроків для реалізації цього в TestNG і JUnit:

**Для TestNG:**

1. **Створіть файл `testng.xml`:** Спочатку створіть файл конфігурації `testng.xml`, в якому ви визначите ваші тести та налаштуєте паралельне виконання. Ось приклад:

```xml
<suite name="MyTestSuite" parallel="tests">
    <test name="Test1">
        <classes>
            <class name="com.example.TestClass1" />
        </classes>
    </test>
    <test name="Test2">
        <classes>
            <class name="com.example.TestClass2" />
        </classes>
    </test>
</suite>
```

У цьому прикладі `parallel="tests"` вказує, що тести виконуються паралельно.

2. **Запустіть тестовий файл з командному рядку або з інтегрованого середовища розробки (IDE):** Ви можете запустити тести, вказавши шлях до `testng.xml` у командному рядку або запустивши файл `testng.xml` з вашого IDE.

**Для JUnit:**

JUnit не має вбудованої підтримки паралельного виконання, але ви можете використовувати зовнішні інструменти та бібліотеки для цього:

1. **Використовуйте бібліотеку JUnit Platform:** JUnit 5 має платформу JUnit Platform, яка підтримує паралельне виконання тестів за допомогою інших інструментів, таких як Maven або Gradle. Вам потрібно буде налаштувати Maven або Gradle для запуску тестів паралельно. Офіційна документація JUnit Platform надає детальну інформацію щодо налаштування.

2. **Використовуйте інші інструменти:** Ви також можете використовувати інші інструменти, такі як TestNG або паралельний запуск JUnit з командного рядку, для виконання тестів паралельно. Наприклад, ви можете використовувати `maven-surefire-plugin` для Maven або `parallel` в командному рядку для запуску тестів в різних потоках.

Зауважте, що важливо правильно керувати ресурсами та забезпечити, щоб ваші тести не конфліктували між собою, коли вони виконуються паралельно.


[Back to top ⬆️](#10-general-questions)
### **24. 2 способи, що дозволяють автоматизувати капчу**

1. *Боти з підтримкою оптичного розпізнавання символів (OCR)* - у цьому підході КАПЧА вирішується автоматично за допомогою бота.
2. *Послуги з вирішення капчі реальними людьми* - у сервісі є співробітники, які постійно доступні онлайн для розв'язання капчі. Коли ви відправляєте свою КАПЧУ, компанія пересилає її працівникам, які її вирішують, та відправляє назад рішення.


[Back to top ⬆️](#10-general-questions)
### **25. Що таке Selenium Grid**

> **Короткий варіант відповіді:**

*Selenium Grid* - кластер, що складається з кількох Selenium-серверів. Призначений для організації розподіленої мережі, що дозволяє паралельно запускати багато браузерів на велику кількість машин. Є виділений сервер, що зветься «хаб» чи «коммутатор», інші сервера називаються «ноди» чи «вузли».

> **Детальний варіант відповіді:**

Selenium Grid - це інструмент для тестування веб-додатків, який дозволяє запускати автоматизовані тести на різних браузерах та платформах одночасно та паралельно. Selenium Grid розширює базовий функціонал Selenium WebDriver, дозволяючи тестам виконуватися на віддалених машинах або вузлах, що знаходяться в різних мережах. Головною перевагою Selenium Grid є можливість прискорити виконання тестів і перевірити сумісність веб-додатків з різними браузерами та операційними системами.

Основні компоненти Selenium Grid включають:

1. **Hub (центральна частина):** Це центральний вузол, який приймає запити на виконання тестів та керує розподілом цих запитів між різними вузлами. Hub знає про наявність доступних вузлів і може розподіляти тестові завдання на вільні вузли для виконання.

2. **Node (вузли):** Вузли - це машини або пристрої, на яких запускаються тести. Кожен вузол повинен бути налаштований для певних браузерів і операційних систем, і він може обслуговувати тестові завдання для цих конфігурацій.

3. **Test Script (скрипти тестування):** Це автоматизовані тести, які ви розробляєте для перевірки вашого веб-додатка. Скрипти тестування використовують Selenium WebDriver для взаємодії з браузерами та виконання дій на веб-сторінках.

Процес виконання тестів у Selenium Grid виглядає так:

1. Розробляєте тести, які використовують Selenium WebDriver для взаємодії з веб-додатком.

2. Запускаєте Hub на одній машині (або вузлі), яка відома як центральна точка для керування виконанням тестів.

3. Налаштовуєте вузли (nodes) на різних машинах або пристроях з різними конфігураціями браузерів та ОС.

4. Запускаєте вузли, які реєструються на Hub.

5. Ваші тести будуть розподілені між доступними вузлами для виконання.

6. Звіти та результати виконання тестів можуть бути зібрані інструментами звітності.

Selenium Grid дозволяє ефективно тестувати веб-додатки на різних платформах і браузерах, що допомагає забезпечити високу якість програмного забезпечення і визначити проблеми, пов'язані з сумісністю.

[Back to top ⬆️](#10-general-questions)
### **26. Драйвер браузера**

Драйвер браузера - це програмний компонент, який дозволяє автоматизованому тестовому скрипту взаємодіяти з веб-браузером. Він використовується в автоматизації веб-тестів для керування браузером, надсилання команд на відкриття веб-сторінок, взаємодії з елементами на сторінках та збору інформації для подальшого аналізу.

Основні характеристики та функції драйвера браузера включають наступне:

1. **Запуск браузера:** Драйвери браузера можуть запускати популярні веб-браузери, такі як Google Chrome, Mozilla Firefox, Microsoft Edge, Safari та інші.

2. **Навігація:** Драйвери дозволяють відкривати веб-сторінки за URL-адресою, переходити на інші сторінки, оновлювати сторінку та виконувати інші навігаційні дії.

3. **Взаємодія з елементами:** Драйвери дозволяють знаходити, взаємодіяти та керувати HTML-елементами на веб-сторінці, такими як кнопки, текстові поля, посилання, таблиці тощо. Це дозволяє виконувати дії, такі як натискання на кнопку, введення тексту або отримання значень з елементів.

4. **Збір інформації:** Драйвери можуть отримувати інформацію з веб-сторінок, таку як текст, атрибути елементів, координати, розміри та інші дані, які можуть бути важливими для перевірки стану сторінки або виконання аналізу.

5. **Обробка подій:** Драйвери можуть спостерігати та обробляти події, які виникають на веб-сторінці, такі як кліки мишею, події клавіатури тощо.

6. **Здійснення скріншотів:** Драйвери можуть створювати скріншоти веб-сторінок для візуальної перевірки.

7. **Робота з вікнами і вкладками:** Деякі драйвери дозволяють керувати роботою з вікнами браузера та вкладками.

Драйвери браузера мають різні версії, які підтримуються різними браузерами, і вони зазвичай використовуються в поєднанні з фреймворками автоматизації тестів, такими як Selenium, для створення та виконання автоматизованих тестів веб-додатків.


[Back to top ⬆️](#10-general-questions)
### **27. Які види локаторів сторінки існують? Які їх переваги та недоліки**

> **Короткий варіант відповіді:**

**```id=<element_id>```** - відповідає елементу, у якого атрибут id дорівнює значенню element_id. Слід зазначити, що даний вид локаторів є одним із найшвидших у знаходженні та одним із найунікальніших.

**```name=<element_name>```** - відповідає елементу, у якого атрибут name дорівнює значенню element_name. Ефективно застосовується під час роботи з полями введення форми (кнопки, текстові поля, списки, що випадають). Даний тип локаторів теж є досить швидким у знаходженні, але менш унікальним, тому що на сторінці може бути кілька форм, які можуть мати елементи з однаковим ім'ям.

**```dom=<dom_object>```** - даний тип локатора дозволяє звертатися до елемента так само, як і в DHTML, використовуючи DOM-структуру. Даний тип локатора використовується нечасто, так як зазвичай знаходяться зручніші аналоги, проте дана можливість є.

**```link=<link_text>```** - спеціально для посилань використовується окремо зарезервований тип локаторів, який знаходить потрібне посилання за його текстом. Це зроблено частково тому, що посилання зазвичай не мають таких атрибутів як ID або name. Також у посилання є фіксована частина і є частина, яка може змінюватись. У цьому випадку ми можемо використовувати wildcards, зокрема '*'.

**```xpath=<xpath_locator>```** - найбільш універсальний тип локаторів. HTML є різним поєднанням тегів, які вибудовуються в певну ієрархію, на кшталт структури каталогів у файловій системі. Завдання XPath - відобразити подібний шлях до потрібного елемента з урахуванням ієрархії. XPath має багато зручностей, але є і основний недолік - низька швидкість знаходження об'єкта. У таких випадках рекомендується скористатися CSS-локаторами, але в деяких випадках від XPath піти не вдасться.

**```css=<css_path>```** - даний тип локаторів ґрунтується на описах таблиць стилів (CSS). На відміну від локаторів по ID, імені або тексту посилання, даний тип локаторів може враховувати ієрархію об'єктів, а також значення атрибутів, що робить його найближчим аналогом XPath. А тому, що об'єкт знаходиться по даному локатору швидше, ніж XPath, рекомендується вдаватися до допомоги CSS замість XPath.

> **Детальний варіант відповіді:**

В інструментах автоматизації тестів, таких як Selenium, для знаходження та взаємодії з елементами веб-сторінки використовуються різні види локаторів. Ось деякі з найпоширеніших локаторів:

1. **XPath:**
>   - *Переваги:* Може бути використаний для складних пошуків, дозволяє вибирати елементи за різними атрибутами та ієрархією.
>   - *Недоліки:* Може бути менш ефективним на великих сторінках через повільний розбір дерева DOM.

2. **CSS-селектори:**
>   - *Переваги:* Швидкі та прості в застосуванні, підтримують багато варіантів вибору елементів.
>   - *Недоліки:* Не завжди підходять для складних виборів, атрибути повинні бути унікальними.

3. **ID:**
>   - *Переваги:* Найшвидший та найпростіший локатор, оскільки ID повинні бути унікальними на сторінці.
>   - *Недоліки:* Не завжди можливо знайти ID для кожного елемента.

4. **Name:**
>   - *Переваги:* Широко підтримується і може бути корисним для вибору групи елементів.
>   - *Недоліки:* Також не завжди є унікальним.

5. **Link Text та Partial Link Text:**
>   - *Переваги:* Використовується для пошуку по текстових посиланнях.
>   - *Недоліки:* Може бути нестабільним при зміні тексту посилань.

6. **Class Name:**
>   - *Переваги:* Широко підтримується, дозволяє вибирати елементи за їхніми класами.
>   - *Недоліки:* Може вибрати багато елементів з однаковим класом.

7. **Tag Name:**
>   - *Переваги:* Вибирає всі елементи з вказаним тегом.
>   - *Недоліки:* Вибирає всі елементи з вказаним тегом, що може бути надто загальним.

8. **Спеціальні локатори (наприклад, для роботи з XPath або CSS):**
>   - *Переваги:* Дозволяють створювати складні та точні локатори для специфічних ситуацій.
>   - *Недоліки:* Вимагають глибокого розуміння синтаксису та структури веб-сторінки.

Вибір локатора залежить від конкретної ситуації і структури сторінки.  
**Найкращий локатор** - це той, який є найефективнішим та надійним для вашого конкретного випадку.

