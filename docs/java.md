## **4. Запитання для співбесіди на тему Java**

---

[Back to top ⬆️](#4-java)

- [1. Типи даних у Java](#1-java)
- [2. Відмінності об'єкта від примітивних типів даних](#2)
- [3. Різниця передачі параметрів за посиланням і за значенням](#3)
- [4. Bytecode](#4-bytecode)
- [5. JVM, JDK, JRE](#5-jvm-jdk-jre)
- [6. Ознаки JavaBean](#6-javabean)
- [7. OutOfMemoryError](#7-outofmemoryerror)
- [8. Стектрейс і як його отримати](#8)
- [9. Всі методи класу object](#9-object)
- [10. Різниця між try-with-resources і try-catch-finally](#10-try-with-resources-try-catch-finally)
- [11. Конструктори та їхні типи](#11)
- [12. Параметризований конструктор](#12)
- [13. Побітові операції](#13)
- [14. Кратка характеристика immutable object і навіщо вони потрібні](#14-immutable-object)
- [15. Вимоги для створення immutable класу](#15-immutable)
- [16. Об'єкти яких стандартних класів immutable в Java](#16-immutable-java)
- [17. Переваги immutable object перед звичайними об'єктами](#17-immutable-object)

---

# Відповіді - 'Java'

[Back to top ⬆️](#4-java)

### 1. Типи даних у Java
* boolean - true/false
* byte - -128 до 127, 1 байт
* short - (+/-)3276(7/8), 2 байти
* int - (+/-)214748364(7/8), 4 байти
* long - (+/-)9 223 372 036 854 775 80(7/8), 8 байт
* double - з плаваючою крапкою, 8 байт
* float - із плаваючою крапкою, 4 байти
* char - символ у кодуванні UTF-16 (0 до 65535), 2 байти


[Back to top ⬆️](#4-java)
### 2. Відмінності об'єкта від примітивних типів даних
* примітивні типи виграють у продуктивності та займаній пам'яті


[Back to top ⬆️](#4-java)
### 3. Різниця передачі параметрів за посиланням і за значенням
*Передача за значенням (by value)* - значення фактичних параметрів копіюються. Метод, що викликається, створює свою копію значень аргументів і потім її використовує. Оскільки робота ведеться з копією, на вихідний параметр це ніяк не впливає.

*Передача за посиланням (by reference)* - параметри передаються як посилання (адреса) на вихідну змінну. Метод, що викликається, не створює свою копію, а посилається на вихідне значення. Отже, зміни, зроблені в методі, що викликається, також будуть відображені у вихідному значенні.

    Java завжди передає параметри за значенням! Однак посилання вказують на один і той самий об'єкт у купі (heap), що призводить до змін параметра навіть у зовнішніх методах.


[Back to top ⬆️](#4-java)
### 4. Bytecode
Усі ЯП можна умовно розділити на компільовані та інтерпретовані. У Java використовується третій підхід - байт-код. Вихідний код Java перетворюється компілятором на байт-код (а не машинний код). A байт-код Java перетворюється на машинний код за допомогою спеціального інтерпретатора - JVM.


[Back to top ⬆️](#4-java)
### 5. JVM, JDK, JRE
*JVM (Java Virtual Machine)* - віртуальна машина відповідає за саме виконання коду. Вона працює з байткодом (тим, що міститься всередині файлів із розширенням .class).

*JRE (Java Runtime Environment)* - оточення, необхідне для запуску Java-програм. Включає в себе стандартну бібліотеку. До неї входять, як базові пакети lang, util, так і пакети для роботи з різними форматами, БД, користувацьким інтерфейсом. JVM теж частина JRE.

*JDK (Java Development Kit)* - набір програм для розробки. Включає в себе JRE, завантажувач коду java, компілятор javac, архіватор jar, генератор документації javadoc та інші утиліти, потрібні під час розробки.


[Back to top ⬆️](#4-java)
### 6. Ознаки JavaBean
1. Усі властивості приватні (для доступу геттери/сеттери)
2) Відкритий конструктор без аргументів
3. Реалізує Serializable


[Back to top ⬆️](#4-java)
### 7. OutOfMemoryError
Помилка виникає при нестачі фізичної пам'яті для виділення додатку. Через що додатком падає без інформації в логах або потоці виведення про те, де і чому це сталося.


[Back to top ⬆️](#4-java)
### 8. Стектрейс і як його отримати
Stacktrace (стек викликів) - послідовність викликів функцій у програмі.
```java
StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
    for (StackTraceElement element : stackTraceElements)
    {
       System.out.println(element.getMethodName());
    }
```


[Back to top ⬆️](#4-java)
### 9. Всі методи класу object
```java
//Вертає строкове представлення об'єкта
public String toString()

//Використовуються для порівняння об'єктів
public native int hashCode()
public boolean equals(Object obj)

//Вертає спеціальний об'єкт, який описує поточний клас
public final native Class getClass()

//Методи для контролю доступу до об'єкта з різних ниток/потоків(threads). Керування синхронізацією ниток
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout)
public final void wait(long timeout, intnanos)
public final void wait()

//Дозволяє "звільнити" рідні не-Java ресурси: закрити файли, потоки тощо.
protected void finalize()

//Дозволяє клонувати об'єкт: створює дублікат об'єкта
protected native Object clone()
```


[Back to top ⬆️](#4-java)
### 10. Різниця між try-with-resources і try-catch-finally
try-with-resources аналог традиційного та детального блоку try-catch-finally. Реалізація ресурсу повинна виконуватися в try(). Ресурси автоматично закриваються після try(), замість ручного закриття в блоці finally у try-catch-finally.
```java
try (FileReader fileReader = new FileReader("D:\\\test.txt");) {
...
}
catch (IOException e){
      e.printStackTrace();
}
```


[Back to top ⬆️](#4-java)
### 11. Конструктори та їхні типи
1. *Конструктор за замовчуванням* - не описаний у класі явно, а створений автоматично компілятором.

2. *Конструктор без аргументів*
```java
public BankAccount() {
    name = "";
    opened = LocalDateTime.now();
    баланс = 0.0d;
}
```


[Back to top ⬆️](#4-java)
### 12. Параметризований конструктор
```java
public BankAccount(String name, LocalDateTime opened, double balance) {
    this.name = name;
    this.opened = opened;
    this.balance = balance;
}
```
*Конструктор копіювання* - спеціальний конструктор, який застосовується коли необхідно створити копію складного об'єкта, але при цьому ми не хочемо використовувати метод clone().
*Зв'язані конструктори* - один конструктор викликає інший з цього ж класу.


[Back to top ⬆️](#4-java)
### 13. Побітові операції
*Порозрядні операції* - виконуються над окремими двійковими розрядами або бітами чисел. У цих операціях як операнди можуть виступати тільки цілі числа.
**Логічні операції**:
* & (логічне І / множення) - якщо в обох операндів значення розрядів дорівнює 1, то операція повертає 1, інакше повертається число 0
* | (логічне АБО / додавання) - повертається одиниця, якщо хоча б у одного числа в даному розряді є одиниця
* ^ (логічне виключне АБО / XOR) - Якщо у нас значення поточного розряду в обох чисел різні, то повертається 1, інакше повертається 0
* ~ (логічне заперечення) - інвертує всі розряди числа: якщо значення розряду дорівнює 1, то воно стає 0


[Back to top ⬆️](#4-java)
### 14. Кратка характеристика immutable object і навіщо вони потрібні
*Іммутабельний (незмінний/immutable) об'єкт* - об'єкт, який після ініціалізації не може змінити свій стан. Тобто якщо в коді є посилання на екземпляр імутабельного класу, то будь-які зміни в ньому призводять до створення нового екземпляра. Імутабельність дає змогу будувати стабільніші програми, і її принципи часто застосовуються у фундаментальних частинах софту.


[Back to top ⬆️](#4-java)
### 15. Вимоги для створення immutable класу
* Оголошено як final, щоб від нього не можна було успадковувати. Інакше дочірні класи можуть порушити імутабельність.
* Усі поля класу мають бути приватними відповідно до принципів інкапсуляції.
* Повинні бути параметризовані конструктори для коректного створення екземпляра, через які здійснюється первісна ініціалізація полів класу.
* У класі не повинно бути сеттерів, для виключення можливості зміни стану після інстанціювання
* Для полів-колекцій необхідно робити глибокі копії, щоб гарантувати їхню незмінність.


[Back to top ⬆️](#4-java)
### 16. Об'єкти яких стандартних класів immutable в Java
* String
* Усі класи-обгортки над примітивними типами (Boolean, Integer, Byte, Long...)
* BigInteger і BigDecimal
* Об'єкти класу java.lang.StackTraceElement
* File
* UUID
* Об'єкти класів пакета java.time
* Locale


[Back to top ⬆️](#4-java)
### 17. Переваги immutable object перед звичайними об'єктами
* Потокобезпека - можна вільно використовувати одночасно з різних ниток.
* Є хорошими ключами в map.
* Відмінно підходять для зберігання констант.
* "Атомарність щодо збою" - якщо immutable об'єкт викине виняток, то він все одно не залишиться в небажаному (зламаному) стані.
* Прості в реалізації та тестуванні
* Не потрібні такі додаткові механізми як конструктор копіювання і реалізація клону.
