<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Dmitry Meita"><link href=https://tendil.github.io/tjh-knowledge-base/ rel=canonical><link rel=icon href=assets/images/favicon.png><meta name=generator content="mkdocs-1.5.2, mkdocs-material-9.3.1"><title>TJHelpers Knowledge Base</title><link rel=stylesheet href=assets/stylesheets/main.046329b4.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr> <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#_1 class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=. title="TJHelpers Knowledge Base" class="md-header__button md-logo" aria-label="TJHelpers Knowledge Base" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> TJHelpers Knowledge Base </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Запитання для співбесіди на теми </span> </div> </div> </div> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=. title="TJHelpers Knowledge Base" class="md-nav__button md-logo" aria-label="TJHelpers Knowledge Base" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> TJHelpers Knowledge Base </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=blog/blog_index/ class=md-nav__link> <span class=md-ellipsis> Blog </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> <span class=md-ellipsis> Interview Questions & Answers </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Interview Questions & Answers </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=python/ class=md-nav__link> <span class=md-ellipsis> Python </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#1-python class=md-nav__link> 1. Python </a> </li> <li class=md-nav__item> <a href=#2-git class=md-nav__link> 2. GIT </a> </li> <li class=md-nav__item> <a href=#3-javascript class=md-nav__link> 3. JavaScript </a> </li> <li class=md-nav__item> <a href=#4-java class=md-nav__link> 4. Java </a> </li> <li class=md-nav__item> <a href=#5-qa-manual class=md-nav__link> 5. QA Manual </a> </li> <li class=md-nav__item> <a href=#6-qa-automation class=md-nav__link> 6. QA Automation </a> </li> <li class=md-nav__item> <a href=#7-typescript class=md-nav__link> 7. TypeScript </a> </li> <li class=md-nav__item> <a href=#8-ci-cd class=md-nav__link> 8. CI CD </a> </li> <li class=md-nav__item> <a href=#9 class=md-nav__link> 9. Основні принципи програмування </a> </li> <li class=md-nav__item> <a href=#10 class=md-nav__link> 10. Теорія тестування </a> </li> <li class=md-nav__item> <a href=#11 class=md-nav__link> 11. Бази данних </a> </li> <li class=md-nav__item> <a href=#12 class=md-nav__link> 12. Загальні питання </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=_1>Запитання для співбесіди на теми<a class=headerlink href=#_1 title="Permanent link">&para;</a></h1> <ul> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#1-python>1. Python</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#2-git>2. GIT</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#3-javascript>3. JavaScript</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#4-java>4. Java</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#5-qa-manual>5. QA Manual</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#6-qa-automation>6. QA Automation</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#7-typescript>7. TypeScript</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#8-ci-cd>8. CI CD</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#9-основні-принципи-програмування>9. Основні принципи програмування</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#10-теорія-тестування>10. Теорія тестування</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#11-бази-данних>11. Бази данних</a></p> </li> <li> <p><a href=https://tendil.github.io/tjh-knowledge-base#12-загальні-питання>12. Загальні питання</a></p> </li> </ul> <hr> <h2 id=1-python>1. Python<a class=headerlink href=#1-python title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-види-типізації>1. Види типізації</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-що-таке-змінна>2. Типізація python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-що-таке-змінна>3. Що таке змінна</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-числа-в-python>4. Числа в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-рядки-в-python>5. Рядки в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-рядки-в-python>6. Списки і кортежі в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-cловник-в-python>7. Словник в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-які-типи-даних-відносяться-до-структур-даних>8. Які типи даних відносяться до структур даних</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#9-що-таке-віртуальне-середовище>9. Що таке віртуальне середовище</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#10-як-встановити-віртуальне-середовище>10. Як встановити віртуальне середовище</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#11-види-форматування-рядків>11. Види форматування рядків</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#12-cрізи-або-срізи-в-python>12. Зрізи або срізи в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#13-що-таке-ітерація>13. Що таке ітерація</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#14-які-цикли-існують-в-python>14. Які цикли існують в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#15-в-чому-різниця-між-while-та-for>15. В чому різниця між while та for</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#16-як-реалізоване-розгалуження-в-python>16. Як реалізоване розгалуження в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#17-як-запитати-в-користувача-ввід>17. Як запросити в користувача ввід</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#18-приведення-типів>18. Приведення типів</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#19-що-таке-анотація-типів>19. Що таке анотація типів</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#20-рядок-це-послідовність-чи-ні>20. Рядок це послідовність чи ні</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#21-що-таке-pep>21. Що таке PEP8</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#22-що-таке-функція-range>22. Що таке функція range</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#23-що-робить-enumerate>23. Що робить enumerate</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#24-які-методи-списків>24. Які методи списків</a></li> <li><a href="https://tendil.github.io/tjh-knowledge-base#25-що-в-python-не-є-об'єктом">25. Що в python не є об'єктом</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#26-назви-змінних>26. Назви змінних</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#27-що-таке-літерали>27. Що таке літерали</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#28-чи-можна-число-зробити-рядком>28. Чи можна число зробити рядком</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#29-що-робить-метод-split>29. Що робить метод split()</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#30-що-робить-метод-join>30. Що робить метод join()</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#31-як-імпортувати-модуль>31. Як імпортувати модуль</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#32-як-імпортувати-весь-вміст-модуля>32. Як імпортувати весь вміст модуля</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#33-скільки-пар-ключ-значення-може-бути-в-словнику>33. Скільки пар ключ-значення може бути в словнику</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#34-який-тип-даних-може-бути-значенням-в-словнику>34. Який тип даних може бути значенням в словнику</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#35-як-дізнатися-id-елемента>35. Як дізнатися id елемента</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#36-як-дізнатися-версію-python>36. Як дізнатися версію python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#37-відмінності-другого-python-від-3>37. Відмінності другого python від 3</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#38-як-перервати-виконання-циклу>38. Як перервати виконання циклу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#39-що-означає-continue>39. Що означає continue</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#40-що-буде-якщо-порівняти-5-і-50>40. Що буде, якщо порівняти 5 і 5.0</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#41-що-швидше-python-або-c>41. Що швидше: python або c++</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#42-що-таке-байт-код>42. Що таке байт-код</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#43-як-уникнути-конфліктів-при-імпорті-файлів>43. Як уникнути конфліктів при імпорті файлів</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#44-що-означає-s-d>44. Що означає %s %d</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#45-що-таке-клас>45. Що таке клас</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#46-що-таке-спадкування>46. Що таке успадкування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#47-що-таке-інкапсуляція>47. Що таке інкапсуляція</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#48-що-таке-поліморфізм>48. Що таке поліморфізм</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#49-скільки-може-бути-батьків-і-спадкоємців-у-класу>49. Скільки може бути батьків і спадкоємців у класу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#50-що-таке-перевантаження-операторів>50. Що таке перевантаження операторів</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#51-магічні-методи>51. Магічні методи</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#52-модифікатори-доступу>52. Модифікатори доступу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#53-генератори>53. Генератори</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#54-як-пишуться-коментарі-в-python>54. Як пишуться коментарі в python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#55-як-можна-змінити-зворотній-порядок-елементів-у-списку>55. Як можна змінити (зворотній) порядок елементів у списку</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#56-якщо-ми-не-поставимо-двокрапку-в-кінці-рядка-для-циклу-do-while-він-все-одно-виконається>56. Якщо ми не поставимо двокрапку в кінці рядка для циклу "do-while", він все одно виконається?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#57-як-видалити-зі-списку-дублікат-елемента>57. Як видалити зі списку дублікат елемента</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#58-розкажіть-про-арифметичні-оператори---і->58. Розкажіть про арифметичні оператори //, %, і **</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#59-як-порахувати-довжину-рядка-string>59. Як порахувати довжину рядка (string)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#60-розкажіть-про-генератори-списків-list-comprehension>60. Розкажіть про генератори списків (list comprehension)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#61-що-таке-http>61. Що таке HTTP</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#62-що-таке-json-xml>62. Що таке json, xml</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#63-чим-відрізняється-html-від-xml>63. Чим відрізняється HTML від XML</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#64-що-таке-crud>64. Що таке CRUD</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#65-який-патерн-програмування-реалізує-django>65. Який патерн програмування реалізує Django</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#66-на-якому-етапі-в-додатку-django-відбувається-запит-до-бази-даних>66. На якому етапі в додатку Django відбувається запит до бази даних</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#67-який-результат-буде-postobjectsall-і-якого-типу-верне>67. Який результат буде Post.objects.all() і якого типу верне</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#68-що-таке-sql>68. Що таке SQL</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#69-яким-запитом-я-можу-витягнути-всі-дані-з-таблиці>69. Яким запитом я можу витягнути всі дані з таблиці</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#70-що-таке-багато-до-багатьох-многие-ко-многим>70. Що таке багато-до-багатьох (многие-ко-многим)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#71-як-реалізується-м2м-в-sql>71. Як реалізується М2М в SQL</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#72-що-таке-join-і-яким-він-може-бути>72. Що таке JOIN і яким він може бути</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#73-що-таке-view>73. Що таке View</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#74-що-таке-міксини>74. Що таке міксини</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#75-префіксні-та-інфіксні-оператори>75. Префіксні та інфіксні оператори</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#76-два-способи-створення-класу>76. Два способи створення класу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#77-чим-файл-pyc-відрізняється-від-py>77. Чим файл .pyc відрізняється від .py</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#78-що-робить-python-обєктно-орієнтованим>78. Що робить python об'єктно-орієнтованим</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#79-як-проводиться-відлагодження-програми-на-python>79. Як проводиться відлагодження програми на Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#80-що-таке-gil>80. Що таке GIL</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#81-що-таке-django-middleware>81. Що таке Django Middleware</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#82-як-вставити-обєкт-так-щоб-він-опинився-під-певним-індексом>82. Як вставити об'єкт так, щоб він опинився під певним індексом?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#83-що-потрібно-зробити-щоб-функція-повертала-значення>83. Що потрібно зробити, щоб функція повертала значення? Використовувати оператор return або yield</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#84-що-якщо-в-функції-не-буде-return-чи-вона-щось-поверне>84. Що якщо в функції не буде return, чи вона щось поверне?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#85-напишіть-в-одну-строку-як-можна-отримати-найпізнішу-за-кодом-літеру-у-рядку>85. Напишіть в одну строку, як можна отримати найпізнішу за кодом літеру у рядку</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#86-як-конвертувати-список-в-рядок>86. Як конвертувати список в рядок?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#87-принципи-solid>87. Принципи SOLID</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#88-sql-join>88. SQL JOIN</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#89-sql-оператор-having>89. SQL оператор HAVING</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#90-метакласи-в-python>90. Метакласи в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#91-множинне-спадкування>91. Множинне успадкування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#92-компоненти-django>92. Компоненти django</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#93-які-вбудовані-типи-доступні-в-python>93. Які вбудовані типи доступні в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#94-mutable-та-immutable-типи-даних>94. Mutable та immutable типи даних</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#95-лямбда-функція-в-python>95. Лямбда-функція в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#96-що-означає-простір-імен>96. Що означає простір імен</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#97-чим-відрізняється-pickling-від-unpickling>97. Чим відрізняється pickling від unpickling</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#98-різниця-між-генераторами-та-ітераторами>98. Різниця між генераторами та ітераторами</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#99-як-перетворити-число-в-рядок>99. Як перетворити число в рядок</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#100-обовязково-чи-функція-python-повинна-повертати-значення>100. Обов'язково чи функція Python повинна повертати значення</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#101-чи-існує-в-python-функція-main>101. Чи існує в Python функція main()</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#102-який-метод-використовувався-перед-оператором-in-для-перевірки-наявності-ключа-в-словнику>102. Який метод використовувався перед оператором «in» для перевірки наявності ключа в словнику</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#103-управління-памяттю-в-python>103. Управління пам'яттю в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#104-що-таке-pythonpath>104. Що таке PYTHONPATH</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#105-що-таке-модулі-python>105. Що таке модулі Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#106-що-означає-self-в-python>106. Що означає self в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#107-як-python-інтерпретується-як-мова>107. Як Python інтерпретується як мова</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#108-як-інтерпретується-python>108. Як інтерпретується Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#109-як-в-python-керується-памятю>109. Як в Python керується пам'ятю</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#110-що-таке-функція-в-python>110. Що таке функція в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#111-що-таке-локальні-та-глобальні-змінні-в-python>111. Що таке локальні та глобальні змінні в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#112-чому-лямбда-форми-в-python-не-мають-операторів>112. Чому лямбда-форми в Python не мають операторів</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#113-відємні-індекси-і-чому-їх-використовують>113. Від'ємні індекси і чому їх використовують</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#114-як-отримати-список-усіх-ключів-в-словнику>114. Як отримати список усіх ключів в словнику</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#115-різниця-між-списком-та-кортежем>115. Різниця між списком та кортежем</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#116-що-таке-ітератори-в-python>116. Що таке ітератори в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#117-що-таке-функція-map-в-python>117. Що таке функція map в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#118-що-таке-поверхнева-копія>118. Що таке поверхнева копія</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#119-що-таке-глибока-копія>119. Що таке глибока копія</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#120-що-робить-функція-zip>120. Що робить функція zip()</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#121-що-робить-оператор-with-в-python>121. Що робить оператор with в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#122-коли-виконується-блок-except-в-конструкції-try-except>122. Коли виконується блок except в конструкції try-except</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#123-де-ви-будете-використовувати-while-замість-for>123. Де ви будете використовувати while замість for</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#124-чи-є-масиви-numpy-в-python-кращими-за-списки>124. Чи є масиви NumPy в Python кращими за списки</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#125-як-отримати-поточний-робочий-каталог-за-допомогою-python>125. Як отримати поточний робочий каталог за допомогою Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#126-що-таке-приведення-в-python>126. Що таке приведення в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#127-як-можна-видалити-змінні-в-python>127. Як можна видалити змінні в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#128-в-чому-різниця-між-методами-append-та-extend>128. В чому різниця між методами append та extend</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#129-що-означає-args-kwargs-і-навіщо-нам-їх-використовувати>129. Що означає *args, **kwargs і навіщо нам їх використовувати</a></li> <li><a href="https://tendil.github.io/tjh-knowledge-base#130-що-означає-одинарний-і-подвійний-підкреслення-перед-ім'ям-об'єкта-dunder-methods">130. Що означає одинарний і подвійний підкреслення перед ім'ям об'єкта (dunder methods)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#131-що-таке-генератор>131. Що таке генератор</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#132-яка-мета-одинарної-змінної-підкреслення-в-python>132. Яка мета одинарної змінної підкреслення в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#133-які-типи-спадкування-в-python>133. Які типи успадкування існують в Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#134-що-таке-розпакування-кортежу>134. Що таке розпакування кортежу</a></li> <li><a href="https://tendil.github.io/tjh-knowledge-base#135-чи-звільняється-вся-пам'ять-після-виходу-з-python">135. Чи звільняється вся пам'ять після виходу з Python</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#136-чи-є-функція-дійсною-якщо-вона-не-має-оператора-return>136. Чи є функція дійсною, якщо вона не має оператора return</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#137-на-що-корисно-використовувати-ооп>137. На що корисно використовувати ООП</a></li> <li><a href="https://tendil.github.io/tjh-knowledge-base#138-що-таке-об'єкт">138. Що таке об'єкт</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#139-в-чому-різниця-між-класом-та-структурою>139. В чому різниця між класом та структурою</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#140-чи-можете-ви-викликати-метод-базового-класу-без-створення-екземпляру>140. Чи можете ви викликати метод базового класу без створення екземпляру</a></li> <li><a href="https://tendil.github.io/tjh-knowledge-base#141-в-чому-різниця-між-класом-та-об'єктом">141. В чому різниця між класом та об'єктом</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#142-що-таке-суперклас>142. Що таке суперклас</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#143-що-таке-підклас>143. Що таке підклас</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#144-що-таке-абстракція>144. Що таке абстракція</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#145-різниця-між-процедурним-програмуванням-та-ооп>145. Різниця між процедурним програмуванням та ООП</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#146-в-чому-різниця-між-модулем-та-пакетом-в-python>146. В чому різниця між модулем та пакетом в Python</a></li> </ul> <h2 id=2-git>2. GIT<a class=headerlink href=#2-git title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-що-таке-git>1. Що таке Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-як-створити-локальний-git-репозиторій>2. Як створити локальний Git репозиторій</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-що-таке-git-push>3. Що таке git push</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-що-робить-git-commit>4. Що робить git commit</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-git-merge-та-rebase>5. Git merge та rebase</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-для-чого-використовують-системи-контролю-версій>6. Для чого використовують системи контролю версій</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-що-таке-git-і-github>7. Що таке Git і GitHub?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-яка-різниця-між-git-і-github>8. Яка різниця між Git і GitHub?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#9-які-основні-відмінності-між-git-і-svn>9. Які основні відмінності між Git і SVN?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#10-які-переваги-використання-git>10. Які переваги використання GIT?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#11-яка-мова-використовується-в-git>11. Яка мова використовується в GIT</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#12-що-таке-git-bash>12. Що таке Git Bash</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#13-що-означає-індекс-або-посадкова-область-у-git-staging-area>13. Що означає «Індекс» або «Посадкова область» у git (Staging Area)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#14-що-таке-тегування-в-git-tagging>14. Що таке тегування в Git (tagging)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#15-що-таке-forking-в-git>15. Що таке forking в Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#16-для-чого-корисний-git-clone>16. Для чого корисний Git clone</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#17-17-який-процес-створення-репозиторію-в-git>17. Який процес створення репозиторію в Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#18-що-таке-cherry-pick-у-git>18. Що таке cherry-pick у Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#19-що-таке-origin-у-git>19. Що таке origin у Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#20-що-таке-команда-git-pull>20. Що таке команда git pull</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#21-яка-різниця-між-git-fetch-і-git-pull>21. Яка різниця між git fetch і git pull</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#22-поясніть-git-checkout-у-git>22. Поясніть git checkout у Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#23-що-робить-git-rebase>23. Що робить git rebase</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#24-яка-різниця-між-git-rebase-і-git-merge>24. Яка різниця між git rebase і git merge</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#25-що-таке-git-revert>25. Що таке git revert</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#26-яка-різниця-між-between-resetting-and-reverting>26. Яка різниця між between resetting and reverting</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#27-яка-різниця-між-git-remote-і-git-clone>27. Яка різниця між «git remote» і «git clone»</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#28-що-таке-git-stash>28. Що таке GIT stash</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#29-чим-fork-branch-и-clone-відрізняються-один-від-одного>29. Чим fork, branch, и clone відрізняються один від одного</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#30-яка-різниця-між-git-reflog-і-log>30. Яка різниця між git reflog і log</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#31-що-таке-git-stash-drop>31. Що таке GIT stash drop</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#32-як-визначити-чи-певну-гілку-було-обєднано-в-головну>32. Як визначити, чи певну гілку було об’єднано в головну</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#33-для-чого-нам-потрібні-розгалуження-в-git>33. Для чого нам потрібні розгалуження в GIT</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#34-що-містять-складові-обєкта-коміту>34. Що містять складові об’єкта коміту</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#35-що-таке-head-у-git-і-скільки-head-можна-створити-в-репозиторії>35. Що таке HEAD у Git і скільки HEAD можна створити в репозиторії</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#36-який-звичайний-спосіб-розгалуження-в-git>36. Який звичайний спосіб розгалуження в GIT</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#37-як-ви-визначаєте-конфлікт-у-git>37. Як ви визначаєте «конфлікт» у git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#38-як-вирішити-конфлікт-у-git>38. Як вирішити конфлікт у Git</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#></a></li> </ul> <h2 id=3-javascript>3. JavaScript<a class=headerlink href=#3-javascript title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <table> <thead> <tr> <th>№</th> <th>Питання</th> </tr> </thead> <tbody> <tr> <td>1</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#1-які-існують-способи-створення-обєктів-у-javascript>Які існують способи створення об'єктів у JavaScript</a></td> </tr> <tr> <td>2</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#2-що-таке-ланцюг-прототипів>Що таке ланцюг прототипів</a></td> </tr> <tr> <td>3</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#3-в-чому-різниця-між-методами-call-apply-та-bind>В чому різниця між методами Call, Apply та Bind</a></td> </tr> <tr> <td>4</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#4-що-таке-json-та-його-загальні-операції>Що таке JSON та його загальні операції</a></td> </tr> <tr> <td>5</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#5-яка-мета-методу-slice-для-масиву>Яка мета методу slice для масиву</a></td> </tr> <tr> <td>6</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#6-яка-мета-методу-splice-для-масиву>Яка мета методу splice для масиву</a></td> </tr> <tr> <td>7</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#7-в-чому-різниця-між-slice-та-splice>В чому різниця між slice та splice</a></td> </tr> <tr> <td>8</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#8-як-порівняти-обєкт-із-map>Як порівняти Об'єкт із Map</a></td> </tr> <tr> <td>9</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#9-в-чому-різниця-між-операторами--та--operators>В чому різниця між операторами == та ===</a></td> </tr> <tr> <td>10</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#10-що-таке-лямбда-або-стрілкові-функції>Що таке лямбда- або стрілкові функції</a></td> </tr> <tr> <td>11</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#11-що-таке-функція-першого-класу>Що таке функція першого класу</a></td> </tr> <tr> <td>12</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#12-що-таке-функція-першого-порядку>Що таке функція першого порядку</a></td> </tr> <tr> <td>13</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#13-що-таке-функція-вищого-порядку>Що таке функція вищого порядку</a></td> </tr> <tr> <td>14</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#14-що-таке-унарна-функція>Що таке унарна функція</a></td> </tr> <tr> <td>15</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#15-що-таке-функція-каррінг>Що таке функція каррінг</a></td> </tr> <tr> <td>16</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#16-що-таке-чиста-функція>Що таке чиста функція</a></td> </tr> <tr> <td>17</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#17-яка-мета-ключового-слова-let>Яка мета ключового слова let</a></td> </tr> <tr> <td>18</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#18-в-чому-різниця-між-let-та-var>В чому різниця між let та var</a></td> </tr> <tr> <td>19</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#19-яка-причина-вибору-назви-let-як-ключового-слова>Яка причина вибору назви let як ключового слова</a></td> </tr> <tr> <td>20</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#20-як-перевизначити-змінні-в-switch-блоку-без-помилки>Як перевизначити змінні в switch блоку без помилки</a></td> </tr> <tr> <td>21</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#21-що-таке-тимчасова-мертва-зона>Що таке Тимчасова мертва зона</a></td> </tr> <tr> <td>22</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#22-що-таке-негайно-викликані-функціональні-вирази-iife>Що таке Негайно Викликані Функціональні Вирази (IIFE)</a></td> </tr> <tr> <td>23</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#23-як-декодувати-або-закодувати-url-в-javascript>Як декодувати або закодувати URL в JavaScript?</a></td> </tr> <tr> <td>24</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#24-що-таке-мемоізація>Що таке мемоізація</a></td> </tr> <tr> <td>25</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#25-що-таке-хойстінг>Що таке Хойстінг</a></td> </tr> <tr> <td>26</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#26-що-таке-класи-в-es6>Що таке класи в ES6</a></td> </tr> <tr> <td>27</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#27-що-таке-замикання>Що таке замикання</a></td> </tr> <tr> <td>28</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#28-що-таке-модулі>Що таке модулі</a></td> </tr> <tr> <td>29</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#29-чому-вам-потрібні-модулі>Чому вам потрібні модулі</a></td> </tr> <tr> <td>30</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#30-що-таке-область-видимості-в-javascript>Що таке область видимості в JavaScript</a></td> </tr> <tr> <td>31</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#31-що-таке-сервісний-працівник-service-worker>Що таке сервісний працівник (service worker)</a></td> </tr> <tr> <td>32</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#32-як-ви-змінюєте-dom-використовуючи-сервісний-працівник-service-worker>Як ви змінюєте DOM, використовуючи сервісний працівник (service worker)</a></td> </tr> <tr> <td>33</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#33-як-ви-перевикористовуєте-інформацію-під-час-перезапуску-сервісного-працівника-service-worker>Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker)</a></td> </tr> <tr> <td>34</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#34-що-таке-indexeddb>Що таке IndexedDB</a></td> </tr> <tr> <td>35</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#35-що-таке-веб-сховище-web-storage>Що таке веб-сховище (web storage)</a></td> </tr> <tr> <td>36</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#36-що-таке-пост-повідомлення-post-message>Що таке пост-повідомлення (post message)</a></td> </tr> <tr> <td>37</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#37-що-таке-кука-cookie>Що таке кука (cookie)</a></td> </tr> <tr> <td>38</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#38-чому-вам-потрібна-кука-cookie>Чому вам потрібна кука (cookie)</a></td> </tr> <tr> <td>39</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#39-які-параметри-куки-cookie>Які параметри куки (cookie)</a></td> </tr> <tr> <td>40</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#40-як-видаляти-куку-cookie>Як видаляти куку (cookie)</a></td> </tr> <tr> <td>41</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#41-яка-різниця-між-кукою-локальним-сховищем-та-сеансовим-сховищем-local-storage-та-session-storage>Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage)</a></td> </tr> <tr> <td>42</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#42-яка-основна-різниця-між-localstorage-та-sessionstorage>Яка основна різниця між localStorage та sessionStorage</a></td> </tr> <tr> <td>43</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#43-як-отримати-доступ-до-веб-сховища-web-storage>Як отримати доступ до веб-сховища (web storage)</a></td> </tr> <tr> <td>44</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#44-які-методи-доступні-для-сеансового-сховища-session-storage>Які методи доступні для сеансового сховища (session storage)</a></td> </tr> <tr> <td>45</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#45-що-таке-подія-сховища-storage-event-та-його-обробник-події-event-handler>Що таке подія сховища (storage event) та його обробник події (event handler)</a></td> </tr> <tr> <td>46</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#46-чому-вам-потрібне-веб-сховище-web-storage>Чому вам потрібне веб-сховище (web storage)</a></td> </tr> <tr> <td>47</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#47-як-перевірити-підтримку-веб-сховища-браузером-browser-support>Як перевірити підтримку веб-сховища браузером (browser support)</a></td> </tr> <tr> <td>48</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#48-як-перевірити-підтримку-веб-працівників-браузером-browser-support>Як перевірити підтримку веб-працівників браузером (browser support)</a></td> </tr> <tr> <td>49</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#49-надайте-приклад-веб-працівника-web-worker>Надайте приклад веб-працівника (web worker)</a></td> </tr> <tr> <td>50</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#50-які-обмеження-веб-працівників-на-dom>Які обмеження веб-працівників на DOM</a></td> </tr> <tr> <td>51</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#51-що-таке-обіцянка-promise>Що таке обіцянка (promise)</a></td> </tr> <tr> <td>52</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#52-чому-вам-потрібна-обіцянка-promise>Чому вам потрібна обіцянка (promise)</a></td> </tr> <tr> <td>53</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#53-які-три-стані-у-обіцянки-promise>Які три стани у обіцянки (promise)</a></td> </tr> <tr> <td>54</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#54-що-таке-зворотний-виклик-callback-function>Що таке зворотний виклик (callback function)</a></td> </tr> <tr> <td>55</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#55-чому-нам-потрібні-зворотні-виклики-callbacks>Чому нам потрібні зворотні виклики (callbacks)</a></td> </tr> <tr> <td>56</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#56-що-таке-інферно-зворотніх-викликів-callback-hell>Що таке "інферно зворотніх викликів" (callback hell)</a></td> </tr> <tr> <td>57</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#57-що-таке-події-відправлені-з-сервера-server-sent-events>Що таке події, відправлені з сервера (server-sent events)</a></td> </tr> <tr> <td>58</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#58-як-ви-отримуєте-повідомлення-подій-відправлених-з-сервера-server-sent-events>Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>59</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#59-як-перевірити-підтримку-браузером-для-подій-відправлених-з-сервера-server-sent-events>Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>60</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#60-які-події-доступні-для-подій-відправлених-з-сервера-server-sent-events>Які події доступні для подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>61</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#60-які-події-доступні-для-подій-відправлених-з-сервера-server-sent-events>Які події доступні для подій, відправлених з сервера (server-sent events)</a></td> </tr> <tr> <td>62</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#61-які-основні-правила-обіцянок-promise>Які основні правила обіцянок (promise)</a></td> </tr> <tr> <td>63</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#62-що-таке-зворотній-виклик-у-зворотньому-виклику-callback-in-callback>Що таке зворотній виклик у зворотньому виклику (callback in callback)</a></td> </tr> <tr> <td>63</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#63-що-таке-ланцюг-обіцянок-promise-chaining>Що таке ланцюг обіцянок (promise chaining)</a></td> </tr> <tr> <td>64</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#64-що-таке-promiseall>Що таке promise.all</a></td> </tr> <tr> <td>65</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#65-яка-мета-методу-race-у-обіцянок-promise>Яка мета методу race у обіцянок (promise)</a></td> </tr> <tr> <td>66</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#66-що-таке-строгий-режим-у-javascript-strict-mode>Що таке строгий режим у JavaScript (strict mode)</a></td> </tr> <tr> <td>67</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#67-чому-вам-потрібен-строгий-режим-strict-mode>Чому вам потрібен строгий режим (strict mode)</a></td> </tr> <tr> <td>68</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#68-як-ви-оголошуєте-строгий-режим-strict-mode>Як ви оголошуєте строгий режим (strict mode)</a></td> </tr> <tr> <td>69</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#69-яка-мета-подвійного-оклику-double-exclamation>Яка мета подвійного оклику (!!) (double exclamation)</a></td> </tr> <tr> <td>70</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#70-яка-мета-оператора-delete>Яка мета оператора delete</a></td> </tr> <tr> <td>71</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#71-який-оператор-typeof>Який оператор typeof</a></td> </tr> <tr> <td>72</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#72-що-таке-властивість-undefined>Що таке властивість undefined</a></td> </tr> <tr> <td>73</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#73-що-таке-значення-null>Що таке значення null</a></td> </tr> <tr> <td>74</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#74-яка-різниця-між-значенням-null-та-undefined>Яка різниця між значенням null та undefined</a></td> </tr> <tr> <td>75</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#75-що-таке-функція-eval>Що таке функція eval</a></td> </tr> <tr> <td>76</td> <td><a href="https://tendil.github.io/tjh-knowledge-base#76-яка-різниця-між-об'єктом-window-та-document">Яка різниця між об'єктом window та document</a></td> </tr> <tr> <td>77</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#77-як-ви-отримуєте-доступ-до-історії-у-javascript>Як ви отримуєте доступ до історії у JavaScript</a></td> </tr> <tr> <td>78</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#78-як-ви-визначаєте-чи-включена-клавіша-caps-lock-чи-ні>Як ви визначаєте, чи включена клавіша Caps Lock, чи ні</a></td> </tr> <tr> <td>79</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#79-що-таке-функція-isnan>Що таке функція isNaN</a></td> </tr> <tr> <td>80</td> <td><a href=#яка-різниця-між-змінними-які-не-оголошені-та-змінними-які-мають-значення-undefined>Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined</a></td> </tr> <tr> <td>81</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#81-що-таке-глобальні-змінні>Що таке глобальні змінні</a></td> </tr> <tr> <td>82</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#82-які-проблеми-із-глобальними-змінними>Які проблеми із глобальними змінними</a></td> </tr> <tr> <td>83</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#83-що-таке-властивість-nan>Що таке властивість NaN</a></td> </tr> <tr> <td>84</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#84-яка-мета-функції-isfinite>Яка мета функції isFinite</a></td> </tr> <tr> <td>85</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#85-що-таке-потік-подій-event-flow>Що таке потік подій (event flow)</a></td> </tr> <tr> <td>86</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#86-що-таке-всплиття-подій-event-bubbling>Що таке всплиття подій (event bubbling)</a></td> </tr> <tr> <td>87</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#87-що-таке-захоплення-подій-event-capturing>Що таке захоплення подій (event capturing)</a></td> </tr> <tr> <td>88</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#88-як-ви-відправляєте-форму-за-допомогою-javascript>Як ви відправляєте форму за допомогою JavaScript</a></td> </tr> <tr> <td>89</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#89-як-ви-знаходите-деталі-операційної-системи>Як ви знаходите деталі операційної системи</a></td> </tr> <tr> <td>90</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#90-яка-різниця-між-подіями-document-load-та-domcontentloaded>Яка різниця між подіями document load та DOMContentLoaded</a></td> </tr> <tr> <td>91</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#91-яка-різниця-між-вбудованими-native-господарськими-host-та-користувацькими-user-обєктами>Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами</a></td> </tr> <tr> <td>92</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#92-які-інструменти-або-техніки-використовуються-для-відлагодження-коду-javascript>Які інструменти або техніки використовуються для відлагодження коду JavaScript</a></td> </tr> <tr> <td>93</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#93-які-переваги-та-недоліки-обіцянок-promises-порівняно-зі-зворотніми-викликами-callbacks>Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks)</a></td> </tr> <tr> <td>94</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#94-яка-різниця-між-атрибутом-та-властивістю-property>Яка різниця між атрибутом та властивістю (property)</a></td> </tr> <tr> <td>95</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#95-що-таке-політика-однакового-походження-same-origin-policy>Що таке політика однакового походження (same-origin policy)</a></td> </tr> <tr> <td>96</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#96-яка-мета-фрази-void-0>Яка мета фрази void 0</a></td> </tr> <tr> <td>97</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#97-чи-є-javascript-компільованою-чи-інтерпретованою-мовою>Чи є JavaScript компільованою чи інтерпретованою мовою</a></td> </tr> <tr> <td>98</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#98-чи-є-javascript-чутливою-до-регістру-мовою>Чи є JavaScript чутливою до регістру мовою</a></td> </tr> <tr> <td>99</td> <td><a href="https://tendil.github.io/tjh-knowledge-base#99-чи-існує-якась-зв'язок-між-java-та-javascript">Чи існує якась зв'язок між Java та JavaScript</a></td> </tr> <tr> <td>100</td> <td><a href=https://tendil.github.io/tjh-knowledge-base#100-що-таке-події-events>Що таке події (events)</a></td> </tr> </tbody> </table> <h2 id=4-java>4. Java<a class=headerlink href=#4-java title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-типи-даних-у-java>1. Типи даних у Java</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-відмінності-обєкта-від-примітивних-типів-даних>2. Відмінності об'єкта від примітивних типів даних</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-різниця-передачі-параметрів-за-посиланням-і-за-значенням>3. Різниця передачі параметрів за посиланням і за значенням</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-bytecode>4. Bytecode</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-jvm-jdk-jre>5. JVM, JDK, JRE</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-ознаки-javabean>6. Ознаки JavaBean</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-outofmemoryerror>7. OutOfMemoryError</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-стектрейс-і-як-його-отримати>8. Стектрейс і як його отримати</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#>9. Всі методи класу object</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#>10. Різниця між try-with-resources і try-catch-finally</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#11-конструктори-та-їхні-типи>11. Конструктори та їхні типи</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#12-параметризований-конструктор>12. Параметризований конструктор</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#13-побітові-операції>13. Побітові операції</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#14-кратка-характеристика-immutable-object-і-навіщо-вони-потрібні>14. Кратка характеристика immutable object і навіщо вони потрібні</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#15-вимоги-для-створення-immutable-класу>15. Вимоги для створення immutable класу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#16-обєкти-яких-стандартних-класів-immutable-в-java>16. Об'єкти яких стандартних класів immutable в Java</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#17-переваги-immutable-object-перед-звичайними-обєктами>17. Переваги immutable object перед звичайними об'єктами</a></li> </ul> <h2 id=5-qa-manual>5. QA Manual<a class=headerlink href=#5-qa-manual title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h2 id=6-qa-automation>6. QA Automation<a class=headerlink href=#6-qa-automation title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h2 id=7-typescript>7. TypeScript<a class=headerlink href=#7-typescript title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-перелічіть-вбудовані-типи-у-typescript>1. Перелічіть вбудовані типи у Typescript</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-що-таке-модулі-в-typescript>2. Що таке модулі в Typescript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-що-таке-typescript-і-чому-його-варто-використовувати?>3. Що таке Typescript і чому його варто використовувати?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-поясніть-що-таке-узагальнення-в-typeScript>4. Поясніть, що таке узагальнення в TypeScript</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-що-таке-typescript-і-чому-я-повинен-використовувати-його-замість-javascript>5. Що таке TypeScript і чому я повинен використовувати його замість JavaScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-що-таке-typescript-і-навіщо-він-потрібен>6. Що таке TypeScript і навіщо він потрібен?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-які-переваги-має-typescript>7. Які переваги має TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-чи-потрібно-компілювати-файли-typescript-і-чому>8. Чи потрібно компілювати файли TypeScript і чому?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#9-як-викликати-конструктор-базового-класу-з-дочірнього-класу-в-typescript>9. Як викликати конструктор базового класу з дочірнього класу в TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#10-яка-різниця-між-typescript-та-javascript>10. Яка різниця між TypeScript та JavaScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#11-що-таке-інтерфейс-у-typescript>11. Що таке інтерфейс у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#12-коли-використовувати-інтерфейси-а-коли-класи-в-typescript>12. Коли використовувати інтерфейси, а коли класи в TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#13-яка-різниця-між-класами-та-інтерфейсами-у-typescript>13. Яка різниця між класами та інтерфейсами у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#14-що-таке-декоратори-у-typescript>14. Що таке "Декоратори" у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#15-що-таке-getter-setter-в-typescript>15. Що таке getter/setter в TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#16-як-можна-перевірити-null-та-undefined-у-typescript>16. Як можна перевірити null та undefined у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#17-як-реалізувати-константи-класу-в-typescript>17. Як реалізувати константи класу в TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#18-чи-можна-використовувати-typescript-на-бекенді-і-як>18. Чи можна використовувати TypeScript на бекенді і як?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#19-чи-підтримує-typescript-всі-обєктно-орієнтовані-принципи>19. Чи підтримує TypeScript всі об'єктно-орієнтовані принципи?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#20-які-обєктно-орієнтовані-терміни-підтримуються-у-typescript>20. Які об'єктно-орієнтовані терміни підтримуються у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#21-що-таке-файл-typescript-map>21. Що таке файл TypeScript Map?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#22-чи-можливі-в-typescript-сильно-типізовані-функції-в-якості-параметрів>22. Чи можливі в TypeScript сильно типізовані функції в якості параметрів?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#23-чи-є-цей-код-typescript-коректним-поясніть-чому>23. Чи є цей код TypeScript коректним? Поясніть чому</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#24-які-існують-різні-компоненти-typescript>24. Які існують різні компоненти TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#25-як-typescript-є-необовязково-статично-типізованою-мовою>25. Як TypeScript є необов'язково статично типізованою мовою</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#26-який-модифікатор-доступу-за-замовчуванням-для-членів-класу-у-typescript>26. Який модифікатор доступу за замовчуванням для членів класу у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#27-як-зробити-класи-визначені-в-модулі-доступними-за-межами-модуля>27. Як зробити класи, визначені в модулі, доступними за межами модуля?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#28-що-не-так-з-цим-кодом>28. Що не так з цим кодом?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#29-чи-підтримує-typescript-перевантаження-функцій>29. Чи підтримує TypeScript перевантаження функцій?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#30-як-використовувати-зовнішні-бібліотеки-простого-javascript-у-typescript>30. Як використовувати зовнішні бібліотеки простого JavaScript у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#31-що-таке-типізація-в-typescript>31. Що таке типізація в TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#32-яка-різниця-між-операторами-інтерфейс-vs-тип>32. Яка різниця між операторами "інтерфейс vs тип"?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#33-як-би-ви-перевантажили-конструктор-класу-у-typescript>33. Як би ви перевантажили конструктор класу у TypeScript?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#34-поясніть-чому-цей-код-позначено-я-wrong>34. Поясніть, чому цей код позначено як WRONG?</a></li> </ul> <h2 id=8-ci-cd>8. CI CD<a class=headerlink href=#8-ci-cd title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-що-таке-ci-cd>1. Що таке CI/CD</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-послідовність-виконанняci-cd-процесу-на-проекті>2. Послідовність виконання CI/CD процесу на проекті</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-як-автоматичне-тестування-інтегрується-в-ci>3. Як автоматичне тестування інтегрується в CI</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-які-інструменти-для-генерації-репорту-після-виконання-автоматичних-тестів-ви-знаєте>4. Які інструменти для генерації репорту після виконання автоматичних тестів ви знаєте</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-яку-інформацію-має-містити-звіт-про-виконання-автоматичних-тестів>5. Яку інформацію має містити звіт про виконання автоматичних тестів</a></li> </ul> <h2 id=9>9. Основні принципи програмування<a class=headerlink href=#9 title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-статуси-відповідей-http>1. Статуси відповідей HTTP</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-що-таке-DRY-KISS-YAGNI>2. Що таке DRY, KISS, YAGNI</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-які-патерни-gof-вам-відомі-наведіть-приклади-їхнього-використання>3. Які патерни GOF вам відомі? Наведіть приклади їхнього використання</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-pageobject-та-pageFactory>4. PageObject та PageFactory</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-яка-ієрархія-collections>5. Яка ієрархія Collections</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-різниця-між-thread-class-та-runnable-interface>6. Різниця між Thread class та Runnable interface</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-різниця-між-string-stringbuffer-і-Stringbuilder>7. Різниця між String, Stringbuffer і Stringbuilder</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-різниця-між-final-finally-та-finalize>8. Різниця між final, finally та finalize</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#9->9. </a></li> </ul> <h2 id=10>10. Теорія тестування<a class=headerlink href=#10 title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-що-таке-тестування>1. Що таке тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-навіщо-тестувати-програмне-забезпечення>2. Навіщо тестувати програмне забезпечення</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-які-існують-етапи-тестування>3. Які існують етапи тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-які-типи-тестування-можна-назвати>4. Які типи тестування можна назвати</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-які-рівні-тестування-знаєте>5. Які рівні тестування ви знаєте</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-які-техніки-тест-дизайну-знаєте>6. Які техніки проектування тестів ви знаєте</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-що-таке-техніка-аналізу-класів-еквівалентності>7. Що таке техніка аналізу класів еквівалентності</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-що-таке-техніка-аналізу-межових-значень-в-чому-цінність-цієї-техніки>8. Що таке техніка аналізу межових значень? В чому цінність цієї техніки</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#9-що-таке-regression-і-confirmation-тестування-в-чому-різниця-між-ними>9. Що таке Regression і Confirmation тестування, в чому різниця між ними</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#10-як-часто-варто-проводити-регресійне-тестування-продукту>10. Як часто варто проводити регресійне тестування продукту</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#11-які-існують-види-інтеграційного-тестування>11. Які існують види інтеграційного тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#12-що-таке-configuration-testing>12. Що таке Configuration testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#13-що-таке-exploratory-testing>13. Що таке Exploratory testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#14-які-існують-ui-стандарти>14. Які існують UI-стандарти</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#15-що-таке-blackgreywhite-box-testing>15. Що таке Black/Grey/White Box Testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#16-що-таке-performance-testing>16. Що таке Performance Testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#17-що-таке-smoke-і-sanity-тестування-і-в-чому-різниця-між-ними>17. Що таке Smoke і Sanity тестування і в чому різниця між ними</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#18-що-таке-traceability-matrix>18. Що таке Traceability Matrix</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#19-що-таке-sanity-testing>19. Що таке Sanity Testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#20-що-таке-end-to-end-тест>20. Що таке End-to-End тест</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#21-що-таке-тестування-безпеки>21. Що таке тестування безпеки</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#22-що-таке-тестування-на-основі-ризиків>22. Що таке тестування на основі ризиків</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#23-що-таке-динамічне-тестування>23. Що таке динамічне тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#24-що-таке-парадокс-пестициду>24. Що таке "парадокс пестициду"</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#25-опишіть-основні-фази-stlc-надайте-визначення-entry-і-exit-criteria>25. Опишіть основні фази STLC? Надайте визначення Entry і Exit Criteria</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#26-що-таке-bug-error-failure-fault>26. Що таке Bug, Error, Failure, Fault</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#27-які-є-атрибути-звіту-про-помилку-які-основні-поля-для-заповнення>27. Які є атрибути звіту про помилку? Які основні поля для заповнення</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#28-яка-різниця-між-пріоритетом-і-серйозністю>28. Яка різниця між пріоритетом і серйозністю</a> </li> <li><a href=https://tendil.github.io/tjh-knowledge-base#29-наведіть-приклади-серйозної-але-не-пріоритетної-помилки>29. Наведіть приклади серйозної, але не пріоритетної помилки</a> </li> <li><a href=https://tendil.github.io/tjh-knowledge-base#30-в-чому-різниця-між-валідацією-і-верифікацією>30. В чому різниця між валідацією і верифікацією</a> </li> <li><a href=https://tendil.github.io/tjh-knowledge-base#31-навіщо-потрібна-тестова-документація-і-які-її-види>31. Навіщо потрібна тестова документація і які її види</a> </li> <li><a href=https://tendil.github.io/tjh-knowledge-base#32-що-таке-тест-план-які-елементи-він-має>32. Що таке тест-план? Які елементи він має</a> </li> <li><a href=https://tendil.github.io/tjh-knowledge-base#33-яку-обовязкову-інформацію-має-містити-тест-план>33. Яку обов'язкову інформацію має містити тест-план</a> </li> <li><a href=https://tendil.github.io/tjh-knowledge-base#34-яка-різниця-між-чеклистом-і-тест-кейсами>34. Яка різниця між чеклистом і тест-кейсами</a> </li> <li><a href="https://tendil.github.io/tjh-knowledge-base#35-обов'язки-qa">35. Обязанності QA</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#36-що-знаєте-про-тестування-навантаження-у-якому-випадку-слід-проводити-таке-тестування-на-якому-етапі-готовності-продукту>36. Що знаєте про тестування навантаження? У якому випадку слід проводити таке тестування? На якому етапі готовності продукту</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#37-decision-table-і-як-її-можна-використовувати>37. Decision table і як її можна використовувати</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#38-що-може-бути-критеріями-запуску-і-завершення-тестування>38. Що може бути критеріями запуску і завершення тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#39-приклади-підходів-для-тестування-локалізації>39. Приклади підходів для тестування локалізації</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#40-a-b-тестування>40. A/B тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#41-що-таке-mockstub-які-знаєте-інструменти-для-роботи-з-ними>41. Що таке mock/stub? Які знаєте інструменти для роботи з ними</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#42-коли-потрібно-використовувати-техніку-pairwise>42. Коли потрібно використовувати техніку Pairwise</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#43-fuzz-тестування-і-де-його-використовують>43. Fuzz-тестування і де його використовують</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#44-regexp>44. REgexp</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#45-як-змінюється-вартість-дефекту-під-час-тестування-пз>45. Як змінюється вартість дефекту під час тестування ПЗ</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#46-які-шляхи-аналізу-бізнесу-клієнта-як-визначити-доцільність-того-чи-іншого-функціоналу>46. Які шляхи аналізу бізнесу клієнта? Як визначити доцільність того чи іншого функціоналу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#47-яке-має-бути-відсоткове-співвідношення-між-позитивним-і-негативним-тестуванням-на-проєкті>47. Яке має бути відсоткове співвідношення між позитивним і негативним тестуванням на проєкті</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#48-чи-є-різниця-між-bug-leakage-і-bug-release>48. Чи є різниця між bug leakage і bug release</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#49-що-потрібно-покривати-тест-кейсами-а-що-вважається-надлишковою-витратою-часу-і-грошей-коли-недоцільно-писати-тест-кейси>49. Що потрібно покривати тест-кейсами, а що вважається надлишковою витратою часу і грошей? Коли недоцільно писати тест-кейси</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#50-як-порахувати-cyclomatic-complexity>50. Як порахувати Cyclomatic complexity</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#51-у-чому-основна-різниця-між-defect-detection-percentage-і-defect-removal-efficiency>51. У чому основна різниця між defect detection percentage і defect removal efficiency</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#52-які-моделі-risk-based-testing-ви-знаєте>52. Які моделі risk-based testing ви знаєте</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#53-тестування-api-інструменти>53. Тестування API? Інструменти</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#54-load-stress-та-stability-testing-якими-інструментами-користуються-для-їх-виконання>54. Load, Stress та Stability testing? Якими інструментами користуються для їх виконання</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#55-як-ви-будуватимете-і-впроваджуватимете-стратегію-з-автоматизації-тестування>55. Як ви будуватимете і впроваджуватимете стратегію з автоматизації тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#56-як-обробляти-браузерні-повідомлення-alerts>56. Як обробляти браузерні повідомлення (alerts)</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#57-концепція-дизайну-appium>57. Концепція дизайну Appium</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#58-electron-як-використовувати-selenium-для-тестування-програм-на-його-основ>58. Electron? Як використовувати Selenium для тестування програм на його основ</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#59-що-таке-і-чим-відрізняються-віртуальна-машина-симулятор-та-емулятор>59. Що таке і чим відрізняються віртуальна машина, симулятор та емулятор</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#60-контейнер-і-чим-він-відрізняється-від-віртуальної-машини>60. Контейнер і чим він відрізняється від віртуальної машини</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#61-iaas-та-paas-приклади-використання>61. IaaS та PaaS? Приклади використання</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#62-configuration-management>62. Configuration Management</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#63-ssh-і-як-ним-користуватися>63. SSH і як ним користуватися</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#64-bash-і-batch-скрипти-для-чого-їх-використовують>64. Bash і Batch скрипти? Для чого їх використовують</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#65-різниця-між-авторизацією-та-автентифікацією>65. Різниця між авторизацією та автентифікацією</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#66-чи-може-сервер-відправити-код-400-якщо-проблема-на-його-стороні>66. Чи може сервер відправити код 400, якщо проблема на його стороні</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#67-як-перевірити-обрив-зєднання-websocket>67. Як перевірити обрив з'єднання WebSocket</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#68-основні-види-вразливості-веб-додатків>68. Основні види вразливості веб-додатків</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#69-які-інструменти-для-тестування-web-performance-client-side-знаєте>69. Які інструменти для тестування Web performance client-side знаєте</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#70-cніфери-які-знаєте>70. Cніфери? Які знаєте</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#71-різниця-між-drop-та-truncate>71. Різниця між DROP та TRUNCATE</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#72-функція-case>72. Функція CASE</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#73-що-таке-collation>73. Що таке collation</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#74-що-таке-схема-graphql>74. Що таке схема GraphQL</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#75-різниця-між-oltp-та-olap>75. Різниця між OLTP та OLAP</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#76-типи-реплікації-в-sql-server>76. Типи реплікації в SQL Server?</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#77-self-join>77. Self Join</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#78-що-такое-тестування>78. Що такое тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#79-піраміда-тестування>79. Піраміда тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#80-навіщо-тестувати-пз>80. Навіщо тестувати ПЗ</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#81-етапи-тестування>81. Етапи тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#82-типи-тестування>82. Типи тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#83-рівні-тестування>83. Рівні тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#84-техніки-тест-дизайну>84. Техніки тест-дизайну</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#85-що-таке-regression-та-confirmation-тестування-яка-між-ними-різниця>85. Що таке Regression та Confirmation тестування, яка між ними різниця</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#86-частота-регресійного-тестування>86. Частота регресійного тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#87-види-інтеграційного-тестування>87. Види інтеграційного тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#88-configuration-testing>88. Configuration Testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#89-exploratory-testing>89. Exploratory Testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#90-performance-testing>90. Performance Testing</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#91-traceability-matrix>91. Traceability Matrix</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#92-end-to-end-тест>92. End-to-End тест</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#93-тестування-безпеки>93. Тестування безпеки</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#94-випробування-на-основі-ризиків>94. Випробування на основі ризиків</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#95-динамічне-тестування>95. Динамічне тестування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#96-основні-фази-stlc-дайте-визначення-entry-та-exit-criteria>96. Основні фази STLC? Дайте визначення Entry та Exit Criteria</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#97-атрибути-баг-репорту-які-основні-поля-для-заповнення>97. Атрибути баг-репорту? Які основні поля для заповнення</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#98-різниця-між-пріоритетом-і-серйозністю>98. Різниця між пріоритетом і серйозністю</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#99-наведіть-приклади-серйозного-але-не-пріоритетного-бага>99. Наведіть приклади серйозного, але не пріоритетного бага</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#100-навіщо-потрібна-тестова-документація-які-її-види>100. Навіщо потрібна тестова документація? Які її види</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#101-тест-план-які-елементи-має>101. Тест-план? Які елементи має</a></li> </ul> <h2 id=11>11. Бази данних<a class=headerlink href=#11 title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-які-бувають-види-бд>1. Які бувають види БД</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2->2. </a></li> </ul> <h2 id=12>12. Загальні питання<a class=headerlink href=#12 title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#загальні-питання>до змісту ⬆️</a></p> <ul> <li><a href=https://tendil.github.io/tjh-knowledge-base#1-які-знаєте-web-elements>1. Які знаєте Web elements</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#2-для-чого-необхідні-інструменти-розробника-в-браузері-chrome-devtools-і-як-вони-допомагають-у-тестуванні>2. Для чого необхідні інструменти розробника в браузері (Chrome DevTools) і як вони допомагають у тестуванні</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#3-що-таке-кеш>3. Що таке кеш</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#4-що-таке-сесія>4. Що таке сесія</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#5-навіщо-потрібні-cookies>5. Навіщо потрібні cookies</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#6-iframe-і-як-з-ним-працювати-в-selenium>6. iFrame і як з ним працювати в Selenium</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#7-що-таке-html-css-javascript>7. Що таке HTML/CSS/JavaScript</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#8-яку-структуру-має-веб-сторінка>8. Яку структуру має веб-сторінка</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#9-навіщо-чистити-кеш>9. Навіщо чистити кеш</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#10-що-таке-ajax>10. Що таке AJAX</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#11-що-таке-adb>11. Що таке ADB</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#12-які-є-http-методи>12. Які є HTTP-методи</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#13-розшифрування-grud>13. Розшифрування CRUD</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#14-як-відбувається-шифрування>14. Як відбувається шифрування</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#15-які-способи-взаємодії-з-api-існують-у-чому-різниця-між-ними>15. Які способи взаємодії з API існують? У чому різниця між ними</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#16-як-можна-протестувати-api-що-там-потрібно-перевіряти>16. Як можна протестувати API, що там потрібно перевіряти</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#17-формати-передачі-даних>17. Формати передачі даних</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#18-відмінності-між-xml-та-json>18. Відмінності між XML та JSON</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#19-клієнт-серверна-архітектура>19. Клієнт-серверна архітектура</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#20-для-чого-потрібні-testng-junit>20. Для чого потрібні TestNG, JUnit</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#21-які-інструкції-використовуються-в-testng-junit>21. Які інструкції використовуються в TestNG, JUnit</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#22-які-assertions-є-в-testng-junit>22. Які assertions є в TestNG, JUnit</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#23-як-виконувати-тести-паралельно-testng-junit>23. Як виконувати тести паралельно TestNG, JUnit</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#24-2-способи-що-дозволяють-автоматизувати-капчу>24. 2 способи, що дозволяють автоматизувати капчу</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#25-що-таке-selenium-grid>25. Що таке Selenium Grid</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#26-драйвер-браузера>26. Драйвер браузера</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#27-які-види-локаторів-сторінки-існують-які-їх-переваги-та-недоліки>27. Які види локаторів сторінки існують? Які їх переваги та недоліки</a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#>28. </a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#>29. </a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#>30. </a></li> <li><a href=https://tendil.github.io/tjh-knowledge-base#>31. </a></li> </ul> <hr> <h1 id=-git>Відповіді - 'GIT'<a class=headerlink href=#-git title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1-git>1. Що таке Git<a class=headerlink href=#1-git title="Permanent link">&para;</a></h3> <p>Розподілена система управління версіями. Розроблено Лінусом Торвальдсом, для зручної розробки ядра Linux.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2-git_1>2. Як створити локальний Git репозиторій<a class=headerlink href=#2-git_1 title="Permanent link">&para;</a></h3> <div class="language-text highlight"><pre><span></span><code><span id=__span-0-1><a id=__codelineno-0-1 name=__codelineno-0-1 href=#__codelineno-0-1></a>git init
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3-git-push>3. Що таке git push<a class=headerlink href=#3-git-push title="Permanent link">&para;</a></h3> <p>Надсилання всіх невідправлених локальних комітів на віддалений сервер репозиторію.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4-git-commit>4. Що робить git commit<a class=headerlink href=#4-git-commit title="Permanent link">&para;</a></h3> <p>Фіксує зміни локальних файлів у таймлайні репозиторію. Інакше кажучи, робить "моментальний знімок" репозиторію в даний момент часу, який і є версією.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5-git-merge-rebase>5. Git merge та rebase<a class=headerlink href=#5-git-merge-rebase title="Permanent link">&para;</a></h3> <p><code>git merge</code> - приймає вміст гілки джерела та об'єднує їх із цільовою гілкою. У цьому процесі змінюється тільки цільова гілка. Історія вихідних гілок залишається незмінною.<br> <code>git rebase</code> - ще один спосіб перенести зміни з однієї гілки в іншу. <code>Rebase</code> стискає всі зміни в один "патч".<br> Потім він інтегрує патч у цільову гілку.На відміну від злиття, переміщення перезаписує історію, тому що вона передає завершену роботу з однієї гілки в іншу.У процесі усувається небажана історія.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=6>6. Для чого використовують системи контролю версій<a class=headerlink href=#6 title="Permanent link">&para;</a></h3> <p><em>Система контролю версій (Version Control System/VCS)</em> - дозволяє зберігати кілька версій одного і того ж документа, при необхідності повертатися до більш ранніх версій, визначати, хто і коли зробив ту чи іншу зміну, та багато іншого. VCS дозволяє змінювати одні й самі файли декільком розробникам одночасно. При цьому всі варіанти змін зберігаються окремо, і можна зробити різні варіанти того самого файлу з урахуванням різних правок від різних людей. Якщо ж кілька змін зачіпають той самий фрагмент документа, то система запропонує вибрати потрібний варіант.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=7-git-github>7. Що таке Git і GitHub<a class=headerlink href=#7-git-github title="Permanent link">&para;</a></h3> <p>Git — це безкоштовна розподілена система керування версіями з відкритим вихідним кодом, розроблена для швидкої та ефективної обробки проектів будь-якого розміру.</p> <p>GitHub використовує Git для надання Інтернет-хостингу для контролю версій і розробки програмного забезпечення. Він пропонує функції розподіленого контролю версій і керування вихідним кодом, які є в Git, на додаток до інших унікальних функцій.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=8-git-github>8. Яка різниця між Git і GitHub?<a class=headerlink href=#8-git-github title="Permanent link">&para;</a></h3> <p>Git — це система контролю версій, яка використовується для керування історією вихідного коду.<br> З іншого боку, GitHub — це хмарна служба хостингу, яка використовується для керування сховищами Git. <br> GitHub призначений для кращого керування проектами з відкритим кодом.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=9-git-svn>9. Які основні відмінності між Git і SVN?<a class=headerlink href=#9-git-svn title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>Критерії</th> <th>GIT</th> <th>SVN</th> </tr> </thead> <tbody> <tr> <td>Тип контролю версій</td> <td>Розповсюджується</td> <td>Централізована</td> </tr> <tr> <td>Доступ до мереж</td> <td>Не обов'язковий</td> <td>Обов'язковий</td> </tr> <tr> <td>Глобальний номер версії</td> <td>Недоступний</td> <td>В наявності</td> </tr> <tr> <td>Зміст</td> <td>Криптографічний хеш SHA-1</td> <td>Немає хешованого вмісту</td> </tr> </tbody> </table> <p>Тут ми перелічимо деякі з найважливіших відмінностей між Git і SVN:</p> <ul> <li>Коли мова йде про обробку великих файлів, Git не є кращим, але SVN може обробляти кілька проектів в одному сховищі</li> <li>Git не має «комітів» для кількох гілок, але SVN дозволяє створювати папки в будь-якому місці макета сховища</li> <li>Ви не можете внести зміни в Git, але SVN дозволяє створити тег як гілку, і ви можете створити кілька версій під кореневим тегом</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=10-git>10. Які переваги використання GIT?<a class=headerlink href=#10-git title="Permanent link">&para;</a></h3> <p>Ось деякі з найважливіших переваг Git:</p> <ul> <li>Можливе резервування даних і реплікація даних</li> <li>Це дуже доступна послуга</li> <li>Для одного репозиторію ми можемо мати лише один каталог Git</li> <li>Продуктивність мережі та використання диска чудові</li> <li>Дуже легко співпрацювати над будь-яким проектом</li> <li>Ми можемо працювати над будь-яким проектом у Git</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=11-git>11. Яка мова використовується в GIT<a class=headerlink href=#11-git title="Permanent link">&para;</a></h3> <p>C — це мова програмування, яка використовується для створення Git, що гарантує зменшення накладних витрат.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=12-git-bash>12. Що таке Git Bash<a class=headerlink href=#12-git-bash title="Permanent link">&para;</a></h3> <p>Git Bash — це програма, яка встановлює Bash, Git і кілька утиліт Bash, які зазвичай використовуються в ОС Windows.<br> У Git Bash можлива взаємодія з елементами Git і репозиторієм за допомогою різних команд.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=13-git-staging-area>13. Що означає «Індекс» або «Посадкова область» у git (Staging Area)<a class=headerlink href=#13-git-staging-area title="Permanent link">&para;</a></h3> <p>Коли ми робимо коміти, ми можемо вносити до нього зміни, форматувати та переглядати його в проміжній області, відомій як «Постанова області» або «Індекс».</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=14-git-tagging>14. Що таке тегування в Git (tagging)<a class=headerlink href=#14-git-tagging title="Permanent link">&para;</a></h3> <p>Додавання тегів дозволяє розробникам позначати всі важливі контрольні точки в ході виконання своїх проектів.<br> Замість ідентифікаторів комітів можна використовувати назви тегів, коли коміти перевіряються та надсилаються до віддаленого репо.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=15-forking-git>15. Що таке forking в Git<a class=headerlink href=#15-forking-git title="Permanent link">&para;</a></h3> <p>Копія сховища називається форком.<br> Отже, розгалуження дозволяє експериментувати зі змінами, не турбуючись про оригінальний проект.<br> Цей процес ідеально підходить для пропозиції змін до чиїхось проектів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=16-git-clone>16. Для чого корисний Git clone<a class=headerlink href=#16-git-clone title="Permanent link">&para;</a></h3> <p>Команда <code>git clone</code> дозволяє скопіювати існуючий репозиторій Git. Якщо ми хочемо отримати копію центрального репозиторію, то найкращий спосіб зробити це — використовувати «клонування»</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=17-git>17. Який процес створення репозиторію в Git<a class=headerlink href=#17-git title="Permanent link">&para;</a></h3> <p>Якщо ми хочемо створити репозиторій у Git, то нам потрібно виконати команду <code>git init</code>.<br> За допомогою цієї команди .git repository ми можемо створити каталог у каталозі проекту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=18-cherry-pick-git>18. Що таке cherry-pick у Git<a class=headerlink href=#18-cherry-pick-git title="Permanent link">&para;</a></h3> <p>Git cherry-pick — це команда, яка дозволяє вибирати довільні коміти Git за посиланням і додавати їх до HEAD.<br> Cherry-picking — це процес вибору коміту з однієї гілки та застосування його до іншої.<br> Це допомагає скасувати зміни.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=19-origin-git>19. Що таке origin у Git<a class=headerlink href=#19-origin-git title="Permanent link">&para;</a></h3> <p>Походження відноситься до віддаленого сховища, з якого спочатку було клоновано проект, і використовується замість URL-адреси оригінального сховища.<br> Це полегшує посилання.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=20-git-pull>20. Що таке команда git pull<a class=headerlink href=#20-git-pull title="Permanent link">&para;</a></h3> <p>Команда <code>git pull</code> призначена для отримання та завантаження вмісту з віддаленого сховища та інтеграції його з локальним сховищем.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=21-git-fetch-git-pull>21. Яка різниця між git fetch і git pull<a class=headerlink href=#21-git-fetch-git-pull title="Permanent link">&para;</a></h3> <p>Git fetch отримує нові дані з віддаленого сховища, але не інтегрує їх у наші робочі файли. Це допомагає перевірити, чи відбулися будь-які зміни у віддаленому сховищі.<br> Він не маніпулює та не руйнує нічого в процесі.</p> <p><code>git pull</code>, з іншого боку, оновлює HEAD останніми змінами з віддаленого сервера та безпосередньо інтегрує його у файли робочої копії.<br> Використання <code>git pull</code> може призвести до конфлікту злиття, оскільки він намагається об’єднати віддалені зміни з локальними.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=22-git-checkout-git>22. Поясніть git checkout у Git<a class=headerlink href=#22-git-checkout-git title="Permanent link">&para;</a></h3> <p><code>git checkout</code> дозволяє перемикати HEAD.<br> Його також можна використовувати для відновлення історичних версій файлів. Команда працює з файлами, комітами та гілками.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=23-git-rebase>23. Що робить git rebase<a class=headerlink href=#23-git-rebase title="Permanent link">&para;</a></h3> <p>Перебазування — це повторне застосування комітів поверх іншого базового відключення.<br> Послідовність комітів застосовується з різних гілок до остаточного коміту. Це лінійний процес злиття та альтернатива команді git merge.<br> Перебазування створює враження, ніби хтось створив гілку з іншого коміту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=24-git-rebase-git-merge>24. Яка різниця між git rebase і git merge<a class=headerlink href=#24-git-rebase-git-merge title="Permanent link">&para;</a></h3> <p>У <code>git rebase</code> гілку функції переміщується в головну.<br> <code>git merge</code> підтримує історію шляхом додавання нового коміту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=25-git-revert>25. Що таке git revert<a class=headerlink href=#25-git-revert title="Permanent link">&para;</a></h3> <p>Команда <code>git revert</code> — це операція скасування вперед.<br> Це безпечний спосіб скасувати зміни, оскільки він створить новий комміт, який інвертує зміни замість видалення чи втрати комітів в історії комітів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=26-between-resetting-and-reverting>26. Яка різниця між between resetting and reverting<a class=headerlink href=#26-between-resetting-and-reverting title="Permanent link">&para;</a></h3> <p>У той час як git reset змінює стан гілки на попередній, видаляючи всі стани після потрібного коміту, git revert робить це шляхом створення нових повертаючих комітів і збереження початкового.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=27-git-remote-git-clone>27. Яка різниця між «git remote» і «git clone»<a class=headerlink href=#27-git-remote-git-clone title="Permanent link">&para;</a></h3> <p>Git remote додає посилання на віддалене сховище для подальшого відстеження.<br> Git clone, як і його назва, клонує існуюче віддалене сховище та створює нове.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=28-git-stash>28. Що таке GIT stash<a class=headerlink href=#28-git-stash title="Permanent link">&para;</a></h3> <p>Схованка Git візьме робочий каталог у поточному стані та проіндексує його, щоб помістити в стек на пізнішому етапі, щоб отримати чистий робочий каталог.</p> <p><img alt=IMG src=images/GitStash.png></p> <p>Це означає, що якщо ми перебуваємо в середині якогось завдання і нам потрібно отримати чистий робочий каталог і водночас ми хочемо зберегти всі наші поточні редагування, тоді ми можемо використати схованку Git.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=29-fork-branch-clone>29. Чим fork, branch, и clone відрізняються один від одного<a class=headerlink href=#29-fork-branch-clone title="Permanent link">&para;</a></h3> <p>Розгалуження створює копію вихідного репозиторію, яка залишається в обліковому записі GitHub.<br> Тоді як під час клонування репозиторій копіюється на локальну машину за допомогою Git.<br> Розгалуження використовується для пропозиції змін власникам сховища.<br> Під час клонування зміни надсилаються безпосередньо до оригінального сховища, якщо користувач має доступ для запису.<br> Розгалуження виникають у сховищі та є способом продовжувати розробку та модифікацію програмного забезпечення, не впливаючи на основний проект.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=30-git-reflog-log>30. Яка різниця між git reflog і log<a class=headerlink href=#30-git-reflog-log title="Permanent link">&para;</a></h3> <p>Журнал git — це загальнодоступний запис історії комітів для гілки. З іншого боку, Reflog є приватним локальним комітом сховища.</p> <p>На відміну від reflog, журнал git є частиною сховища Git і реплікується після push, fetch або pull.<br> Розробник не може отримати доступ до reflog локального сховища, не маючи доступу до комп’ютера, на якому він розташований.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=31-git-stash-drop>31. Що таке GIT stash drop<a class=headerlink href=#31-git-stash-drop title="Permanent link">&para;</a></h3> <p>Коли ми закінчимо роботу над схованим елементом або захочемо видалити список, ми можемо використати схованку Git.<br> Це гарантує, що останній доданий елемент за замовчуванням або будь-який окремий елемент можна видалити з аргументу.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=32>32. Як визначити, чи певну гілку було об’єднано в головну<a class=headerlink href=#32 title="Permanent link">&para;</a></h3> <p><code>git branch –merged master</code> – показує всі гілки, які об’єднано в головний</p> <p><code>git branch –merged</code> – показує всі гілки, які об’єднані в голову</p> <p><code>git branch –no-merged</code> – показує всі гілки, які не об’єднані</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=33-git>33. Для чого нам потрібні розгалуження в GIT<a class=headerlink href=#33-git title="Permanent link">&para;</a></h3> <p>За допомогою розгалуження ми можемо мати власну гілку, а також можемо переходити між різними гілками.<br> Ми можемо перейти до нашої попередньої роботи, в той же час зберігши свою недавню роботу.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=34>34. Що містять складові об’єкта коміту<a class=headerlink href=#34 title="Permanent link">&para;</a></h3> <ul> <li>Cтан проекту в даний момент часу міститься в наборі файлів</li> <li>Посилання на фіксацію батьківського об’єкта</li> <li>Рядок із 40 символів, який однозначно ідентифікує об’єкт коміту під назвою SHAI</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=35-head-git-head>35. Що таке HEAD у Git і скільки HEAD можна створити в репозиторії<a class=headerlink href=#35-head-git-head title="Permanent link">&para;</a></h3> <ul> <li>Посилання на об'єкт коміту називається HEAD. </li> <li>Кожен репозиторій має «Головний», який є головним за замовчуванням. </li> <li>У сховищі може бути кілька голів.</li> </ul> <p><img alt=IMG src=images/GitHead.png> <img alt=IMG src=images/GitBranching.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=36-git>36. Який звичайний спосіб розгалуження в GIT<a class=headerlink href=#36-git title="Permanent link">&para;</a></h3> <p>Найкращий спосіб створити гілку в GIT — мати одну «головну» гілку, а потім створити іншу гілку для впровадження змін, які ми хочемо внести.<br> Це надзвичайно корисно, коли над одним проектом працює велика кількість розробників.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=37-git>37. Як ви визначаєте «конфлікт» у Git<a class=headerlink href=#37-git title="Permanent link">&para;</a></h3> <p>Якщо ми хочемо об’єднати коміт, є зміна в одному місці, і така сама зміна вже існує, тоді під час об’єднання Git не зможе передбачити, яка саме зміна має бути пріоритетною.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=38-git>38. Як вирішити конфлікт у Git<a class=headerlink href=#38-git title="Permanent link">&para;</a></h3> <p>Якщо ми хочемо вирішити конфлікт у Git, тоді нам потрібно відредагувати файли для виправлення суперечливих змін, а потім ми можемо запустити «git add», щоб додати вирішені файли, а після цього ми можемо запустити «git commit» для фіксації відремонтоване злиття.</p> <hr> <h1 id=-javascript>Відповіді - 'JavaScript'<a class=headerlink href=#-javascript title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1-javascript>1. Які існують способи створення обєктів у JavaScript<a class=headerlink href=#1-javascript title="Permanent link">&para;</a></h3> <p>Існує багато способів створення об'єктів у javascript, як показано нижче</p> <ol> <li> <p><strong>Конструктор об'єктів:</strong></p> <p>Найпростіший спосіб створення порожнього об'єкта - використання конструктора об'єктів. Наразі такий підхід не рекомендується.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-1-1><a id=__codelineno-1-1 name=__codelineno-1-1 href=#__codelineno-1-1></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nb>Object</span><span class=p>();</span>
</span></code></pre></div> </li> <li> <p><strong>Метод створення об'єкту Object:</strong></p> <p>Метод create об'єкту Object створює новий об'єкт, передаючи в якості параметру об'єкт-прототип</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-2-1><a id=__codelineno-2-1 name=__codelineno-2-1 href=#__codelineno-2-1></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Object</span><span class=p>.</span><span class=nx>create</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span>
</span></code></pre></div> </li> <li> <p><strong>Синтаксис літералів об'єктів:</strong></p> <p>Синтаксис літералів об'єкта (або ініціалізатор об'єкта) - це відокремлений комами набір пар ім'я-значення, обгорнутий фігурними дужками.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-3-1><a id=__codelineno-3-1 name=__codelineno-3-1 href=#__codelineno-3-1></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-3-2><a id=__codelineno-3-2 name=__codelineno-3-2 href=#__codelineno-3-2></a><span class=w>     </span><span class=nx>name</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Sudheer&quot;</span><span class=p>,</span>
</span><span id=__span-3-3><a id=__codelineno-3-3 name=__codelineno-3-3 href=#__codelineno-3-3></a><span class=w>     </span><span class=nx>age</span><span class=o>:</span><span class=w> </span><span class=mf>34</span>
</span><span id=__span-3-4><a id=__codelineno-3-4 name=__codelineno-3-4 href=#__codelineno-3-4></a><span class=p>};</span>
</span><span id=__span-3-5><a id=__codelineno-3-5 name=__codelineno-3-5 href=#__codelineno-3-5></a>
</span><span id=__span-3-6><a id=__codelineno-3-6 name=__codelineno-3-6 href=#__codelineno-3-6></a><span class=nx>Значення</span><span class=w> </span><span class=nx>властивостей</span><span class=w> </span><span class=nx>об</span><span class=s1>&#39;єктних літералів можуть бути будь-якого типу даних, включаючи масив, функцію та вкладений об&#39;</span><span class=nx>єкт</span><span class=p>.</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Це найпростіший спосіб створення об'єкта</p> </li> <li> <p><strong>Конструктор функцій:</strong></p> <p>Створіть будь-яку функцію і застосуйте оператор new для створення екземплярів об'єктів,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-4-1><a id=__codelineno-4-1 name=__codelineno-4-1 href=#__codelineno-4-1></a><span class=kd>function</span><span class=w> </span><span class=nx>Person</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-4-2><a id=__codelineno-4-2 name=__codelineno-4-2 href=#__codelineno-4-2></a><span class=w>  </span><span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>name</span><span class=p>;</span>
</span><span id=__span-4-3><a id=__codelineno-4-3 name=__codelineno-4-3 href=#__codelineno-4-3></a><span class=w>  </span><span class=k>this</span><span class=p>.</span><span class=nx>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>21</span><span class=p>;</span>
</span><span id=__span-4-4><a id=__codelineno-4-4 name=__codelineno-4-4 href=#__codelineno-4-4></a><span class=p>}</span>
</span><span id=__span-4-5><a id=__codelineno-4-5 name=__codelineno-4-5 href=#__codelineno-4-5></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Person</span><span class=p>(</span><span class=s2>&quot;Sudheer&quot;</span><span class=p>);</span>
</span></code></pre></div> </li> <li> <p><strong>Конструктор функції з прототипом:</strong></p> <p>Подібно до конструктора функцій, але використовує прототип для їх властивостей та методів,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-5-1><a id=__codelineno-5-1 name=__codelineno-5-1 href=#__codelineno-5-1></a><span class=kd>function</span><span class=w> </span><span class=nx>Person</span><span class=p>()</span><span class=w> </span><span class=p>{}</span>
</span><span id=__span-5-2><a id=__codelineno-5-2 name=__codelineno-5-2 href=#__codelineno-5-2></a><span class=nx>Person</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;Sudheer&quot;</span><span class=p>;</span>
</span><span id=__span-5-3><a id=__codelineno-5-3 name=__codelineno-5-3 href=#__codelineno-5-3></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Person</span><span class=p>();</span>
</span></code></pre></div> <p>Це еквівалентно створенню екземпляра за допомогою методу створення об'єкта з прототипом функції, а потім виклику цієї функції з екземпляром і параметрами в якості аргументів.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-6-1><a id=__codelineno-6-1 name=__codelineno-6-1 href=#__codelineno-6-1></a><span class=kd>function</span><span class=w> </span><span class=nx>func</span><span class=p>()</span><span class=w> </span><span class=p>{};</span>
</span><span id=__span-6-2><a id=__codelineno-6-2 name=__codelineno-6-2 href=#__codelineno-6-2></a>
</span><span id=__span-6-3><a id=__codelineno-6-3 name=__codelineno-6-3 href=#__codelineno-6-3></a><span class=ow>new</span><span class=w> </span><span class=nx>func</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span><span class=w> </span><span class=nx>y</span><span class=p>,</span><span class=w> </span><span class=nx>z</span><span class=p>);</span>
</span></code></pre></div> <p><strong>(АБО)</strong></p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-7-1><a id=__codelineno-7-1 name=__codelineno-7-1 href=#__codelineno-7-1></a><span class=c1>// Створити новий екземпляр з використанням прототипу функції.</span>
</span><span id=__span-7-2><a id=__codelineno-7-2 name=__codelineno-7-2 href=#__codelineno-7-2></a><span class=kd>var</span><span class=w> </span><span class=nx>newInstance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Object</span><span class=p>.</span><span class=nx>create</span><span class=p>(</span><span class=nx>func</span><span class=p>.</span><span class=nx>prototype</span><span class=p>)</span>
</span><span id=__span-7-3><a id=__codelineno-7-3 name=__codelineno-7-3 href=#__codelineno-7-3></a>
</span><span id=__span-7-4><a id=__codelineno-7-4 name=__codelineno-7-4 href=#__codelineno-7-4></a><span class=c1>// Викликати функцію</span>
</span><span id=__span-7-5><a id=__codelineno-7-5 name=__codelineno-7-5 href=#__codelineno-7-5></a><span class=kd>var</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>func</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>newInstance</span><span class=p>,</span><span class=w> </span><span class=nx>x</span><span class=p>,</span><span class=w> </span><span class=nx>y</span><span class=p>,</span><span class=w> </span><span class=nx>z</span><span class=p>),</span>
</span><span id=__span-7-6><a id=__codelineno-7-6 name=__codelineno-7-6 href=#__codelineno-7-6></a>
</span><span id=__span-7-7><a id=__codelineno-7-7 name=__codelineno-7-7 href=#__codelineno-7-7></a><span class=c1>// Якщо результат є ненульовим об&#39;єктом, використовуйте його, інакше просто використовуйте новий екземпляр.</span>
</span><span id=__span-7-8><a id=__codelineno-7-8 name=__codelineno-7-8 href=#__codelineno-7-8></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=ow>typeof</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;object&#39;</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=nx>newInstance</span><span class=p>);</span>
</span></code></pre></div> </li> <li> <p><strong>Синтаксис класів у ES6:</strong> *Синтаксис класів у ES6</p> <p>У ES6 введено клас для створення об'єктів</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-8-1><a id=__codelineno-8-1 name=__codelineno-8-1 href=#__codelineno-8-1></a><span class=kd>class</span><span class=w> </span><span class=nx>Person</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-8-2><a id=__codelineno-8-2 name=__codelineno-8-2 href=#__codelineno-8-2></a><span class=w>  </span><span class=kr>constructor</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-8-3><a id=__codelineno-8-3 name=__codelineno-8-3 href=#__codelineno-8-3></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>name</span><span class=p>;</span>
</span><span id=__span-8-4><a id=__codelineno-8-4 name=__codelineno-8-4 href=#__codelineno-8-4></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-8-5><a id=__codelineno-8-5 name=__codelineno-8-5 href=#__codelineno-8-5></a><span class=p>}</span>
</span><span id=__span-8-6><a id=__codelineno-8-6 name=__codelineno-8-6 href=#__codelineno-8-6></a>
</span><span id=__span-8-7><a id=__codelineno-8-7 name=__codelineno-8-7 href=#__codelineno-8-7></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Person</span><span class=p>(</span><span class=s2>&quot;Sudheer&quot;</span><span class=p>);</span>
</span></code></pre></div> </li> <li> <p><strong>Шаблон синглетону:</strong></p> <p>Синглтон - це об'єкт, який може бути створений лише один раз. Повторні виклики його конструктора повертають той самий екземпляр, і таким чином можна гарантувати, що випадково не буде створено декілька екземплярів.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-9-1><a id=__codelineno-9-1 name=__codelineno-9-1 href=#__codelineno-9-1></a><span class=kd>var</span><span class=w> </span><span class=nx>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-9-2><a id=__codelineno-9-2 name=__codelineno-9-2 href=#__codelineno-9-2></a><span class=w>  </span><span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;Sudheer&quot;</span><span class=p>;</span>
</span><span id=__span-9-3><a id=__codelineno-9-3 name=__codelineno-9-3 href=#__codelineno-9-3></a><span class=p>})();</span>
</span></code></pre></div> </li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2>2. Що таке ланцюг прототипів<a class=headerlink href=#2 title="Permanent link">&para;</a></h3> <p><strong>Ланцюжок прототипів</strong> використовується для створення нових типів об'єктів на основі існуючих. Це схоже на успадкування у мовах, заснованих на класах.</p> <p>Прототип на екземплярі об'єкта доступний через <strong>Object.getPrototypeOf(object)</strong> або властивість <strong>__proto__</strong>, тоді як прототип на функції конструктора доступний через <strong>Object.prototype</strong>.</p> <p><img alt=Скріншот src=images/prototype_chain.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3-call-apply-bind>3. В чому різниця між методами Call, Apply та Bind<a class=headerlink href=#3-call-apply-bind title="Permanent link">&para;</a></h3> <p>Різницю між методами Call, Apply та Bind можна пояснити за допомогою наступних прикладів,</p> <p><strong>Виклик:</strong> Метод call() викликає функцію із заданим значенням <code>this</code> і аргументами, що надаються один за одним</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-10-1><a id=__codelineno-10-1 name=__codelineno-10-1 href=#__codelineno-10-1></a><span class=kd>var</span><span class=w> </span><span class=nx>employee1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>firstName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;John&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>lastName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Rodson&quot;</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-10-2><a id=__codelineno-10-2 name=__codelineno-10-2 href=#__codelineno-10-2></a><span class=kd>var</span><span class=w> </span><span class=nx>employee2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>firstName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Jimmy&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>lastName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Baily&quot;</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-10-3><a id=__codelineno-10-3 name=__codelineno-10-3 href=#__codelineno-10-3></a>
</span><span id=__span-10-4><a id=__codelineno-10-4 name=__codelineno-10-4 href=#__codelineno-10-4></a><span class=kd>function</span><span class=w> </span><span class=nx>invite</span><span class=p>(</span><span class=nx>greeting1</span><span class=p>,</span><span class=w> </span><span class=nx>greeting2</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-10-5><a id=__codelineno-10-5 name=__codelineno-10-5 href=#__codelineno-10-5></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span>
</span><span id=__span-10-6><a id=__codelineno-10-6 name=__codelineno-10-6 href=#__codelineno-10-6></a><span class=w>    </span><span class=nx>greeting1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>firstName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>lastName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot;, &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>greeting2</span>
</span><span id=__span-10-7><a id=__codelineno-10-7 name=__codelineno-10-7 href=#__codelineno-10-7></a><span class=w>  </span><span class=p>);</span>
</span><span id=__span-10-8><a id=__codelineno-10-8 name=__codelineno-10-8 href=#__codelineno-10-8></a><span class=p>}</span>
</span><span id=__span-10-9><a id=__codelineno-10-9 name=__codelineno-10-9 href=#__codelineno-10-9></a>
</span><span id=__span-10-10><a id=__codelineno-10-10 name=__codelineno-10-10 href=#__codelineno-10-10></a><span class=nx>invite</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>employee1</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;Hello&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;How are you?&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>// Привіт Джон Родсон, як справи?</span>
</span><span id=__span-10-11><a id=__codelineno-10-11 name=__codelineno-10-11 href=#__codelineno-10-11></a><span class=nx>invite</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>employee2</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;Hello&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;How are you?&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>// Привіт Джиммі Бейлі, як справи?</span>
</span></code></pre></div> <p><strong>Apply:</strong> Викликає функцію з заданим значенням <code>this</code> і дозволяє передавати аргументи у вигляді масиву</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-11-1><a id=__codelineno-11-1 name=__codelineno-11-1 href=#__codelineno-11-1></a><span class=kd>var</span><span class=w> </span><span class=nx>employee1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>firstName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;John&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>lastName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Rodson&quot;</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-11-2><a id=__codelineno-11-2 name=__codelineno-11-2 href=#__codelineno-11-2></a><span class=kd>var</span><span class=w> </span><span class=nx>employee2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>firstName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Jimmy&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>lastName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Baily&quot;</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-11-3><a id=__codelineno-11-3 name=__codelineno-11-3 href=#__codelineno-11-3></a>
</span><span id=__span-11-4><a id=__codelineno-11-4 name=__codelineno-11-4 href=#__codelineno-11-4></a><span class=kd>function</span><span class=w> </span><span class=nx>invite</span><span class=p>(</span><span class=nx>greeting1</span><span class=p>,</span><span class=w> </span><span class=nx>greeting2</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-11-5><a id=__codelineno-11-5 name=__codelineno-11-5 href=#__codelineno-11-5></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span>
</span><span id=__span-11-6><a id=__codelineno-11-6 name=__codelineno-11-6 href=#__codelineno-11-6></a><span class=w>    </span><span class=nx>greeting1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>firstName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>lastName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot;, &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>greeting2</span>
</span><span id=__span-11-7><a id=__codelineno-11-7 name=__codelineno-11-7 href=#__codelineno-11-7></a><span class=w>  </span><span class=p>);</span>
</span><span id=__span-11-8><a id=__codelineno-11-8 name=__codelineno-11-8 href=#__codelineno-11-8></a><span class=p>}</span>
</span><span id=__span-11-9><a id=__codelineno-11-9 name=__codelineno-11-9 href=#__codelineno-11-9></a>
</span><span id=__span-11-10><a id=__codelineno-11-10 name=__codelineno-11-10 href=#__codelineno-11-10></a><span class=nx>invite</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=nx>employee1</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=s2>&quot;Hello&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;How are you?&quot;</span><span class=p>]);</span><span class=w> </span><span class=c1>// Привіт Джон Родсон, як справи?</span>
</span><span id=__span-11-11><a id=__codelineno-11-11 name=__codelineno-11-11 href=#__codelineno-11-11></a><span class=nx>invite</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=nx>employee2</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=s2>&quot;Hello&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;How are you?&quot;</span><span class=p>]);</span><span class=w> </span><span class=c1>// Привіт Джиммі Бейлі, як справи?</span>
</span></code></pre></div> <p><strong>bind:</strong> повертає нову функцію, що дозволяє передавати будь-яку кількість аргументів</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-12-1><a id=__codelineno-12-1 name=__codelineno-12-1 href=#__codelineno-12-1></a><span class=kd>var</span><span class=w> </span><span class=nx>employee1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>firstName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;John&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>lastName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Rodson&quot;</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-12-2><a id=__codelineno-12-2 name=__codelineno-12-2 href=#__codelineno-12-2></a><span class=kd>var</span><span class=w> </span><span class=nx>employee2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>firstName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Jimmy&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>lastName</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;Baily&quot;</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-12-3><a id=__codelineno-12-3 name=__codelineno-12-3 href=#__codelineno-12-3></a>
</span><span id=__span-12-4><a id=__codelineno-12-4 name=__codelineno-12-4 href=#__codelineno-12-4></a><span class=kd>function</span><span class=w> </span><span class=nx>invite</span><span class=p>(</span><span class=nx>greeting1</span><span class=p>,</span><span class=w> </span><span class=nx>greeting2</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-12-5><a id=__codelineno-12-5 name=__codelineno-12-5 href=#__codelineno-12-5></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span>
</span><span id=__span-12-6><a id=__codelineno-12-6 name=__codelineno-12-6 href=#__codelineno-12-6></a><span class=w>    </span><span class=nx>greeting1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>firstName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>lastName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot;, &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>greeting2</span>
</span><span id=__span-12-7><a id=__codelineno-12-7 name=__codelineno-12-7 href=#__codelineno-12-7></a><span class=w>  </span><span class=p>);</span>
</span><span id=__span-12-8><a id=__codelineno-12-8 name=__codelineno-12-8 href=#__codelineno-12-8></a><span class=p>}</span>
</span><span id=__span-12-9><a id=__codelineno-12-9 name=__codelineno-12-9 href=#__codelineno-12-9></a>
</span><span id=__span-12-10><a id=__codelineno-12-10 name=__codelineno-12-10 href=#__codelineno-12-10></a><span class=kd>var</span><span class=w> </span><span class=nx>inviteEmployee1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>invite</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>employee1</span><span class=p>);</span>
</span><span id=__span-12-11><a id=__codelineno-12-11 name=__codelineno-12-11 href=#__codelineno-12-11></a><span class=kd>var</span><span class=w> </span><span class=nx>inviteEmployee2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>invite</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>employee2</span><span class=p>);</span>
</span><span id=__span-12-12><a id=__codelineno-12-12 name=__codelineno-12-12 href=#__codelineno-12-12></a><span class=nx>inviteEmployee1</span><span class=p>(</span><span class=s2>&quot;Hello&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;How are you?&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>// Привіт Джон Родсон, як справи?</span>
</span><span id=__span-12-13><a id=__codelineno-12-13 name=__codelineno-12-13 href=#__codelineno-12-13></a><span class=nx>inviteEmployee2</span><span class=p>(</span><span class=s2>&quot;Hello&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;How are you?&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>// Привіт, Джиммі Бейлі, як справи?</span>
</span></code></pre></div> <p>Виклик і застосування практично взаємозамінні. Обидва вони негайно виконують поточну функцію. Вам потрібно вирішити, що простіше - надсилати масив або список аргументів, розділених комами. Ви можете запам'ятати, розглядаючи Call як <strong>comma</strong> (відокремлений список), а Apply як <strong>Array</strong> (масив).</p> <p>Тоді як Bind створює нову функцію, яка матиме <code>this</code> як перший параметр, переданий до bind().</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4-json>4. Що таке JSON та його загальні операції<a class=headerlink href=#4-json title="Permanent link">&para;</a></h3> <p><strong>JSON</strong> - це текстовий формат даних, що відповідає об'єктному синтаксису JavaScript, який популяризував Дуглас Крокфорд (Douglas Crockford). Він корисний, коли ви хочете передати дані через мережу, і являє собою просто текстовий файл з розширенням .json і MIME-типом application/json.</p> <p><strong>Синтаксичний аналіз:</strong> Перетворення рядка в нативний об'єкт</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-13-1><a id=__codelineno-13-1 name=__codelineno-13-1 href=#__codelineno-13-1></a><span class=nb>JSON</span><span class=p>.</span><span class=nx>parse</span><span class=p>(</span><span class=nx>text</span><span class=p>);</span>
</span></code></pre></div> <p><strong>Структурування:</strong> перетворення нативного об'єкта в рядок для передачі по мережі</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-14-1><a id=__codelineno-14-1 name=__codelineno-14-1 href=#__codelineno-14-1></a><span class=nb>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>(</span><span class=nx>object</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5-slice>5. Яка мета методу slice для масиву<a class=headerlink href=#5-slice title="Permanent link">&para;</a></h3> <p>Метод <strong>slice()</strong> повертає вибрані елементи масиву у вигляді нового об'єкта масиву. Він вибирає елементи, починаючи з заданого початкового аргументу, і закінчуючи заданим необов'язковим кінцевим аргументом, не включаючи останній елемент. Якщо ви опустите другий аргумент, то вибірка буде виконуватися до кінця.</p> <p>Деякі приклади використання цього методу наведено нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-15-1><a id=__codelineno-15-1 name=__codelineno-15-1 href=#__codelineno-15-1></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>,</span><span class=w> </span><span class=mf>4</span><span class=p>,</span><span class=w> </span><span class=mf>5</span><span class=p>];</span>
</span><span id=__span-15-2><a id=__codelineno-15-2 name=__codelineno-15-2 href=#__codelineno-15-2></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>arrayIntegers</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mf>0</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає [1,2]</span>
</span><span id=__span-15-3><a id=__codelineno-15-3 name=__codelineno-15-3 href=#__codelineno-15-3></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>arrayIntegers</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає [3]</span>
</span><span id=__span-15-4><a id=__codelineno-15-4 name=__codelineno-15-4 href=#__codelineno-15-4></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>arrayIntegers</span><span class=p>.</span><span class=nx>slice</span><span class=p>(</span><span class=mf>4</span><span class=p>);</span><span class=w> </span><span class=c1>//повертається [5]</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Метод slice не мутує оригінальний масив, але повертає підмножину у вигляді нового масиву.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=6-splice>6. Яка мета методу splice для масиву<a class=headerlink href=#6-splice title="Permanent link">&para;</a></h3> <p>Метод <strong>splice()</strong> використовується або для додавання/видалення елементів до/з масиву, а потім повертає видалений елемент. Перший аргумент вказує позицію в масиві для вставки або видалення, тоді як необов'язковий другий аргумент вказує кількість елементів, які потрібно видалити. Кожен додатковий аргумент додається до масиву.</p> <p>Деякі приклади використання цього методу наведено нижче:</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-16-1><a id=__codelineno-16-1 name=__codelineno-16-1 href=#__codelineno-16-1></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegersOriginal1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>,</span><span class=w> </span><span class=mf>4</span><span class=p>,</span><span class=w> </span><span class=mf>5</span><span class=p>];</span>
</span><span id=__span-16-2><a id=__codelineno-16-2 name=__codelineno-16-2 href=#__codelineno-16-2></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegersOriginal2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>,</span><span class=w> </span><span class=mf>4</span><span class=p>,</span><span class=w> </span><span class=mf>5</span><span class=p>];</span>
</span><span id=__span-16-3><a id=__codelineno-16-3 name=__codelineno-16-3 href=#__codelineno-16-3></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegersOriginal3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>,</span><span class=w> </span><span class=mf>4</span><span class=p>,</span><span class=w> </span><span class=mf>5</span><span class=p>];</span>
</span><span id=__span-16-4><a id=__codelineno-16-4 name=__codelineno-16-4 href=#__codelineno-16-4></a>
</span><span id=__span-16-5><a id=__codelineno-16-5 name=__codelineno-16-5 href=#__codelineno-16-5></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>arrayIntegersOriginal1</span><span class=p>.</span><span class=nx>splice</span><span class=p>(</span><span class=mf>0</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає [1, 2]; вихідний масив: [3, 4, 5]</span>
</span><span id=__span-16-6><a id=__codelineno-16-6 name=__codelineno-16-6 href=#__codelineno-16-6></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>arrayIntegersOriginal2</span><span class=p>.</span><span class=nx>splice</span><span class=p>(</span><span class=mf>3</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає [4, 5]; вихідний масив: [1, 2, 3]</span>
</span><span id=__span-16-7><a id=__codelineno-16-7 name=__codelineno-16-7 href=#__codelineno-16-7></a><span class=kd>let</span><span class=w> </span><span class=nx>arrayIntegers3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>arrayIntegersOriginal3</span><span class=p>.</span><span class=nx>splice</span><span class=p>(</span><span class=mf>3</span><span class=p>,</span><span class=w> </span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;a&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;b&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;c&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>//повертає [4]; вихідний масив: [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 5]</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Метод Splice модифікує вихідний масив і повертає видалений масив.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=7-slice-splice>7. В чому різниця між slice та splice<a class=headerlink href=#7-slice-splice title="Permanent link">&para;</a></h3> <p>Деякі основні відмінності в табличній формі:</p> <table> <thead> <tr> <th>Slice</th> <th>Splice</th> </tr> </thead> <tbody> <tr> <td>Не модифікує вихідний масив (незмінний)</td> <td>Модифікує вихідний масив (змінюваний)</td> </tr> <tr> <td>Повертає підмножину вихідного масиву</td> <td>Повертає видалені елементи як масив</td> </tr> <tr> <td>Використовується для вибору елементів з масиву</td> <td>Використовується для вставки або видалення елементів в/з масиву</td> </tr> </tbody> </table> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=8-map>8. Як порівняти Об'єкт із Map<a class=headerlink href=#8-map title="Permanent link">&para;</a></h3> <p><strong>Об'єкти</strong> схожі на мапи у тому, що обидва дозволяють встановлювати ключі для значень, отримувати ці значення, видаляти ключі та визначати, чи зберігається щось за ключем. З цієї причини об'єкти історично використовувалися як мапи. Але існують важливі відмінності, які роблять використання мапи кращим у певних випадках.</p> <ol> <li>Ключами об'єкта є рядки та символи, тоді як для мапи вони можуть бути будь-якими значеннями, включаючи функції, об'єкти та будь-які примітиви.</li> <li>Ключі на карті впорядковані, а ключі, додані до об'єкта, ні. Таким чином, при ітерації над об'єктом Map повертає ключі у порядку їх додавання.</li> <li>Розмір Map можна легко отримати за допомогою властивості size, в той час як кількість властивостей в Object потрібно визначати вручну.</li> <li>Мапа є ітерабельним об'єктом і тому може бути безпосередньо ітерабельною, в той час як ітерація над Об'єктом вимагає отримання його ключів та ітерації над ними.</li> <li>Об'єкт має прототип, тому на карті є ключі за замовчуванням, які можуть зіткнутися з вашими ключами, якщо ви не будете обережними. Починаючи з ES5 це можна обійти за допомогою map = Object.create(null), але це рідко робиться.</li> <li>Карта може працювати краще у сценаріях, що передбачають часте додавання та видалення пар ключів.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=9_1>9. В чому різниця між операторами == та ===<a class=headerlink href=#9_1 title="Permanent link">&para;</a></h3> <p>JavaScript забезпечує як строге (===, !<mark>), так і привідне (</mark>, !=) порівняння на рівність. Строгі оператори беруть до уваги тип змінної, в той час як нестрогі оператори виконують корекцію/перетворення типу на основі значень змінних. Строгі оператори виконують наступні умови для різних типів,</p> <ol> <li>Два рядки є строго рівними, якщо вони мають однакову послідовність символів, однакову довжину і однакові символи у відповідних позиціях.</li> <li>Два числа є строго рівними, якщо вони є чисельно рівними, тобто мають однакове числове значення. Існує два особливих випадки,<ol> <li>NaN не дорівнює ніякому числу, включаючи NaN.</li> <li>Додатні та від'ємні нулі дорівнюють один одному.</li> </ol> </li> <li>Два булевих операнди строго рівні, якщо обидва істинні або обидва хибні.</li> <li>Два об'єкти строго рівні, якщо вони посилаються на один і той самий об'єкт.</li> <li>Типи Null та Undefined не рівні з ===, але рівні з <mark>, тобто null =</mark> undefined &rarr; false, але null ==u ndefined &rarr; true</li> </ol> <p>Декілька прикладів, які охоплюють вищезгадані випадки,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-17-1><a id=__codelineno-17-1 name=__codelineno-17-1 href=#__codelineno-17-1></a><span class=mf>0</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>false</span><span class=w> </span><span class=c1>// true</span>
</span><span id=__span-17-2><a id=__codelineno-17-2 name=__codelineno-17-2 href=#__codelineno-17-2></a><span class=mf>0</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=kc>false</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-17-3><a id=__codelineno-17-3 name=__codelineno-17-3 href=#__codelineno-17-3></a><span class=mf>1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s2>&quot;1&quot;</span><span class=w> </span><span class=c1>// true</span>
</span><span id=__span-17-4><a id=__codelineno-17-4 name=__codelineno-17-4 href=#__codelineno-17-4></a><span class=mf>1</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s2>&quot;1&quot;</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-17-5><a id=__codelineno-17-5 name=__codelineno-17-5 href=#__codelineno-17-5></a><span class=kc>null</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>undefined</span><span class=w> </span><span class=c1>// true</span>
</span><span id=__span-17-6><a id=__codelineno-17-6 name=__codelineno-17-6 href=#__codelineno-17-6></a><span class=kc>null</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=kc>undefined</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-17-7><a id=__codelineno-17-7 name=__codelineno-17-7 href=#__codelineno-17-7></a><span class=s1>&#39;0&#39;</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>false</span><span class=w> </span><span class=c1>// true</span>
</span><span id=__span-17-8><a id=__codelineno-17-8 name=__codelineno-17-8 href=#__codelineno-17-8></a><span class=s1>&#39;0&#39;</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=kc>false</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-17-9><a id=__codelineno-17-9 name=__codelineno-17-9 href=#__codelineno-17-9></a><span class=p>[]</span><span class=o>==</span><span class=p>[]</span><span class=w> </span><span class=nx>або</span><span class=w> </span><span class=p>[]</span><span class=o>===</span><span class=p>[]</span><span class=w> </span><span class=c1>//false, посилаються на різні об&#39;єкти в пам&#39;яті</span>
</span><span id=__span-17-10><a id=__codelineno-17-10 name=__codelineno-17-10 href=#__codelineno-17-10></a><span class=p>{}</span><span class=o>==</span><span class=p>{}</span><span class=w> </span><span class=nx>або</span><span class=w> </span><span class=p>{}</span><span class=o>===</span><span class=p>{}</span><span class=w> </span><span class=c1>//неправда, посилаються на різні об&#39;єкти в пам&#39;яті</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=10->10. Що таке лямбда- або стрілкові функції<a class=headerlink href=#10- title="Permanent link">&para;</a></h3> <p>Функція-стрілка - це коротший синтаксис виразу функції, який не має власних <strong>this, arguments, super або new.target</strong>.<br> Ці функції найкраще підходять для функцій, що не є методами, і їх не можна використовувати як конструктори.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=11_1>11. Що таке функція першого класу<a class=headerlink href=#11_1 title="Permanent link">&para;</a></h3> <p>У Javascript функції є об'єктами першого класу. Першокласні функції означають, що функції в цій мові поводяться так само, як і будь-які інші змінні.</p> <p>Наприклад, у такій мові функцію можна передавати як аргумент іншим функціям, повертати іншою функцією і присвоювати як значення змінній. Наприклад, у наведеному нижче прикладі функції-оброблювачі, присвоєні слухачеві</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-18-1><a id=__codelineno-18-1 name=__codelineno-18-1 href=#__codelineno-18-1></a><span class=kd>const</span><span class=w> </span><span class=nx>handler</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Це функція обробки кліку&quot;</span><span class=p>);</span>
</span><span id=__span-18-2><a id=__codelineno-18-2 name=__codelineno-18-2 href=#__codelineno-18-2></a><span class=nb>document</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&quot;click&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>handler</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=12_1>12. Що таке функція першого порядку<a class=headerlink href=#12_1 title="Permanent link">&para;</a></h3> <p>Функція першого порядку - це функція, яка не приймає іншу функцію як аргумент і не повертає функцію як своє значення.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-19-1><a id=__codelineno-19-1 name=__codelineno-19-1 href=#__codelineno-19-1></a><span class=kd>const</span><span class=w> </span><span class=nx>firstOrder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Я функція першого порядку!&quot;</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=13>13. Що таке функція вищого порядку<a class=headerlink href=#13 title="Permanent link">&para;</a></h3> <p>Функція вищого порядку - це функція, яка приймає іншу функцію як аргумент або повертає функцію як значення, що повертається, або і те, і інше.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-20-1><a id=__codelineno-20-1 name=__codelineno-20-1 href=#__codelineno-20-1></a><span class=kd>const</span><span class=w> </span><span class=nx>firstOrderFunc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>...</span>
</span><span id=__span-20-2><a id=__codelineno-20-2 name=__codelineno-20-2 href=#__codelineno-20-2></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Привіт, я функція першого порядку&quot;</span><span class=p>);</span>
</span><span id=__span-20-3><a id=__codelineno-20-3 name=__codelineno-20-3 href=#__codelineno-20-3></a><span class=kd>const</span><span class=w> </span><span class=nx>higherOrder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>ReturnFirstOrderFunc</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>ReturnFirstOrderFunc</span><span class=p>();</span>
</span><span id=__span-20-4><a id=__codelineno-20-4 name=__codelineno-20-4 href=#__codelineno-20-4></a><span class=nx>higherOrder</span><span class=p>(</span><span class=nx>firstOrderFunc</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=14>14. Що таке унарна функція<a class=headerlink href=#14 title="Permanent link">&para;</a></h3> <p>Унарна функція (тобто монада) - це функція, яка приймає рівно один аргумент. Вона позначає єдиний аргумент, який приймає функція.</p> <p>Розглянемо приклад унарної функції:</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-21-1><a id=__codelineno-21-1 name=__codelineno-21-1 href=#__codelineno-21-1></a><span class=kd>const</span><span class=w> </span><span class=nx>unaryFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mf>10</span><span class=p>);</span><span class=w> </span><span class=c1>// Додати до заданого аргументу 10 і вивести значення</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=15>15. Що таке функція каррінг<a class=headerlink href=#15 title="Permanent link">&para;</a></h3> <p>Каррінг - це процес перетворення функції з декількома аргументами на послідовність функцій, кожна з яких має лише один аргумент. Каррінг названо на честь математика <strong>Гаскелла Каррі</strong>. Застосовуючи каррінг, n-арна функція перетворюється на унарну функцію.</p> <p>Розглянемо приклад n-арної функції і те, як вона перетворюється на функцію каррі,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-22-1><a id=__codelineno-22-1 name=__codelineno-22-1 href=#__codelineno-22-1></a><span class=kd>const</span><span class=w> </span><span class=nx>multiArgFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>a</span><span class=p>,</span><span class=w> </span><span class=nx>b</span><span class=p>,</span><span class=w> </span><span class=nx>c</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>b</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>c</span><span class=p>;</span>
</span><span id=__span-22-2><a id=__codelineno-22-2 name=__codelineno-22-2 href=#__codelineno-22-2></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>multiArgFunction</span><span class=p>(</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>));</span><span class=w> </span><span class=c1>// 6</span>
</span><span id=__span-22-3><a id=__codelineno-22-3 name=__codelineno-22-3 href=#__codelineno-22-3></a>
</span><span id=__span-22-4><a id=__codelineno-22-4 name=__codelineno-22-4 href=#__codelineno-22-4></a><span class=kd>const</span><span class=w> </span><span class=nx>curryUnaryFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nx>b</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nx>c</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>a</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>b</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>c</span><span class=p>;</span>
</span><span id=__span-22-5><a id=__codelineno-22-5 name=__codelineno-22-5 href=#__codelineno-22-5></a><span class=nx>curryUnaryFunction</span><span class=p>(</span><span class=mf>1</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає функцію: b =&gt; c =&gt; 1 + b + c</span>
</span><span id=__span-22-6><a id=__codelineno-22-6 name=__codelineno-22-6 href=#__codelineno-22-6></a><span class=nx>curryUnaryFunction</span><span class=p>(</span><span class=mf>1</span><span class=p>)(</span><span class=mf>2</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає функцію: c =&gt; 3 + c</span>
</span><span id=__span-22-7><a id=__codelineno-22-7 name=__codelineno-22-7 href=#__codelineno-22-7></a><span class=nx>curryUnaryFunction</span><span class=p>(</span><span class=mf>1</span><span class=p>)(</span><span class=mf>2</span><span class=p>)(</span><span class=mf>3</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає число 6</span>
</span></code></pre></div> <p>Функції каррі чудово підходять для покращення <strong>можливості повторного використання коду</strong> та <strong>функціонального складу</strong>.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=16>16. Що таке чиста функція<a class=headerlink href=#16 title="Permanent link">&para;</a></h3> <p>Чиста функція - це функція, значення, що повертається, визначається лише її аргументами без будь-яких побічних ефектів, тобто якщо ви викликаєте функцію з тими самими аргументами "n" разів і "n" місць у програмі, вона завжди повертатиме одне й те саме значення.</p> <p>Розглянемо на прикладі різницю між чистими і нечистими функціями:</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-23-1><a id=__codelineno-23-1 name=__codelineno-23-1 href=#__codelineno-23-1></a><span class=c1>//Нечиста</span>
</span><span id=__span-23-2><a id=__codelineno-23-2 name=__codelineno-23-2 href=#__codelineno-23-2></a><span class=kd>let</span><span class=w> </span><span class=nx>numberArray</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[];</span>
</span><span id=__span-23-3><a id=__codelineno-23-3 name=__codelineno-23-3 href=#__codelineno-23-3></a><span class=kd>const</span><span class=w> </span><span class=nx>impureAddNumber</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>number</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>numberArray</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>number</span><span class=p>);</span>
</span><span id=__span-23-4><a id=__codelineno-23-4 name=__codelineno-23-4 href=#__codelineno-23-4></a><span class=c1>//Чистий</span>
</span><span id=__span-23-5><a id=__codelineno-23-5 name=__codelineno-23-5 href=#__codelineno-23-5></a><span class=kd>const</span><span class=w> </span><span class=nx>pureAddNumber</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>number</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nx>argNumberArray</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nx>numberArray</span><span class=p>)</span>
</span><span id=__span-23-6><a id=__codelineno-23-6 name=__codelineno-23-6 href=#__codelineno-23-6></a><span class=nx>argNumberArray</span><span class=p>.</span><span class=nx>concat</span><span class=p>([</span><span class=nx>number</span><span class=p>]);</span>
</span><span id=__span-23-7><a id=__codelineno-23-7 name=__codelineno-23-7 href=#__codelineno-23-7></a>
</span><span id=__span-23-8><a id=__codelineno-23-8 name=__codelineno-23-8 href=#__codelineno-23-8></a><span class=c1>//Вивести результати</span>
</span><span id=__span-23-9><a id=__codelineno-23-9 name=__codelineno-23-9 href=#__codelineno-23-9></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>impureAddNumber</span><span class=p>(</span><span class=mf>6</span><span class=p>));</span><span class=w> </span><span class=c1>// повертає 1</span>
</span><span id=__span-23-10><a id=__codelineno-23-10 name=__codelineno-23-10 href=#__codelineno-23-10></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>numberArray</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає [6]</span>
</span><span id=__span-23-11><a id=__codelineno-23-11 name=__codelineno-23-11 href=#__codelineno-23-11></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>pureAddNumber</span><span class=p>(</span><span class=mf>7</span><span class=p>)(</span><span class=nx>numberArray</span><span class=p>));</span><span class=w> </span><span class=c1>// повертає [6, 7]</span>
</span><span id=__span-23-12><a id=__codelineno-23-12 name=__codelineno-23-12 href=#__codelineno-23-12></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>numberArray</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає [6]</span>
</span></code></pre></div> <p>Як видно з вищенаведених фрагментів коду, функція <strong>Push</strong> сама є нечистою, оскільки змінює масив і повертає індекс числа, що проштовхується, незалежно від значення параметра. . Тоді як <strong>Concat</strong>, навпаки, бере масив і об'єднує його з іншим масивом, створюючи абсолютно новий масив без побічних ефектів. Крім того, значення, що повертається, є конкатенацією попереднього масиву.</p> <p>Пам'ятайте, що чисті функції важливі, оскільки вони спрощують модульне тестування без побічних ефектів і не потребують ін'єкції залежностей. Вони також уникають тісного зв'язку і ускладнюють злам вашої програми, оскільки не мають побічних ефектів. Ці принципи поєднуються з концепцією <strong>Immutability</strong> в ES6, надаючи перевагу використанню <strong>const</strong> над <strong>let</strong>.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=17-let>17. Яка мета ключового слова let<a class=headerlink href=#17-let title="Permanent link">&para;</a></h3> <p>Інструкція <code>let</code> оголошує локальну змінну з областю видимості <strong>блоку</strong>. Таким чином, змінні, визначені з ключовим словом let, обмежені в області видимості блоком, оператором або виразом, в якому вони використовуються. Тоді як змінні, оголошені з ключовим словом <code>var</code>, використовуються для визначення змінної глобально або локально для всієї функції незалежно від області видимості блоку.</p> <p>Розглянемо приклад, щоб продемонструвати використання:</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-24-1><a id=__codelineno-24-1 name=__codelineno-24-1 href=#__codelineno-24-1></a><span class=kd>let</span><span class=w> </span><span class=nx>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>30</span><span class=p>;</span>
</span><span id=__span-24-2><a id=__codelineno-24-2 name=__codelineno-24-2 href=#__codelineno-24-2></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>counter</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>30</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-24-3><a id=__codelineno-24-3 name=__codelineno-24-3 href=#__codelineno-24-3></a><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=nx>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>31</span><span class=p>;</span>
</span><span id=__span-24-4><a id=__codelineno-24-4 name=__codelineno-24-4 href=#__codelineno-24-4></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>);</span><span class=w> </span><span class=c1>// 31</span>
</span><span id=__span-24-5><a id=__codelineno-24-5 name=__codelineno-24-5 href=#__codelineno-24-5></a><span class=p>}</span>
</span><span id=__span-24-6><a id=__codelineno-24-6 name=__codelineno-24-6 href=#__codelineno-24-6></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>);</span><span class=w> </span><span class=c1>// 30 (тому що змінної в блоці if тут не буде)</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=18-let-var>18. В чому різниця між let та var<a class=headerlink href=#18-let-var title="Permanent link">&para;</a></h3> <table> <thead> <tr> <th>var</th> <th>let</th> </tr> </thead> <tbody> <tr> <td>Був доступний з самого початку JavaScript</td> <td>Представлений як частина ES6</td> </tr> <tr> <td>Має область видимості функції</td> <td>Має область видимості блоку</td> </tr> <tr> <td>Змінні будуть підняті</td> <td>Підняті, але не ініціалізовані</td> </tr> </tbody> </table> <p>Давайте розглянемо приклад, щоб побачити різницю: <div class="language-javascript highlight"><pre><span></span><code><span id=__span-25-1><a id=__codelineno-25-1 name=__codelineno-25-1 href=#__codelineno-25-1></a><span class=kd>function</span><span class=w> </span><span class=nx>userDetails</span><span class=p>(</span><span class=nx>ім</span><span class=s1>&#39;я користувача) {</span>
</span><span id=__span-25-2><a id=__codelineno-25-2 name=__codelineno-25-2 href=#__codelineno-25-2></a><span class=s1>  if (ім&#39;</span><span class=nx>я_користувача</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-25-3><a id=__codelineno-25-3 name=__codelineno-25-3 href=#__codelineno-25-3></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>salary</span><span class=p>);</span><span class=w> </span><span class=c1>// невизначено через підняття</span>
</span><span id=__span-25-4><a id=__codelineno-25-4 name=__codelineno-25-4 href=#__codelineno-25-4></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>age</span><span class=p>);</span><span class=w> </span><span class=c1>// ReferenceError: Неможливо отримати доступ до &#39;age&#39; до ініціалізації</span>
</span><span id=__span-25-5><a id=__codelineno-25-5 name=__codelineno-25-5 href=#__codelineno-25-5></a><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=nx>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>30</span><span class=p>;</span>
</span><span id=__span-25-6><a id=__codelineno-25-6 name=__codelineno-25-6 href=#__codelineno-25-6></a><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>salary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>10000</span><span class=p>;</span>
</span><span id=__span-25-7><a id=__codelineno-25-7 name=__codelineno-25-7 href=#__codelineno-25-7></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-25-8><a id=__codelineno-25-8 name=__codelineno-25-8 href=#__codelineno-25-8></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>salary</span><span class=p>);</span><span class=w> </span><span class=c1>//10000 (доступно з області видимості функції)</span>
</span><span id=__span-25-9><a id=__codelineno-25-9 name=__codelineno-25-9 href=#__codelineno-25-9></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>age</span><span class=p>);</span><span class=w> </span><span class=c1>//помилка: вік не визначений(через область видимості блоку)</span>
</span><span id=__span-25-10><a id=__codelineno-25-10 name=__codelineno-25-10 href=#__codelineno-25-10></a><span class=p>}</span>
</span><span id=__span-25-11><a id=__codelineno-25-11 name=__codelineno-25-11 href=#__codelineno-25-11></a><span class=nx>userDetails</span><span class=p>(</span><span class=s2>&quot;John&quot;</span><span class=p>);</span>
</span></code></pre></div></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=19-let>19. Яка причина вибору назви let як ключового слова<a class=headerlink href=#19-let title="Permanent link">&para;</a></h3> <p><code>let</code> - це математичний оператор, який був прийнятий у ранніх мовах програмування, таких як <strong>Scheme</strong> та <strong>Basic</strong>. Його було запозичено з десятків інших мов, які використовують <code>let</code> вже як традиційне ключове слово, максимально наближене до <code>var</code>.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=20-switch>20. Як перевизначити змінні в switch блоку без помилки<a class=headerlink href=#20-switch title="Permanent link">&para;</a></h3> <p>Якщо ви спробуєте перевизначити змінні в "блоці перемикачів", то це призведе до помилок, оскільки існує лише один блок. Наприклад, наведений нижче блок коду викликає синтаксичну помилку, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-26-1><a id=__codelineno-26-1 name=__codelineno-26-1 href=#__codelineno-26-1></a><span class=kd>let</span><span class=w> </span><span class=nx>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1</span><span class=p>;</span>
</span><span id=__span-26-2><a id=__codelineno-26-2 name=__codelineno-26-2 href=#__codelineno-26-2></a><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=nx>x</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-26-3><a id=__codelineno-26-3 name=__codelineno-26-3 href=#__codelineno-26-3></a><span class=w>  </span><span class=k>case</span><span class=w> </span><span class=mf>0</span>
</span><span id=__span-26-4><a id=__codelineno-26-4 name=__codelineno-26-4 href=#__codelineno-26-4></a><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=nx>name</span><span class=p>;</span>
</span><span id=__span-26-5><a id=__codelineno-26-5 name=__codelineno-26-5 href=#__codelineno-26-5></a><span class=w>    </span><span class=k>break</span>
</span><span id=__span-26-6><a id=__codelineno-26-6 name=__codelineno-26-6 href=#__codelineno-26-6></a>
</span><span id=__span-26-7><a id=__codelineno-26-7 name=__codelineno-26-7 href=#__codelineno-26-7></a><span class=w>  </span><span class=k>case</span><span class=w> </span><span class=mf>1</span><span class=o>:</span>
</span><span id=__span-26-8><a id=__codelineno-26-8 name=__codelineno-26-8 href=#__codelineno-26-8></a><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=nx>name</span><span class=p>;</span><span class=w> </span><span class=c1>// Синтаксична помилка при перевизначенні.</span>
</span><span id=__span-26-9><a id=__codelineno-26-9 name=__codelineno-26-9 href=#__codelineno-26-9></a><span class=w>    </span><span class=k>break</span><span class=p>;</span>
</span><span id=__span-26-10><a id=__codelineno-26-10 name=__codelineno-26-10 href=#__codelineno-26-10></a><span class=p>}</span>
</span></code></pre></div> <p>Щоб уникнути цієї помилки, ви можете створити вкладений блок всередині case-речення і створити нове блокове лексичне оточення.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-27-1><a id=__codelineno-27-1 name=__codelineno-27-1 href=#__codelineno-27-1></a><span class=kd>let</span><span class=w> </span><span class=nx>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1</span><span class=p>;</span>
</span><span id=__span-27-2><a id=__codelineno-27-2 name=__codelineno-27-2 href=#__codelineno-27-2></a><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=nx>x</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-27-3><a id=__codelineno-27-3 name=__codelineno-27-3 href=#__codelineno-27-3></a><span class=w>  </span><span class=k>case</span><span class=w> </span><span class=mf>0</span><span class=o>:</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-27-4><a id=__codelineno-27-4 name=__codelineno-27-4 href=#__codelineno-27-4></a><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=nx>name</span><span class=p>;</span>
</span><span id=__span-27-5><a id=__codelineno-27-5 name=__codelineno-27-5 href=#__codelineno-27-5></a><span class=w>    </span><span class=k>break</span><span class=p>;</span>
</span><span id=__span-27-6><a id=__codelineno-27-6 name=__codelineno-27-6 href=#__codelineno-27-6></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-27-7><a id=__codelineno-27-7 name=__codelineno-27-7 href=#__codelineno-27-7></a><span class=w>  </span><span class=k>case</span><span class=w> </span><span class=mf>1</span><span class=o>:</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-27-8><a id=__codelineno-27-8 name=__codelineno-27-8 href=#__codelineno-27-8></a><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=nx>name</span><span class=p>;</span><span class=w> </span><span class=c1>// Немає синтаксичної помилки при перевизначенні.</span>
</span><span id=__span-27-9><a id=__codelineno-27-9 name=__codelineno-27-9 href=#__codelineno-27-9></a><span class=w>    </span><span class=k>break</span><span class=p>;</span>
</span><span id=__span-27-10><a id=__codelineno-27-10 name=__codelineno-27-10 href=#__codelineno-27-10></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-27-11><a id=__codelineno-27-11 name=__codelineno-27-11 href=#__codelineno-27-11></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=21>21. Що таке Тимчасова мертва зона<a class=headerlink href=#21 title="Permanent link">&para;</a></h3> <p>Тимчасова мертва зона - це поведінка в JavaScript, яка виникає при оголошенні змінної з ключовими словами let і const, але не з var. В ECMAScript 6 доступ до змінної <code>let</code> або <code>const</code> до її оголошення (в межах її області видимості) викликає помилку посилання. Проміжок часу, коли це відбувається, між створенням прив'язки змінної та її оголошенням, називається тимчасовою мертвою зоною.</p> <p>Розглянемо таку поведінку на прикладі:</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-28-1><a id=__codelineno-28-1 name=__codelineno-28-1 href=#__codelineno-28-1></a><span class=kd>function</span><span class=w> </span><span class=nx>somemethod</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-28-2><a id=__codelineno-28-2 name=__codelineno-28-2 href=#__codelineno-28-2></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter1</span><span class=p>);</span><span class=w> </span><span class=c1>// undefined</span>
</span><span id=__span-28-3><a id=__codelineno-28-3 name=__codelineno-28-3 href=#__codelineno-28-3></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter2</span><span class=p>);</span><span class=w> </span><span class=c1>// ReferenceError</span>
</span><span id=__span-28-4><a id=__codelineno-28-4 name=__codelineno-28-4 href=#__codelineno-28-4></a><span class=w>  </span><span class=kd>var</span><span class=w> </span><span class=nx>counter1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1</span><span class=p>;</span>
</span><span id=__span-28-5><a id=__codelineno-28-5 name=__codelineno-28-5 href=#__codelineno-28-5></a><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=nx>counter2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>2</span><span class=p>;</span>
</span><span id=__span-28-6><a id=__codelineno-28-6 name=__codelineno-28-6 href=#__codelineno-28-6></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=22-iife>22. Що таке Негайно Викликані Функціональні Вирази (IIFE)<a class=headerlink href=#22-iife title="Permanent link">&para;</a></h3> <p>IIFE (Immediately Invoked Function Expression) - це функція JavaScript, яка виконується одразу після її визначення. Її підпис буде таким, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-29-1><a id=__codelineno-29-1 name=__codelineno-29-1 href=#__codelineno-29-1></a><span class=p>(</span><span class=nx>функція</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-29-2><a id=__codelineno-29-2 name=__codelineno-29-2 href=#__codelineno-29-2></a><span class=w>  </span><span class=c1>// логіка тут</span>
</span><span id=__span-29-3><a id=__codelineno-29-3 name=__codelineno-29-3 href=#__codelineno-29-3></a><span class=p>})();</span>
</span></code></pre></div> <p>Основною причиною використання IIFE є забезпечення конфіденційності даних, оскільки будь-які змінні, оголошені в IIFE, не можуть бути доступні ззовні. Тобто, якщо ви намагаєтесь отримати доступ до змінних за допомогою IIFE, він видасть помилку, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-30-1><a id=__codelineno-30-1 name=__codelineno-30-1 href=#__codelineno-30-1></a><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-30-2><a id=__codelineno-30-2 name=__codelineno-30-2 href=#__codelineno-30-2></a><span class=w>  </span><span class=kd>var</span><span class=w> </span><span class=nx>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;IIFE&quot;</span><span class=p>;</span>
</span><span id=__span-30-3><a id=__codelineno-30-3 name=__codelineno-30-3 href=#__codelineno-30-3></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span><span id=__span-30-4><a id=__codelineno-30-4 name=__codelineno-30-4 href=#__codelineno-30-4></a><span class=p>})();</span>
</span><span id=__span-30-5><a id=__codelineno-30-5 name=__codelineno-30-5 href=#__codelineno-30-5></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span><span class=w> </span><span class=c1>//Ошибка: повідомлення не визначено</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=23-url-javascript>23. Як декодувати або закодувати URL в JavaScript?<a class=headerlink href=#23-url-javascript title="Permanent link">&para;</a></h3> <p>Функція <code>encodeURI()</code> використовується для кодування URL-адреси. Ця функція отримує в якості параметра рядок URL-адреси і повертає закодований рядок. Функція <code>decodeURI()</code> використовується для декодування URL-адреси. Ця функція отримує закодований рядок URL як параметр і повертає декодований рядок.</p> <p><strong>Примітка:</strong> Якщо ви хочете закодувати такі символи, як <code>/ ? : @ &amp; = + $ #</code>, то вам слід використовувати <code>encodeURIComponent()</code>.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-31-1><a id=__codelineno-31-1 name=__codelineno-31-1 href=#__codelineno-31-1></a><span class=kd>let</span><span class=w> </span><span class=nx>uri</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;employeeDetails?name=john&amp;occupation=manager&quot;</span><span class=p>;</span>
</span><span id=__span-31-2><a id=__codelineno-31-2 name=__codelineno-31-2 href=#__codelineno-31-2></a><span class=kd>let</span><span class=w> </span><span class=nx>encoded_uri</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>encodeURI</span><span class=p>(</span><span class=nx>uri</span><span class=p>);</span>
</span><span id=__span-31-3><a id=__codelineno-31-3 name=__codelineno-31-3 href=#__codelineno-31-3></a><span class=kd>let</span><span class=w> </span><span class=nx>decoded_uri</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>decodeURI</span><span class=p>(</span><span class=nx>encoded_uri</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=24>24. Що таке мемоізація<a class=headerlink href=#24 title="Permanent link">&para;</a></h3> <p>Memoization (Запам'ятовування) - це техніка програмування, яка намагається підвищити продуктивність функції шляхом кешування її попередньо обчислених результатів. Кожного разу, коли викликається функція, що запам'ятовується, її параметри використовуються для індексації кешу. Якщо дані є, то їх можна повернути, не виконуючи всю функцію. В іншому випадку функція виконується, а потім результат додається до кешу. Розглянемо приклад додавання функції із запам'ятовуванням,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-32-1><a id=__codelineno-32-1 name=__codelineno-32-1 href=#__codelineno-32-1></a><span class=kd>const</span><span class=w> </span><span class=nx>memoizAddition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-32-2><a id=__codelineno-32-2 name=__codelineno-32-2 href=#__codelineno-32-2></a><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=nx>cache</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{};</span>
</span><span id=__span-32-3><a id=__codelineno-32-3 name=__codelineno-32-3 href=#__codelineno-32-3></a><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-32-4><a id=__codelineno-32-4 name=__codelineno-32-4 href=#__codelineno-32-4></a><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=w> </span><span class=ow>in</span><span class=w> </span><span class=nx>cache</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-32-5><a id=__codelineno-32-5 name=__codelineno-32-5 href=#__codelineno-32-5></a><span class=w>      </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Вибірка з кешу&quot;</span><span class=p>);</span>
</span><span id=__span-32-6><a id=__codelineno-32-6 name=__codelineno-32-6 href=#__codelineno-32-6></a><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=nx>cache</span><span class=p>[</span><span class=nx>value</span><span class=p>];</span><span class=w> </span><span class=c1>// Тут cache.value не може бути використано, оскільки назва властивості починається з цифри, яка не є коректним ідентифікатором JavaScript. Отже, доступ до нього можливий лише з використанням квадратних дужок.</span>
</span><span id=__span-32-7><a id=__codelineno-32-7 name=__codelineno-32-7 href=#__codelineno-32-7></a><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-32-8><a id=__codelineno-32-8 name=__codelineno-32-8 href=#__codelineno-32-8></a><span class=w>      </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Обчислюємо результат&quot;</span><span class=p>);</span>
</span><span id=__span-32-9><a id=__codelineno-32-9 name=__codelineno-32-9 href=#__codelineno-32-9></a><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mf>20</span><span class=p>;</span>
</span><span id=__span-32-10><a id=__codelineno-32-10 name=__codelineno-32-10 href=#__codelineno-32-10></a><span class=w>      </span><span class=nx>cache</span><span class=p>[</span><span class=nx>value</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>result</span><span class=p>;</span>
</span><span id=__span-32-11><a id=__codelineno-32-11 name=__codelineno-32-11 href=#__codelineno-32-11></a><span class=w>      </span><span class=k>return</span><span class=w> </span><span class=nx>result</span><span class=p>;</span>
</span><span id=__span-32-12><a id=__codelineno-32-12 name=__codelineno-32-12 href=#__codelineno-32-12></a><span class=w>    </span><span class=p>}</span>
</span><span id=__span-32-13><a id=__codelineno-32-13 name=__codelineno-32-13 href=#__codelineno-32-13></a><span class=w>  </span><span class=p>};</span>
</span><span id=__span-32-14><a id=__codelineno-32-14 name=__codelineno-32-14 href=#__codelineno-32-14></a><span class=p>};</span>
</span><span id=__span-32-15><a id=__codelineno-32-15 name=__codelineno-32-15 href=#__codelineno-32-15></a><span class=c1>// функція, що повертається з memoizAddition</span>
</span><span id=__span-32-16><a id=__codelineno-32-16 name=__codelineno-32-16 href=#__codelineno-32-16></a><span class=kd>const</span><span class=w> </span><span class=nx>addition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>memoizAddition</span><span class=p>();</span>
</span><span id=__span-32-17><a id=__codelineno-32-17 name=__codelineno-32-17 href=#__codelineno-32-17></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>addition</span><span class=p>(</span><span class=mf>20</span><span class=p>));</span><span class=w> </span><span class=c1>//виведення: 40 обчислено</span>
</span><span id=__span-32-18><a id=__codelineno-32-18 name=__codelineno-32-18 href=#__codelineno-32-18></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>addition</span><span class=p>(</span><span class=mf>20</span><span class=p>));</span><span class=w> </span><span class=c1>//виведення: 40 кешовано</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=25>25.Що таке Хойстінг<a class=headerlink href=#25 title="Permanent link">&para;</a></h3> <p>Hoisting - це механізм JavaScript, за допомогою якого змінні, оголошення функцій і класів переміщуються на початок їхньої області видимості перед виконанням коду. Пам'ятайте, що JavaScript піднімає тільки оголошення, а не ініціалізацію. Розглянемо простий приклад підйому змінної,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-33-1><a id=__codelineno-33-1 name=__codelineno-33-1 href=#__codelineno-33-1></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span><span class=w> </span><span class=c1>//вихід : undefined</span>
</span><span id=__span-33-2><a id=__codelineno-33-2 name=__codelineno-33-2 href=#__codelineno-33-2></a><span class=kd>var</span><span class=w> </span><span class=nx>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;Змінна була піднята&quot;</span><span class=p>;</span>
</span></code></pre></div> <p>Вищенаведений код для інтерпретатора виглядає так, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-34-1><a id=__codelineno-34-1 name=__codelineno-34-1 href=#__codelineno-34-1></a><span class=kd>var</span><span class=w> </span><span class=nx>message</span><span class=p>;</span>
</span><span id=__span-34-2><a id=__codelineno-34-2 name=__codelineno-34-2 href=#__codelineno-34-2></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span><span id=__span-34-3><a id=__codelineno-34-3 name=__codelineno-34-3 href=#__codelineno-34-3></a><span class=nx>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;Змінна була піднята&quot;</span><span class=p>;</span>
</span></code></pre></div> <p>Таким же чином піднімаються оголошення функцій</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-35-1><a id=__codelineno-35-1 name=__codelineno-35-1 href=#__codelineno-35-1></a><span class=nx>message</span><span class=p>(</span><span class=s2>&quot;Good morning&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>//Доброго ранку</span>
</span><span id=__span-35-2><a id=__codelineno-35-2 name=__codelineno-35-2 href=#__codelineno-35-2></a>
</span><span id=__span-35-3><a id=__codelineno-35-3 name=__codelineno-35-3 href=#__codelineno-35-3></a><span class=kd>function</span><span class=w> </span><span class=nx>message</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-35-4><a id=__codelineno-35-4 name=__codelineno-35-4 href=#__codelineno-35-4></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>name</span><span class=p>);</span>
</span><span id=__span-35-5><a id=__codelineno-35-5 name=__codelineno-35-5 href=#__codelineno-35-5></a><span class=p>}</span>
</span></code></pre></div> <p>Цей підйом дозволяє безпечно використовувати функції у коді до їх оголошення.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=26-es6>26. Що таке класи в ES6<a class=headerlink href=#26-es6 title="Permanent link">&para;</a></h3> <p>В ES6 класи Javascript - це насамперед синтаксичний цукор у порівнянні з існуючим успадкуванням JavaScript на основі прототипів. Наприклад, успадкування на основі прототипу, записане у вигляді виразу функції, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-36-1><a id=__codelineno-36-1 name=__codelineno-36-1 href=#__codelineno-36-1></a><span class=kd>function</span><span class=w> </span><span class=nx>Bike</span><span class=p>(</span><span class=nx>model</span><span class=p>,</span><span class=w> </span><span class=nx>color</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-36-2><a id=__codelineno-36-2 name=__codelineno-36-2 href=#__codelineno-36-2></a><span class=w>  </span><span class=k>this</span><span class=p>.</span><span class=nx>model</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>model</span><span class=p>;</span>
</span><span id=__span-36-3><a id=__codelineno-36-3 name=__codelineno-36-3 href=#__codelineno-36-3></a><span class=w>  </span><span class=k>this</span><span class=p>.</span><span class=nx>color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>color</span><span class=p>;</span>
</span><span id=__span-36-4><a id=__codelineno-36-4 name=__codelineno-36-4 href=#__codelineno-36-4></a><span class=p>}</span>
</span><span id=__span-36-5><a id=__codelineno-36-5 name=__codelineno-36-5 href=#__codelineno-36-5></a>
</span><span id=__span-36-6><a id=__codelineno-36-6 name=__codelineno-36-6 href=#__codelineno-36-6></a><span class=nx>Bike</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>getDetails</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-36-7><a id=__codelineno-36-7 name=__codelineno-36-7 href=#__codelineno-36-7></a><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>model</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; велосипед має&quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>color</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; колір&quot;</span><span class=p>;</span>
</span><span id=__span-36-8><a id=__codelineno-36-8 name=__codelineno-36-8 href=#__codelineno-36-8></a><span class=p>};</span>
</span></code></pre></div> <p>В той час як класи ES6 можуть бути визначені як альтернатива</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-37-1><a id=__codelineno-37-1 name=__codelineno-37-1 href=#__codelineno-37-1></a><span class=kd>class</span><span class=w> </span><span class=nx>Bike</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-37-2><a id=__codelineno-37-2 name=__codelineno-37-2 href=#__codelineno-37-2></a><span class=w>  </span><span class=kr>constructor</span><span class=p>(</span><span class=nx>color</span><span class=p>,</span><span class=w> </span><span class=nx>model</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-37-3><a id=__codelineno-37-3 name=__codelineno-37-3 href=#__codelineno-37-3></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=nx>color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>color</span>
</span><span id=__span-37-4><a id=__codelineno-37-4 name=__codelineno-37-4 href=#__codelineno-37-4></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=nx>model</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>model</span><span class=p>;</span>
</span><span id=__span-37-5><a id=__codelineno-37-5 name=__codelineno-37-5 href=#__codelineno-37-5></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-37-6><a id=__codelineno-37-6 name=__codelineno-37-6 href=#__codelineno-37-6></a>
</span><span id=__span-37-7><a id=__codelineno-37-7 name=__codelineno-37-7 href=#__codelineno-37-7></a><span class=w>  </span><span class=nx>getDetails</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-37-8><a id=__codelineno-37-8 name=__codelineno-37-8 href=#__codelineno-37-8></a><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>model</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; велосипед має&quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>color</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; колір&quot;</span><span class=p>;</span>
</span><span id=__span-37-9><a id=__codelineno-37-9 name=__codelineno-37-9 href=#__codelineno-37-9></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-37-10><a id=__codelineno-37-10 name=__codelineno-37-10 href=#__codelineno-37-10></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=27>27. Що таке замикання<a class=headerlink href=#27 title="Permanent link">&para;</a></h3> <p>Закриття - це поєднання функції та лексичного оточення, в якому ця функція була оголошена, тобто це внутрішня функція, яка має доступ до змінних зовнішньої або охоплюючої функції.Закриття має три ланцюжки області видимості</p> <ol> <li>Власна область видимості, де змінні визначені між фігурними дужками</li> <li>Змінні зовнішньої функції</li> <li>Глобальні змінні</li> </ol> <p>Розглянемо приклад концепції закриття,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-38-1><a id=__codelineno-38-1 name=__codelineno-38-1 href=#__codelineno-38-1></a><span class=kd>function</span><span class=w> </span><span class=nx>Welcome</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-38-2><a id=__codelineno-38-2 name=__codelineno-38-2 href=#__codelineno-38-2></a><span class=w>  </span><span class=kd>var</span><span class=w> </span><span class=nx>greetingInfo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-38-3><a id=__codelineno-38-3 name=__codelineno-38-3 href=#__codelineno-38-3></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>message</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot; &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>name</span><span class=p>);</span>
</span><span id=__span-38-4><a id=__codelineno-38-4 name=__codelineno-38-4 href=#__codelineno-38-4></a><span class=w>  </span><span class=p>};</span>
</span><span id=__span-38-5><a id=__codelineno-38-5 name=__codelineno-38-5 href=#__codelineno-38-5></a><span class=w>  </span><span class=k>return</span><span class=w> </span><span class=nx>greetingInfo</span><span class=p>;</span>
</span><span id=__span-38-6><a id=__codelineno-38-6 name=__codelineno-38-6 href=#__codelineno-38-6></a><span class=p>}</span>
</span><span id=__span-38-7><a id=__codelineno-38-7 name=__codelineno-38-7 href=#__codelineno-38-7></a><span class=kd>var</span><span class=w> </span><span class=nx>myFunction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>Welcome</span><span class=p>(</span><span class=s2>&quot;John&quot;</span><span class=p>);</span>
</span><span id=__span-38-8><a id=__codelineno-38-8 name=__codelineno-38-8 href=#__codelineno-38-8></a><span class=nx>myFunction</span><span class=p>(</span><span class=s2>&quot;Welcome &quot;</span><span class=p>);</span><span class=w> </span><span class=c1>//Output: Welcome John</span>
</span><span id=__span-38-9><a id=__codelineno-38-9 name=__codelineno-38-9 href=#__codelineno-38-9></a><span class=nx>myFunction</span><span class=p>(</span><span class=s2>&quot;Hello Mr.&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>//output: Hello Mr.John</span>
</span></code></pre></div> <p>Як видно з вищенаведеного коду, внутрішня функція (тобто greetingInfo) має доступ до змінних в області видимості зовнішньої функції (тобто Welcome) навіть після того, як зовнішня функція повернулася.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=28>28. Що таке модулі<a class=headerlink href=#28 title="Permanent link">&para;</a></h3> <p>Модулі - це невеликі одиниці незалежного коду, який можна використовувати повторно, а також основа багатьох шаблонів проектування JavaScript. Більшість модулів JavaScript експортують об'єктний літерал, функцію або конструктор</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=29>29. Чому вам потрібні модулі<a class=headerlink href=#29 title="Permanent link">&para;</a></h3> <p>Нижче наведено перелік переваг використання модулів в екосистемі JavaScript</p> <ol> <li>Легкість супроводу</li> <li>Можливість повторного використання</li> <li>Простір імен</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=30-javascript>30. Що таке область видимості в JavaScript<a class=headerlink href=#30-javascript title="Permanent link">&para;</a></h3> <p>Область видимості - це доступність змінних, функцій та об'єктів у певній частині вашого коду під час виконання. Іншими словами, область видимості визначає видимість змінних та інших ресурсів у певних частинах вашого коду.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=31-service-worker>31. Що таке сервісний працівник (service worker)<a class=headerlink href=#31-service-worker title="Permanent link">&para;</a></h3> <p>Сервісний працівник - це, по суті, скрипт (файл JavaScript), який працює у фоновому режимі, окремо від веб-сторінки, і надає функції, які не потребують веб-сторінки або взаємодії з користувачем. Деякі з основних функцій сервісних працівників - це багатий офлайн-досвід (перша розробка веб-додатків в автономному режимі), періодична фонова синхронізація, push-сповіщення, перехоплення та обробка мережевих запитів і програмне керування кешем відповідей.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=32-dom-service-worker>32. Як ви змінюєте DOM, використовуючи сервісний працівник (service worker)<a class=headerlink href=#32-dom-service-worker title="Permanent link">&para;</a></h3> <p>Сервісний працівник не може отримати доступ до DOM безпосередньо. Але він може взаємодіяти зі сторінками, які він контролює, відповідаючи на повідомлення, надіслані через інтерфейс <code>postMessage</code>, і ці сторінки можуть маніпулювати DOM.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=33-service-worker>33. Як ви перевикористовуєте інформацію під час перезапуску сервісного працівника (service worker)<a class=headerlink href=#33-service-worker title="Permanent link">&para;</a></h3> <p>Проблема з сервісним працівником полягає у тому, що він завершується, коли не використовується, і перезапускається, коли він потрібен наступного разу, тому ви не можете покладатися на глобальний стан у обробниках <code>onfetch</code> та <code>onmessage</code> сервісного працівника. У цьому випадку сервісні працівники матимуть доступ до API IndexedDB для збереження та повторного використання після перезапуску.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=34-indexeddb>34. Що таке IndexedDB<a class=headerlink href=#34-indexeddb title="Permanent link">&para;</a></h3> <p>IndexedDB - це низькорівневий API для зберігання на стороні клієнта великих обсягів структурованих даних, включаючи файли/блоки. Цей API використовує індекси для забезпечення високопродуктивного пошуку в цих даних.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=35-web-storage>35. Що таке веб-сховище (web storage)<a class=headerlink href=#35-web-storage title="Permanent link">&para;</a></h3> <p>Веб-сховище - це API, який надає механізм, за допомогою якого браузери можуть зберігати пари ключ/значення локально в браузері користувача, в набагато більш інтуїтивно зрозумілий спосіб, ніж використання файлів cookie. Веб-сховище надає два механізми для зберігання даних на клієнті.</p> <ol> <li><strong>Локальне сховище:</strong> Зберігає дані поточного походження без терміну придатності.</li> <li><strong>Сховище сеансів:</strong> Зберігає дані протягом одного сеансу, і дані втрачаються при закритті вкладки браузера.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=36-post-message>36. Що таке пост-повідомлення (post message)<a class=headerlink href=#36-post-message title="Permanent link">&para;</a></h3> <p>Пост-повідомлення - це метод, який забезпечує перехресний зв'язок між об'єктами Window (наприклад, між сторінкою і спливаючим вікном, яке вона породила, або між сторінкою і вбудованим в неї iframe). Як правило, скриптам на різних сторінках дозволяється доступ один до одного, якщо і тільки якщо сторінки дотримуються політики однакового походження (тобто сторінки використовують один і той самий протокол, номер порту та хост).</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=37-cookie>37. Що таке кука (cookie)<a class=headerlink href=#37-cookie title="Permanent link">&para;</a></h3> <p>Файл cookie - це фрагмент даних, який зберігається на вашому комп'ютері для доступу до нього вашим браузером. Файли cookie зберігаються у вигляді пар ключ/значення. Наприклад, ви можете створити файл cookie з ім'ям користувача, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-39-1><a id=__codelineno-39-1 name=__codelineno-39-1 href=#__codelineno-39-1></a><span class=nb>document</span><span class=p>.</span><span class=nx>cookie</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;username=John&quot;</span><span class=p>;</span>
</span></code></pre></div> <p><img alt=Скріншот src=images/cookie.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=38-cookie>38. Чому вам потрібна кука (cookie)<a class=headerlink href=#38-cookie title="Permanent link">&para;</a></h3> <p>Файли cookie використовуються для запам'ятовування інформації про профіль користувача (наприклад, ім'я користувача). В основному це відбувається в два етапи,</p> <ol> <li>Коли користувач відвідує веб-сторінку, профіль користувача може бути збережений у файлі cookie.</li> <li>Наступного разу, коли користувач відвідає сторінку, файл cookie запам'ятає профіль користувача.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=39-cookie>39. Які параметри куки (cookie)<a class=headerlink href=#39-cookie title="Permanent link">&para;</a></h3> <p>Нижче наведено кілька варіантів, доступних для файлів cookie,</p> <ol> <li>За замовчуванням, файл cookie видаляється при закритті браузера, але ви можете змінити цю поведінку, встановивши дату закінчення терміну дії (за часом UTC).</li> </ol> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-40-1><a id=__codelineno-40-1 name=__codelineno-40-1 href=#__codelineno-40-1></a><span class=nb>document</span><span class=p>.</span><span class=nx>cookie</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;username=John; expires=Sat, 10 Jun 2023 10:00:00 UTC&quot;</span><span class=p>;</span>
</span></code></pre></div> <ol> <li>За замовчуванням файл cookie належить поточній сторінці. Але ви можете вказати браузеру, до якого шляху належить файл cookie, за допомогою параметра path.</li> </ol> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-41-1><a id=__codelineno-41-1 name=__codelineno-41-1 href=#__codelineno-41-1></a><span class=nb>document</span><span class=p>.</span><span class=nx>cookie</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;username=John; path=/services&quot;</span><span class=p>;</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=40-cookie>40. Як видаляти куку (cookie)<a class=headerlink href=#40-cookie title="Permanent link">&para;</a></h3> <p>Ви можете видалити файл cookie, встановивши дату закінчення терміну дії як минулу дату. У цьому випадку вам не потрібно вказувати значення файлу cookie. Наприклад, ви можете видалити файл cookie імені користувача на поточній сторінці, як показано нижче.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-42-1><a id=__codelineno-42-1 name=__codelineno-42-1 href=#__codelineno-42-1></a><span class=nb>document</span><span class=p>.</span><span class=nx>cookie</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;&quot;</span><span class=p>;</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Ви повинні вказати шлях до файлу cookie, щоб переконатися, що ви видаляєте правильний файл cookie. Деякі браузери не дозволяють видаляти файли cookie, якщо ви не вкажете параметр шляху.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=41-local-storage-session-storage>41. Яка різниця між кукою, локальним сховищем та сеансовим сховищем (local storage та session storage)<a class=headerlink href=#41-local-storage-session-storage title="Permanent link">&para;</a></h3> <p>Нижче наведено деякі відмінності між файлами cookie, локальним сховищем і сховищем сеансів,</p> <table> <thead> <tr> <th>Функція</th> <th>Cookie</th> <th>Локальне сховище</th> <th>Сховище сеансів</th> </tr> </thead> <tbody> <tr> <td>Доступ на стороні клієнта або сервера</td> <td>Як на стороні сервера, так і на стороні клієнта</td> <td>Тільки на стороні клієнта</td> <td>Тільки на стороні клієнта</td> </tr> <tr> <td>Термін дії</td> <td>Як налаштовано за допомогою параметра Термін дії</td> <td>до видалення</td> <td>до закриття вкладки</td> </tr> <tr> <td>Підтримка SSL</td> <td>Підтримується</td> <td>Підтримується</td> <td>Не підтримується</td> </tr> <tr> <td>Максимальний розмір даних</td> <td>4 КБ</td> <td>5 МБ</td> <td>5 МБ</td> </tr> </tbody> </table> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=42-localstorage-sessionstorage>42. Яка основна різниця між localStorage та sessionStorage<a class=headerlink href=#42-localstorage-sessionstorage title="Permanent link">&para;</a></h3> <p>LocalStorage - це те ж саме, що і SessionStorage, але воно зберігає дані, навіть коли браузер закривається і відкривається знову (тобто не має терміну придатності), тоді як у sessionStorage дані очищаються після завершення сеансу роботи зі сторінкою.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=43-web-storage>43. Як отримати доступ до веб-сховища (web storage)<a class=headerlink href=#43-web-storage title="Permanent link">&para;</a></h3> <p>Об'єкт Window реалізує об'єкти <code>WindowLocalStorage</code> та <code>WindowSessionStorage</code>, які мають властивості <code>localStorage</code> (window.localStorage) та <code>essionStorage</code> (window.sessionStorage) відповідно. Ці властивості створюють екземпляр об'єкта Storage, за допомогою якого можна встановлювати, отримувати і видаляти елементи даних для певного домену і типу сховища (сеансового або локального). Наприклад, ви можете читати і писати на локальних об'єктах сховища, як показано нижче</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-43-1><a id=__codelineno-43-1 name=__codelineno-43-1 href=#__codelineno-43-1></a><span class=nx>localStorage</span><span class=p>.</span><span class=nx>setItem</span><span class=p>(</span><span class=s2>&quot;logo&quot;</span><span class=p>,</span><span class=w> </span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&quot;logo&quot;</span><span class=p>).</span><span class=nx>value</span><span class=p>);</span>
</span><span id=__span-43-2><a id=__codelineno-43-2 name=__codelineno-43-2 href=#__codelineno-43-2></a><span class=nx>localStorage</span><span class=p>.</span><span class=nx>getItem</span><span class=p>(</span><span class=s2>&quot;logo&quot;</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=44-session-storage>44. Які методи доступні для сеансового сховища (session storage)<a class=headerlink href=#44-session-storage title="Permanent link">&para;</a></h3> <p>У сховищі сесій передбачено методи для читання, запису та очищення даних сесії:</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-44-1><a id=__codelineno-44-1 name=__codelineno-44-1 href=#__codelineno-44-1></a><span class=c1>// Зберегти дані в sessionStorage</span>
</span><span id=__span-44-2><a id=__codelineno-44-2 name=__codelineno-44-2 href=#__codelineno-44-2></a><span class=nx>sessionStorage</span><span class=p>.</span><span class=nx>setItem</span><span class=p>(</span><span class=s2>&quot;key&quot;</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;value&quot;</span><span class=p>);</span>
</span><span id=__span-44-3><a id=__codelineno-44-3 name=__codelineno-44-3 href=#__codelineno-44-3></a>
</span><span id=__span-44-4><a id=__codelineno-44-4 name=__codelineno-44-4 href=#__codelineno-44-4></a><span class=c1>// Отримати збережені дані зі сховища sessionStorage</span>
</span><span id=__span-44-5><a id=__codelineno-44-5 name=__codelineno-44-5 href=#__codelineno-44-5></a><span class=kd>let</span><span class=w> </span><span class=nx>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>sessionStorage</span><span class=p>.</span><span class=nx>getItem</span><span class=p>(</span><span class=s2>&quot;key&quot;</span><span class=p>);</span>
</span><span id=__span-44-6><a id=__codelineno-44-6 name=__codelineno-44-6 href=#__codelineno-44-6></a>
</span><span id=__span-44-7><a id=__codelineno-44-7 name=__codelineno-44-7 href=#__codelineno-44-7></a><span class=c1>// Видалити збережені дані зі сховища sessionStorage</span>
</span><span id=__span-44-8><a id=__codelineno-44-8 name=__codelineno-44-8 href=#__codelineno-44-8></a><span class=nx>sessionStorage</span><span class=p>.</span><span class=nx>removeItem</span><span class=p>(</span><span class=s2>&quot;key&quot;</span><span class=p>);</span>
</span><span id=__span-44-9><a id=__codelineno-44-9 name=__codelineno-44-9 href=#__codelineno-44-9></a>
</span><span id=__span-44-10><a id=__codelineno-44-10 name=__codelineno-44-10 href=#__codelineno-44-10></a><span class=c1>// Видалити усі збережені дані зі сховища sessionStorage</span>
</span><span id=__span-44-11><a id=__codelineno-44-11 name=__codelineno-44-11 href=#__codelineno-44-11></a><span class=nx>sessionStorage</span><span class=p>.</span><span class=nx>clear</span><span class=p>();</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=45-storage-event-event-handler>45. Що таке подія сховища (storage event) та його обробник події (event handler)<a class=headerlink href=#45-storage-event-event-handler title="Permanent link">&para;</a></h3> <p>StorageEvent - це подія, яка спрацьовує, коли змінюється область зберігання у контексті іншого документа. Тоді як властивість onstorage є обробником подій для обробки подій зберігання. Синтаксис буде наступним</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-45-1><a id=__codelineno-45-1 name=__codelineno-45-1 href=#__codelineno-45-1></a><span class=nb>window</span><span class=p>.</span><span class=nx>onstorage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>functionRef</span><span class=p>;</span>
</span></code></pre></div> <p>Розглянемо приклад використання обробника подій onstorage, який реєструє ключ сховища та його значення</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-46-1><a id=__codelineno-46-1 name=__codelineno-46-1 href=#__codelineno-46-1></a><span class=nb>window</span><span class=p>.</span><span class=nx>onstorage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-46-2><a id=__codelineno-46-2 name=__codelineno-46-2 href=#__codelineno-46-2></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span>
</span><span id=__span-46-3><a id=__codelineno-46-3 name=__codelineno-46-3 href=#__codelineno-46-3></a><span class=w>    </span><span class=s2>&quot;The &quot;</span><span class=w> </span><span class=o>+</span>
</span><span id=__span-46-4><a id=__codelineno-46-4 name=__codelineno-46-4 href=#__codelineno-46-4></a><span class=w>      </span><span class=nx>e</span><span class=p>.</span><span class=nx>key</span><span class=w> </span><span class=o>+</span>
</span><span id=__span-46-5><a id=__codelineno-46-5 name=__codelineno-46-5 href=#__codelineno-46-5></a><span class=w>      </span><span class=s2>&quot; ключ був змінений з &quot;</span><span class=w> </span><span class=o>+</span>
</span><span id=__span-46-6><a id=__codelineno-46-6 name=__codelineno-46-6 href=#__codelineno-46-6></a><span class=w>      </span><span class=nx>e</span><span class=p>.</span><span class=nx>oldValue</span><span class=w> </span><span class=o>+</span>
</span><span id=__span-46-7><a id=__codelineno-46-7 name=__codelineno-46-7 href=#__codelineno-46-7></a><span class=w>      </span><span class=s2>&quot; на &quot;</span><span class=w> </span><span class=o>+</span>
</span><span id=__span-46-8><a id=__codelineno-46-8 name=__codelineno-46-8 href=#__codelineno-46-8></a><span class=w>      </span><span class=nx>e</span><span class=p>.</span><span class=nx>newValue</span><span class=w> </span><span class=o>+</span>
</span><span id=__span-46-9><a id=__codelineno-46-9 name=__codelineno-46-9 href=#__codelineno-46-9></a><span class=w>      </span><span class=s2>&quot;.&quot;</span>
</span><span id=__span-46-10><a id=__codelineno-46-10 name=__codelineno-46-10 href=#__codelineno-46-10></a><span class=w>  </span><span class=p>);</span>
</span><span id=__span-46-11><a id=__codelineno-46-11 name=__codelineno-46-11 href=#__codelineno-46-11></a><span class=p>};</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=46-web-storage>46. Чому вам потрібне веб-сховище (web storage)<a class=headerlink href=#46-web-storage title="Permanent link">&para;</a></h3> <p>Веб-сховище більш безпечне, і великі обсяги даних можна зберігати локально, не впливаючи на продуктивність веб-сайту. Крім того, інформація ніколи не передається на сервер. Тому це більш рекомендований підхід, ніж використання файлів cookie.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=47-browser-support>47. Як перевірити підтримку веб-сховища браузером (browser support)<a class=headerlink href=#47-browser-support title="Permanent link">&para;</a></h3> <p>Перед використанням веб-сховища необхідно перевірити підтримку браузером localStorage і sessionStorage,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-47-1><a id=__codelineno-47-1 name=__codelineno-47-1 href=#__codelineno-47-1></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>Storage</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=s2>&quot;undefined&quot;</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-47-2><a id=__codelineno-47-2 name=__codelineno-47-2 href=#__codelineno-47-2></a><span class=w>  </span><span class=c1>// Код для localStorage/sessionStorage.</span>
</span><span id=__span-47-3><a id=__codelineno-47-3 name=__codelineno-47-3 href=#__codelineno-47-3></a><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-47-4><a id=__codelineno-47-4 name=__codelineno-47-4 href=#__codelineno-47-4></a><span class=w>  </span><span class=c1>// Вибачте! Веб-сховище не підтримується..</span>
</span><span id=__span-47-5><a id=__codelineno-47-5 name=__codelineno-47-5 href=#__codelineno-47-5></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=48-browser-support>48. Як перевірити підтримку веб-працівників браузером (browser support)<a class=headerlink href=#48-browser-support title="Permanent link">&para;</a></h3> <p>Перш ніж використовувати веб-працівники, потрібно перевірити підтримку браузером</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-48-1><a id=__codelineno-48-1 name=__codelineno-48-1 href=#__codelineno-48-1></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>Worker</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=s2>&quot;undefined&quot;</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-48-2><a id=__codelineno-48-2 name=__codelineno-48-2 href=#__codelineno-48-2></a><span class=w>  </span><span class=c1>// код підтримки веб-працівників.</span>
</span><span id=__span-48-3><a id=__codelineno-48-3 name=__codelineno-48-3 href=#__codelineno-48-3></a><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-48-4><a id=__codelineno-48-4 name=__codelineno-48-4 href=#__codelineno-48-4></a><span class=w>  </span><span class=c1>// Вибачте! Підтримки Web Worker немає..</span>
</span><span id=__span-48-5><a id=__codelineno-48-5 name=__codelineno-48-5 href=#__codelineno-48-5></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=49-web-worker>49. Надайте приклад веб-працівника (web worker)<a class=headerlink href=#49-web-worker title="Permanent link">&para;</a></h3> <p>Вам потрібно виконати наступні кроки, щоб почати використовувати веб-працівників для прикладу підрахунку</p> <ol> <li>Створіть файл веб-програми: Вам потрібно написати скрипт для збільшення значення лічильника. Назвемо його counter.js</li> </ol> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-49-1><a id=__codelineno-49-1 name=__codelineno-49-1 href=#__codelineno-49-1></a><span class=nx>нехай</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0</span><span class=p>;</span>
</span><span id=__span-49-2><a id=__codelineno-49-2 name=__codelineno-49-2 href=#__codelineno-49-2></a>
</span><span id=__span-49-3><a id=__codelineno-49-3 name=__codelineno-49-3 href=#__codelineno-49-3></a><span class=kd>function</span><span class=w> </span><span class=nx>timedCount</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-49-4><a id=__codelineno-49-4 name=__codelineno-49-4 href=#__codelineno-49-4></a><span class=w>  </span><span class=nx>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mf>1</span><span class=p>;</span>
</span><span id=__span-49-5><a id=__codelineno-49-5 name=__codelineno-49-5 href=#__codelineno-49-5></a><span class=w>  </span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span>
</span><span id=__span-49-6><a id=__codelineno-49-6 name=__codelineno-49-6 href=#__codelineno-49-6></a><span class=w>  </span><span class=nx>setTimeout</span><span class=p>(</span><span class=s2>&quot;timedCount()&quot;</span><span class=p>,</span><span class=w> </span><span class=mf>500</span><span class=p>);</span>
</span><span id=__span-49-7><a id=__codelineno-49-7 name=__codelineno-49-7 href=#__codelineno-49-7></a><span class=p>}</span>
</span><span id=__span-49-8><a id=__codelineno-49-8 name=__codelineno-49-8 href=#__codelineno-49-8></a>
</span><span id=__span-49-9><a id=__codelineno-49-9 name=__codelineno-49-9 href=#__codelineno-49-9></a><span class=nx>timedCount</span><span class=p>();</span>
</span></code></pre></div> <p>Тут метод postMessage() використовується для відправки повідомлення назад на HTML-сторінку</p> <ol> <li>Створіть об'єкт веб-сервера: Ви можете створити об'єкт веб-працівника, перевіривши підтримку браузером. Назвемо цей файл web_worker_example.js</li> </ol> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-50-1><a id=__codelineno-50-1 name=__codelineno-50-1 href=#__codelineno-50-1></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>w</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s2>&quot;undefined&quot;</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-50-2><a id=__codelineno-50-2 name=__codelineno-50-2 href=#__codelineno-50-2></a><span class=w>  </span><span class=nx>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Worker</span><span class=p>(</span><span class=s2>&quot;counter.js&quot;</span><span class=p>);</span>
</span><span id=__span-50-3><a id=__codelineno-50-3 name=__codelineno-50-3 href=#__codelineno-50-3></a><span class=p>}</span>
</span></code></pre></div> <p>і ми можемо отримувати повідомлення від web worker</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-51-1><a id=__codelineno-51-1 name=__codelineno-51-1 href=#__codelineno-51-1></a><span class=nx>w</span><span class=p>.</span><span class=nx>onmessage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-51-2><a id=__codelineno-51-2 name=__codelineno-51-2 href=#__codelineno-51-2></a><span class=w>  </span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&quot;message&quot;</span><span class=p>).</span><span class=nx>innerHTML</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>;</span>
</span><span id=__span-51-3><a id=__codelineno-51-3 name=__codelineno-51-3 href=#__codelineno-51-3></a><span class=p>};</span>
</span></code></pre></div> <ol> <li>Завершити роботу веб-працівника: Веб-засоби продовжуватимуть прослуховувати повідомлення (навіть після завершення роботи зовнішнього скрипту), доки їх не буде завершено. Ви можете використовувати метод terminate() для завершення прослуховування повідомлень.</li> </ol> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-52-1><a id=__codelineno-52-1 name=__codelineno-52-1 href=#__codelineno-52-1></a><span class=nx>w</span><span class=p>.</span><span class=nx>terminate</span><span class=p>();</span>
</span></code></pre></div> <ol> <li>Повторне використання веб-працівника: Якщо ви встановите для змінної worker значення undefined, ви можете повторно використовувати код</li> </ol> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-53-1><a id=__codelineno-53-1 name=__codelineno-53-1 href=#__codelineno-53-1></a><span class=nx>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>undefined</span><span class=p>;</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=50-dom>50. Які обмеження веб-працівників на DOM<a class=headerlink href=#50-dom title="Permanent link">&para;</a></h3> <p>WebWorker не має доступу до нижченаведених об'єктів javascript, оскільки вони визначені у зовнішніх файлах</p> <ol> <li>Об'єкт вікна</li> <li>Об'єкт документа</li> <li>Батьківський об'єкт</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=51-promise>51. Що таке обіцянка (promise)<a class=headerlink href=#51-promise title="Permanent link">&para;</a></h3> <p>Обіцянка - це об'єкт, який може створити єдине значення колись у майбутньому, або з вирішеним значенням, або з причиною, чому воно не вирішене (наприклад, мережева помилка). Обіцянка перебуватиме в одному з 3 можливих станів: виконана, відхилена або в очікуванні.</p> <p>Синтаксис створення обіцянки виглядає наступним чином,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-54-1><a id=__codelineno-54-1 name=__codelineno-54-1 href=#__codelineno-54-1></a><span class=kd>const</span><span class=w> </span><span class=nx>promise</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span><span class=w> </span><span class=nx>reject</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-54-2><a id=__codelineno-54-2 name=__codelineno-54-2 href=#__codelineno-54-2></a><span class=w>  </span><span class=c1>// опис обіцянки</span>
</span><span id=__span-54-3><a id=__codelineno-54-3 name=__codelineno-54-3 href=#__codelineno-54-3></a><span class=p>});</span>
</span></code></pre></div> <p>Використання обіцянки буде таким, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-55-1><a id=__codelineno-55-1 name=__codelineno-55-1 href=#__codelineno-55-1></a><span class=kd>const</span><span class=w> </span><span class=nx>promise</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nb>Promise</span><span class=p>()</span>
</span><span id=__span-55-2><a id=__codelineno-55-2 name=__codelineno-55-2 href=#__codelineno-55-2></a><span class=w>  </span><span class=p>(</span><span class=nx>resolve</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-55-3><a id=__codelineno-55-3 name=__codelineno-55-3 href=#__codelineno-55-3></a><span class=w>    </span><span class=nx>setTimeout</span><span class=p>(()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-55-4><a id=__codelineno-55-4 name=__codelineno-55-4 href=#__codelineno-55-4></a><span class=w>      </span><span class=nx>resolve</span><span class=p>(</span><span class=s2>&quot;Я - обіцянка!&quot;</span><span class=p>);</span>
</span><span id=__span-55-5><a id=__codelineno-55-5 name=__codelineno-55-5 href=#__codelineno-55-5></a><span class=w>    </span><span class=p>},</span><span class=w> </span><span class=mf>5000</span><span class=p>);</span>
</span><span id=__span-55-6><a id=__codelineno-55-6 name=__codelineno-55-6 href=#__codelineno-55-6></a><span class=w>  </span><span class=p>},</span>
</span><span id=__span-55-7><a id=__codelineno-55-7 name=__codelineno-55-7 href=#__codelineno-55-7></a><span class=w>  </span><span class=p>(</span><span class=nx>reject</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{}</span>
</span><span id=__span-55-8><a id=__codelineno-55-8 name=__codelineno-55-8 href=#__codelineno-55-8></a><span class=p>);</span>
</span><span id=__span-55-9><a id=__codelineno-55-9 name=__codelineno-55-9 href=#__codelineno-55-9></a>
</span><span id=__span-55-10><a id=__codelineno-55-10 name=__codelineno-55-10 href=#__codelineno-55-10></a><span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>));</span>
</span></code></pre></div> <p>Потік дій обіцянки буде таким, як показано нижче,</p> <p><img alt=Скріншот src=images/promises.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=52-promise>52. Чому вам потрібна обіцянка (promise)<a class=headerlink href=#52-promise title="Permanent link">&para;</a></h3> <p>Обіцянки використовуються для обробки асинхронних операцій. Вони забезпечують альтернативний підхід до зворотних викликів, зменшуючи пекло зворотних викликів і дозволяючи писати чистіший код.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=53-promise>53. Які три стани у обіцянки (promise)<a class=headerlink href=#53-promise title="Permanent link">&para;</a></h3> <p>Обіцянки мають три стани:</p> <ol> <li><strong>Очікує:</strong> Це початковий стан обіцянки перед початком операції</li> <li><strong>Виконано:</strong> Цей стан означає, що вказана операція була завершена.</li> <li><strong>Відхилено:</strong> Цей стан вказує на те, що операція не була виконана. У цьому випадку буде викинуто значення помилки.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=54-callback-function>54. Що таке зворотний виклик (callback function)<a class=headerlink href=#54-callback-function title="Permanent link">&para;</a></h3> <p>Функція зворотного виклику - це функція, яка передається в іншу функцію як аргумент. Ця функція викликається всередині зовнішньої функції для виконання певної дії. Розглянемо простий приклад використання функції зворотного виклику</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-56-1><a id=__codelineno-56-1 name=__codelineno-56-1 href=#__codelineno-56-1></a><span class=kd>function</span><span class=w> </span><span class=nx>callbackFunction</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-56-2><a id=__codelineno-56-2 name=__codelineno-56-2 href=#__codelineno-56-2></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Hello &quot;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>name</span><span class=p>);</span>
</span><span id=__span-56-3><a id=__codelineno-56-3 name=__codelineno-56-3 href=#__codelineno-56-3></a><span class=p>}</span>
</span><span id=__span-56-4><a id=__codelineno-56-4 name=__codelineno-56-4 href=#__codelineno-56-4></a>
</span><span id=__span-56-5><a id=__codelineno-56-5 name=__codelineno-56-5 href=#__codelineno-56-5></a><span class=kd>function</span><span class=w> </span><span class=nx>outerFunction</span><span class=p>(</span><span class=nx>callback</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-56-6><a id=__codelineno-56-6 name=__codelineno-56-6 href=#__codelineno-56-6></a><span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=nx>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>prompt</span><span class=p>(</span><span class=s2>&quot;Будь ласка, введіть ваше ім&#39;я.&quot;</span><span class=p>);</span>
</span><span id=__span-56-7><a id=__codelineno-56-7 name=__codelineno-56-7 href=#__codelineno-56-7></a><span class=w>  </span><span class=nx>callback</span><span class=p>(</span><span class=nx>name</span><span class=p>);</span>
</span><span id=__span-56-8><a id=__codelineno-56-8 name=__codelineno-56-8 href=#__codelineno-56-8></a><span class=p>}</span>
</span><span id=__span-56-9><a id=__codelineno-56-9 name=__codelineno-56-9 href=#__codelineno-56-9></a>
</span><span id=__span-56-10><a id=__codelineno-56-10 name=__codelineno-56-10 href=#__codelineno-56-10></a><span class=nx>outerFunction</span><span class=p>(</span><span class=nx>callbackFunction</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=55-callbacks>55. Чому нам потрібні зворотні виклики (callbacks)<a class=headerlink href=#55-callbacks title="Permanent link">&para;</a></h3> <p>Функції зворотного виклику потрібні тому, що javascript - це мова, керована подіями. Це означає, що замість того, щоб чекати на відповідь, javascript буде продовжувати виконання, слухаючи інші події. Розглянемо приклад з першою функцією, яка викликає виклик API (імітований за допомогою setTimeout), і наступною функцією, яка записує повідомлення в журнал.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-57-1><a id=__codelineno-57-1 name=__codelineno-57-1 href=#__codelineno-57-1></a><span class=kd>function</span><span class=w> </span><span class=nx>firstFunction</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-57-2><a id=__codelineno-57-2 name=__codelineno-57-2 href=#__codelineno-57-2></a><span class=w>  </span><span class=c1>// Імітуємо затримку коду</span>
</span><span id=__span-57-3><a id=__codelineno-57-3 name=__codelineno-57-3 href=#__codelineno-57-3></a><span class=w>  </span><span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// Імітуємо затримку коду.</span>
</span><span id=__span-57-4><a id=__codelineno-57-4 name=__codelineno-57-4 href=#__codelineno-57-4></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Викликано першу функцію&quot;</span><span class=p>);</span>
</span><span id=__span-57-5><a id=__codelineno-57-5 name=__codelineno-57-5 href=#__codelineno-57-5></a><span class=w>  </span><span class=p>},</span><span class=w> </span><span class=mf>1000</span><span class=p>);</span>
</span><span id=__span-57-6><a id=__codelineno-57-6 name=__codelineno-57-6 href=#__codelineno-57-6></a><span class=p>}</span>
</span><span id=__span-57-7><a id=__codelineno-57-7 name=__codelineno-57-7 href=#__codelineno-57-7></a><span class=kd>function</span><span class=w> </span><span class=nx>secondFunction</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-57-8><a id=__codelineno-57-8 name=__codelineno-57-8 href=#__codelineno-57-8></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;Викликано другу функцію&quot;</span><span class=p>);</span>
</span><span id=__span-57-9><a id=__codelineno-57-9 name=__codelineno-57-9 href=#__codelineno-57-9></a><span class=p>}</span>
</span><span id=__span-57-10><a id=__codelineno-57-10 name=__codelineno-57-10 href=#__codelineno-57-10></a><span class=nx>firstFunction</span><span class=p>();</span>
</span><span id=__span-57-11><a id=__codelineno-57-11 name=__codelineno-57-11 href=#__codelineno-57-11></a><span class=nx>secondFunction</span><span class=p>();</span>
</span><span id=__span-57-12><a id=__codelineno-57-12 name=__codelineno-57-12 href=#__codelineno-57-12></a>
</span><span id=__span-57-13><a id=__codelineno-57-13 name=__codelineno-57-13 href=#__codelineno-57-13></a><span class=nx>Вивести</span><span class=p>;</span>
</span><span id=__span-57-14><a id=__codelineno-57-14 name=__codelineno-57-14 href=#__codelineno-57-14></a><span class=c1>// Викликано другу функцію</span>
</span><span id=__span-57-15><a id=__codelineno-57-15 name=__codelineno-57-15 href=#__codelineno-57-15></a><span class=c1>// Викликана перша функція</span>
</span></code></pre></div> <p>Як видно з виводу, javascript не дочекався відповіді першої функції і виконав блок коду, що залишився. Таким чином, функція зворотного виклику використовується для того, щоб переконатися, що певний код не виконується, доки інший код не завершить виконання.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=56-callback-hell>56. Що таке "інферно зворотніх викликів" (callback hell)<a class=headerlink href=#56-callback-hell title="Permanent link">&para;</a></h3> <p>Пекло зворотного виклику - це антипатерн з декількома вкладеними зворотними викликами, який ускладнює читання та налагодження коду при роботі з асинхронною логікою. Пекло зворотних викликів виглядає наступним чином,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-58-1><a id=__codelineno-58-1 name=__codelineno-58-1 href=#__codelineno-58-1></a><span class=nx>async1</span><span class=p>(</span><span class=kd>function</span><span class=p>(){</span>
</span><span id=__span-58-2><a id=__codelineno-58-2 name=__codelineno-58-2 href=#__codelineno-58-2></a><span class=w>    </span><span class=nx>async2</span><span class=p>(</span><span class=kd>function</span><span class=p>(){</span>
</span><span id=__span-58-3><a id=__codelineno-58-3 name=__codelineno-58-3 href=#__codelineno-58-3></a><span class=w>        </span><span class=nx>async3</span><span class=p>(</span><span class=kd>function</span><span class=p>(){</span>
</span><span id=__span-58-4><a id=__codelineno-58-4 name=__codelineno-58-4 href=#__codelineno-58-4></a><span class=w>            </span><span class=nx>async4</span><span class=p>(</span><span class=kd>function</span><span class=p>(){</span>
</span><span id=__span-58-5><a id=__codelineno-58-5 name=__codelineno-58-5 href=#__codelineno-58-5></a><span class=w>                </span><span class=p>....</span>
</span><span id=__span-58-6><a id=__codelineno-58-6 name=__codelineno-58-6 href=#__codelineno-58-6></a><span class=w>            </span><span class=p>});</span>
</span><span id=__span-58-7><a id=__codelineno-58-7 name=__codelineno-58-7 href=#__codelineno-58-7></a><span class=w>        </span><span class=p>});</span>
</span><span id=__span-58-8><a id=__codelineno-58-8 name=__codelineno-58-8 href=#__codelineno-58-8></a><span class=w>    </span><span class=p>});</span>
</span><span id=__span-58-9><a id=__codelineno-58-9 name=__codelineno-58-9 href=#__codelineno-58-9></a><span class=p>});</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=57-server-sent-events>57. Що таке події, відправлені з сервера (server-sent events)<a class=headerlink href=#57-server-sent-events title="Permanent link">&para;</a></h3> <p>Події, що надсилаються сервером (SSE) - це технологія server push, яка дозволяє браузеру отримувати автоматичні оновлення від сервера через HTTP-з'єднання, не вдаючись до опитування. Це односторонній канал зв'язку - події передаються лише від сервера до клієнта. Ця технологія використовується в оновленнях Facebook/Twitter, оновленнях біржових котирувань, новинних стрічках тощо.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=58-server-sent-events>58. Як ви отримуєте повідомлення подій, відправлених з сервера (server-sent events)<a class=headerlink href=#58-server-sent-events title="Permanent link">&para;</a></h3> <p>Об’єкт EventSource використовується для отримання сповіщень про події, надісланих сервером. Наприклад, ви можете отримувати повідомлення від сервера, як показано нижче: <div class="language-javascript highlight"><pre><span></span><code><span id=__span-59-1><a id=__codelineno-59-1 name=__codelineno-59-1 href=#__codelineno-59-1></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>EventSource</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=s2>&quot;undefined&quot;</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-59-2><a id=__codelineno-59-2 name=__codelineno-59-2 href=#__codelineno-59-2></a><span class=w>  </span><span class=kd>var</span><span class=w> </span><span class=nx>source</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>EventSource</span><span class=p>(</span><span class=s2>&quot;sse_generator.js&quot;</span><span class=p>);</span>
</span><span id=__span-59-3><a id=__codelineno-59-3 name=__codelineno-59-3 href=#__codelineno-59-3></a><span class=w>  </span><span class=nx>source</span><span class=p>.</span><span class=nx>onmessage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>event</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-59-4><a id=__codelineno-59-4 name=__codelineno-59-4 href=#__codelineno-59-4></a><span class=w>    </span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&quot;output&quot;</span><span class=p>).</span><span class=nx>innerHTML</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s2>&quot;&lt;br&gt;&quot;</span><span class=p>;</span>
</span><span id=__span-59-5><a id=__codelineno-59-5 name=__codelineno-59-5 href=#__codelineno-59-5></a><span class=w>  </span><span class=p>};</span>
</span><span id=__span-59-6><a id=__codelineno-59-6 name=__codelineno-59-6 href=#__codelineno-59-6></a><span class=p>}</span>
</span></code></pre></div></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=59-server-sent-events>59. Як перевірити підтримку браузером для подій, відправлених з сервера (server-sent events)<a class=headerlink href=#59-server-sent-events title="Permanent link">&para;</a></h3> <p>Ви можете перевірити підтримку браузером подій, що надсилаються сервером, перед їх використанням, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-60-1><a id=__codelineno-60-1 name=__codelineno-60-1 href=#__codelineno-60-1></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>EventSource</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=s2>&quot;undefined&quot;</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-60-2><a id=__codelineno-60-2 name=__codelineno-60-2 href=#__codelineno-60-2></a><span class=w>  </span><span class=c1>// Підтримуються події, відправлені сервером. Давайте напишемо код!</span>
</span><span id=__span-60-3><a id=__codelineno-60-3 name=__codelineno-60-3 href=#__codelineno-60-3></a><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-60-4><a id=__codelineno-60-4 name=__codelineno-60-4 href=#__codelineno-60-4></a><span class=w>  </span><span class=c1>// Не підтримуються події, що надсилаються сервером</span>
</span><span id=__span-60-5><a id=__codelineno-60-5 name=__codelineno-60-5 href=#__codelineno-60-5></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=60-server-sent-events>60. Які події доступні для подій, відправлених з сервера (server-sent events)<a class=headerlink href=#60-server-sent-events title="Permanent link">&para;</a></h3> <p>Нижче наведено список подій, доступних для подій, що надсилаються сервером</p> <table> <thead> <tr> <th>Подія</th> <th>Опис</th> </tr> </thead> <tbody> <tr> <td>onopen</td> <td>Використовується, коли відкривається з'єднання з сервером</td> </tr> <tr> <td>onmessage</td> <td>Ця подія використовується при отриманні повідомлення</td> </tr> <tr> <td>onerror</td> <td>Відбувається при виникненні помилки</td> </tr> </tbody> </table> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=61-server-sent-events>61. Які події доступні для подій, відправлених з сервера (server-sent events)<a class=headerlink href=#61-server-sent-events title="Permanent link">&para;</a></h3> <p>Обіцянка повинна відповідати певному набору правил:</p> <ol> <li>Обіцянка - це об'єкт, який надає стандартний метод <code>.then()</code>.</li> <li>Обіцянка, що очікує на виконання, може перейти в стан виконаної або відхиленої</li> <li>Виконана або відхилена обіцянка є завершеною і не повинна переходити в будь-який інший стан.</li> <li>Після того, як обіцянка виконана, її значення не повинно змінюватися.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=62-callback-in-callback>62. Що таке зворотній виклик у зворотньому виклику (callback in callback)<a class=headerlink href=#62-callback-in-callback title="Permanent link">&para;</a></h3> <p>Ви можете вкласти один колбек в інший колбек, щоб виконати дії послідовно один за одним. Це називається зворотний виклик у зворотному виклику.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-61-1><a id=__codelineno-61-1 name=__codelineno-61-1 href=#__codelineno-61-1></a><span class=nx>loadScript</span><span class=p>(</span><span class=s2>&quot;/script1.js&quot;</span><span class=p>,</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>script</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-61-2><a id=__codelineno-61-2 name=__codelineno-61-2 href=#__codelineno-61-2></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;завантажено перший скрипт&quot;</span><span class=p>);</span>
</span><span id=__span-61-3><a id=__codelineno-61-3 name=__codelineno-61-3 href=#__codelineno-61-3></a>
</span><span id=__span-61-4><a id=__codelineno-61-4 name=__codelineno-61-4 href=#__codelineno-61-4></a><span class=w>  </span><span class=nx>loadScript</span><span class=p>(</span><span class=s2>&quot;/script2.js&quot;</span><span class=p>,</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>script</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-61-5><a id=__codelineno-61-5 name=__codelineno-61-5 href=#__codelineno-61-5></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;завантажено другий скрипт&quot;</span><span class=p>);</span>
</span><span id=__span-61-6><a id=__codelineno-61-6 name=__codelineno-61-6 href=#__codelineno-61-6></a>
</span><span id=__span-61-7><a id=__codelineno-61-7 name=__codelineno-61-7 href=#__codelineno-61-7></a><span class=w>    </span><span class=nx>loadScript</span><span class=p>(</span><span class=s2>&quot;/script3.js&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>функція</span><span class=w> </span><span class=p>(</span><span class=nx>скрипт</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-61-8><a id=__codelineno-61-8 name=__codelineno-61-8 href=#__codelineno-61-8></a><span class=w>      </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;завантажено третій скрипт&quot;</span><span class=p>);</span>
</span><span id=__span-61-9><a id=__codelineno-61-9 name=__codelineno-61-9 href=#__codelineno-61-9></a><span class=w>      </span><span class=c1>// після завантаження всіх скриптів</span>
</span><span id=__span-61-10><a id=__codelineno-61-10 name=__codelineno-61-10 href=#__codelineno-61-10></a><span class=w>    </span><span class=p>});</span>
</span><span id=__span-61-11><a id=__codelineno-61-11 name=__codelineno-61-11 href=#__codelineno-61-11></a><span class=w>  </span><span class=p>});</span>
</span><span id=__span-61-12><a id=__codelineno-61-12 name=__codelineno-61-12 href=#__codelineno-61-12></a><span class=p>});</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=63-promise-chaining>63. Що таке ланцюг обіцянок (promise chaining)<a class=headerlink href=#63-promise-chaining title="Permanent link">&para;</a></h3> <p>Процес виконання послідовності асинхронних завдань одне за одним з використанням обіцянок називається ланцюжком обіцянок (Promise chaining). Розглянемо приклад ланцюжка обіцянок для обчислення кінцевого результату,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-62-1><a id=__codelineno-62-1 name=__codelineno-62-1 href=#__codelineno-62-1></a><span class=ow>new</span><span class=w> </span><span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span><span class=w> </span><span class=nx>reject</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-62-2><a id=__codelineno-62-2 name=__codelineno-62-2 href=#__codelineno-62-2></a><span class=w>  </span><span class=nx>setTimeout</span><span class=p>(()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>resolve</span><span class=p>(</span><span class=mf>1</span><span class=p>),</span><span class=w> </span><span class=mf>1000</span><span class=p>);</span>
</span><span id=__span-62-3><a id=__codelineno-62-3 name=__codelineno-62-3 href=#__codelineno-62-3></a><span class=p>})</span>
</span><span id=__span-62-4><a id=__codelineno-62-4 name=__codelineno-62-4 href=#__codelineno-62-4></a><span class=w>  </span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>result</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-62-5><a id=__codelineno-62-5 name=__codelineno-62-5 href=#__codelineno-62-5></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span><span class=w> </span><span class=c1>// 1</span>
</span><span id=__span-62-6><a id=__codelineno-62-6 name=__codelineno-62-6 href=#__codelineno-62-6></a><span class=w>    </span><span class=nx>повернути</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mf>2</span><span class=p>;</span>
</span><span id=__span-62-7><a id=__codelineno-62-7 name=__codelineno-62-7 href=#__codelineno-62-7></a><span class=w>  </span><span class=p>})</span>
</span><span id=__span-62-8><a id=__codelineno-62-8 name=__codelineno-62-8 href=#__codelineno-62-8></a><span class=w>  </span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>result</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-62-9><a id=__codelineno-62-9 name=__codelineno-62-9 href=#__codelineno-62-9></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span><span class=w> </span><span class=c1>// 2</span>
</span><span id=__span-62-10><a id=__codelineno-62-10 name=__codelineno-62-10 href=#__codelineno-62-10></a><span class=w>    </span><span class=nx>повернути</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mf>3</span><span class=p>;</span>
</span><span id=__span-62-11><a id=__codelineno-62-11 name=__codelineno-62-11 href=#__codelineno-62-11></a><span class=w>  </span><span class=p>})</span>
</span><span id=__span-62-12><a id=__codelineno-62-12 name=__codelineno-62-12 href=#__codelineno-62-12></a><span class=w>  </span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>result</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-62-13><a id=__codelineno-62-13 name=__codelineno-62-13 href=#__codelineno-62-13></a><span class=w>    </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span><span class=w> </span><span class=c1>// 6</span>
</span><span id=__span-62-14><a id=__codelineno-62-14 name=__codelineno-62-14 href=#__codelineno-62-14></a><span class=w>    </span><span class=nx>повернути</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mf>4</span><span class=p>;</span>
</span><span id=__span-62-15><a id=__codelineno-62-15 name=__codelineno-62-15 href=#__codelineno-62-15></a><span class=w>  </span><span class=p>});</span>
</span></code></pre></div> <p>У вищенаведених обробниках результат передається в ланцюжок обробників .then() з наведеним нижче алгоритмом роботи,</p> <ol> <li>Початкова обіцянка виконується за 1 секунду,</li> <li>Після цього викликається обробник <code>.then</code>, який записує результат(1) і повертає обіцянку зі значенням result * 2.</li> <li>Після цього значення передається наступному обробнику <code>.then</code>, який записує result(2) і повертає обіцянку зі значенням result * 3.</li> <li>Нарешті, значення передається останньому обробнику <code>.then</code>, який записує результат(6) і повертає обіцянку з результатом * 4.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=64-promiseall>64. Що таке promise.all<a class=headerlink href=#64-promiseall title="Permanent link">&para;</a></h3> <p>Promise.all - це обіцянка, яка отримує на вхід масив обіцянок (ітерабельний масив) і повертає результат, коли виконано всі обіцянки або відхилено будь-яку з них. Наприклад, синтаксис методу promise.all наведено нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-63-1><a id=__codelineno-63-1 name=__codelineno-63-1 href=#__codelineno-63-1></a><span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span><span class=nx>Promise1</span><span class=p>,</span><span class=w> </span><span class=nx>Promise2</span><span class=p>,</span><span class=w> </span><span class=nx>Promise3</span><span class=p>])</span><span class=w> </span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>)</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=p>.</span><span class=k>catch</span><span class=p>(</span><span class=nx>error</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`Помилка в обіцянках </span><span class=si>${</span><span class=nx>error</span><span class=si>}</span><span class=sb>`</span><span class=p>))</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Пам'ятайте, що порядок обіцянок (виведення результату) зберігається відповідно до порядку введення.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=65-race-promise>65. Яка мета методу race у обіцянок (promise)<a class=headerlink href=#65-race-promise title="Permanent link">&para;</a></h3> <p>Метод promise.race() повертає екземпляр обіцянки, який першим буде вирішено або відхилено. Розглянемо приклад методу race(), в якому першим обробляється promise2</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-64-1><a id=__codelineno-64-1 name=__codelineno-64-1 href=#__codelineno-64-1></a><span class=kd>var</span><span class=w> </span><span class=nx>promise1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span><span class=w> </span><span class=nx>reject</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-64-2><a id=__codelineno-64-2 name=__codelineno-64-2 href=#__codelineno-64-2></a><span class=w>  </span><span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span><span class=w> </span><span class=mf>500</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;one&quot;</span><span class=p>);</span>
</span><span id=__span-64-3><a id=__codelineno-64-3 name=__codelineno-64-3 href=#__codelineno-64-3></a><span class=p>});</span>
</span><span id=__span-64-4><a id=__codelineno-64-4 name=__codelineno-64-4 href=#__codelineno-64-4></a><span class=kd>var</span><span class=w> </span><span class=nx>promise2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span><span class=w> </span><span class=nx>reject</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-64-5><a id=__codelineno-64-5 name=__codelineno-64-5 href=#__codelineno-64-5></a><span class=w>  </span><span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span><span class=w> </span><span class=mf>100</span><span class=p>,</span><span class=w> </span><span class=s2>&quot;two&quot;</span><span class=p>);</span>
</span><span id=__span-64-6><a id=__codelineno-64-6 name=__codelineno-64-6 href=#__codelineno-64-6></a><span class=p>});</span>
</span><span id=__span-64-7><a id=__codelineno-64-7 name=__codelineno-64-7 href=#__codelineno-64-7></a>
</span><span id=__span-64-8><a id=__codelineno-64-8 name=__codelineno-64-8 href=#__codelineno-64-8></a><span class=nb>Promise</span><span class=p>.</span><span class=nx>race</span><span class=p>([</span><span class=nx>promise1</span><span class=p>,</span><span class=w> </span><span class=nx>promise2</span><span class=p>]).</span><span class=nx>then</span><span class=p>(</span><span class=kd>function</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-64-9><a id=__codelineno-64-9 name=__codelineno-64-9 href=#__codelineno-64-9></a><span class=w>  </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>);</span><span class=w> </span><span class=c1>// &quot;two&quot; // Обидві обіцянки вирішаться, але promise2 швидше</span>
</span><span id=__span-64-10><a id=__codelineno-64-10 name=__codelineno-64-10 href=#__codelineno-64-10></a><span class=p>});</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=66-javascript-strict-mode>66. Що таке строгий режим у JavaScript (strict mode)<a class=headerlink href=#66-javascript-strict-mode title="Permanent link">&para;</a></h3> <p>Суворий режим - це нова функція в ECMAScript 5, яка дозволяє помістити програму або функцію в "суворий" робочий контекст. Таким чином, він запобігає виконанню певних дій і генерує більше винятків. Буквальний вираз <code>"use strict";</code> вказує браузеру використовувати код javascript в строгому режимі.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=67-strict-mode>67. Чому вам потрібен строгий режим (strict mode)<a class=headerlink href=#67-strict-mode title="Permanent link">&para;</a></h3> <p>Суворий режим корисний для написання "безпечного" JavaScript, перетворюючи "поганий синтаксис" на реальні помилки. Наприклад, він усуває випадкове створення глобальної змінної, видаючи помилку, а також видає помилку при присвоюванні властивості, яку не можна записати, властивості, доступної лише для отримання, неіснуючої властивості, неіснуючої змінної або неіснуючого об'єкта.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=68-strict-mode>68. Як ви оголошуєте строгий режим (strict mode)<a class=headerlink href=#68-strict-mode title="Permanent link">&para;</a></h3> <p>Строгий режим оголошується додаванням "use strict"; на початку скрипту або функції. Якщо його оголошено на початку скрипта, він має глобальну область видимості.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-65-1><a id=__codelineno-65-1 name=__codelineno-65-1 href=#__codelineno-65-1></a><span class=s2>&quot;use strict&quot;</span><span class=p>;</span>
</span><span id=__span-65-2><a id=__codelineno-65-2 name=__codelineno-65-2 href=#__codelineno-65-2></a><span class=nx>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.14</span><span class=p>;</span><span class=w> </span><span class=c1>// Це призведе до помилки, оскільки x не оголошено</span>
</span></code></pre></div> <p>а якщо оголосити всередині функції, то вона має локальну область видимості</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-66-1><a id=__codelineno-66-1 name=__codelineno-66-1 href=#__codelineno-66-1></a><span class=nx>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.14</span><span class=p>;</span><span class=w> </span><span class=c1>// Це не викличе помилки.</span>
</span><span id=__span-66-2><a id=__codelineno-66-2 name=__codelineno-66-2 href=#__codelineno-66-2></a><span class=nx>myFunction</span><span class=p>();</span>
</span><span id=__span-66-3><a id=__codelineno-66-3 name=__codelineno-66-3 href=#__codelineno-66-3></a>
</span><span id=__span-66-4><a id=__codelineno-66-4 name=__codelineno-66-4 href=#__codelineno-66-4></a><span class=kd>function</span><span class=w> </span><span class=nx>myFunction</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-66-5><a id=__codelineno-66-5 name=__codelineno-66-5 href=#__codelineno-66-5></a><span class=w>  </span><span class=s2>&quot;use strict&quot;</span><span class=p>;</span>
</span><span id=__span-66-6><a id=__codelineno-66-6 name=__codelineno-66-6 href=#__codelineno-66-6></a><span class=w>  </span><span class=nx>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>3.14</span><span class=p>;</span><span class=w> </span><span class=c1>// Це викличе помилку</span>
</span><span id=__span-66-7><a id=__codelineno-66-7 name=__codelineno-66-7 href=#__codelineno-66-7></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=69-double-exclamation>69. Яка мета подвійного оклику (!!) (double exclamation)<a class=headerlink href=#69-double-exclamation title="Permanent link">&para;</a></h3> <p>Вигук double або заперечення(!!) гарантує, що результуючий тип буде логічним. Якщо він був хибним (наприклад, 0, null, undefined і т.д.), він буде хибним, в іншому випадку - істинним. Наприклад, ви можете перевірити версію IE, використовуючи цей вираз, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-67-1><a id=__codelineno-67-1 name=__codelineno-67-1 href=#__codelineno-67-1></a><span class=kd>let</span><span class=w> </span><span class=nx>isIE8</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span>
</span><span id=__span-67-2><a id=__codelineno-67-2 name=__codelineno-67-2 href=#__codelineno-67-2></a><span class=nx>isIE8</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>!!</span><span class=w> </span><span class=nx>navigator</span><span class=p>.</span><span class=nx>userAgent</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=sr>/MSIE 8.0/</span><span class=p>);</span>
</span><span id=__span-67-3><a id=__codelineno-67-3 name=__codelineno-67-3 href=#__codelineno-67-3></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>isIE8</span><span class=p>);</span><span class=w> </span><span class=c1>// повертає true або false</span>
</span></code></pre></div> <p>Якщо ви не використовуєте цей вираз, то він повертає початкове значення.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-68-1><a id=__codelineno-68-1 name=__codelineno-68-1 href=#__codelineno-68-1></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>navigator</span><span class=p>.</span><span class=nx>userAgent</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=sr>/MSIE 8.0/</span><span class=p>));</span><span class=w> </span><span class=c1>// повертає масив або null</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Вираз !! не є оператором, але це просто двічі оператор !</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=70-delete>70. Яка мета оператора delete<a class=headerlink href=#70-delete title="Permanent link">&para;</a></h3> <p>Ключове слово delete використовується для видалення властивості та її значення.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-69-1><a id=__codelineno-69-1 name=__codelineno-69-1 href=#__codelineno-69-1></a><span class=kd>var</span><span class=w> </span><span class=nx>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=nx>name</span><span class=o>:</span><span class=w> </span><span class=s2>&quot;John&quot;</span><span class=p>,</span><span class=w> </span><span class=nx>age</span><span class=o>:</span><span class=w> </span><span class=mf>20</span><span class=w> </span><span class=p>};</span>
</span><span id=__span-69-2><a id=__codelineno-69-2 name=__codelineno-69-2 href=#__codelineno-69-2></a><span class=ow>delete</span><span class=w> </span><span class=nx>user</span><span class=p>.</span><span class=nx>age</span><span class=p>;</span>
</span><span id=__span-69-3><a id=__codelineno-69-3 name=__codelineno-69-3 href=#__codelineno-69-3></a>
</span><span id=__span-69-4><a id=__codelineno-69-4 name=__codelineno-69-4 href=#__codelineno-69-4></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span><span class=w> </span><span class=c1>// {name: &quot;John&quot;}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=71-typeof>71. Який оператор typeof<a class=headerlink href=#71-typeof title="Permanent link">&para;</a></h3> <p>Ви можете використовувати оператор typeof для визначення типу змінної JavaScript. Він повертає тип змінної або виразу.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-70-1><a id=__codelineno-70-1 name=__codelineno-70-1 href=#__codelineno-70-1></a><span class=ow>typeof</span><span class=w> </span><span class=s2>&quot;John Abraham&quot;</span><span class=p>;</span><span class=w> </span><span class=c1>// Повертає &quot;рядок&quot;</span>
</span><span id=__span-70-2><a id=__codelineno-70-2 name=__codelineno-70-2 href=#__codelineno-70-2></a><span class=ow>typeof</span><span class=w> </span><span class=p>(</span><span class=mf>1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mf>2</span><span class=p>);</span><span class=w> </span><span class=c1>// Повертає &quot;число&quot;</span>
</span><span id=__span-70-3><a id=__codelineno-70-3 name=__codelineno-70-3 href=#__codelineno-70-3></a><span class=ow>typeof</span><span class=w> </span><span class=p>[</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=mf>3</span><span class=p>]</span><span class=w> </span><span class=c1>// Повертає &quot;об&#39;єкт&quot;, оскільки всі масиви також є об&#39;єктами</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=72-undefined>72. Що таке властивість undefined<a class=headerlink href=#72-undefined title="Permanent link">&para;</a></h3> <p>Властивість undefined вказує на те, що змінній не присвоєно значення, або вона оголошена, але не ініціалізована взагалі. Тип невизначеного значення також є невизначеним.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-71-1><a id=__codelineno-71-1 name=__codelineno-71-1 href=#__codelineno-71-1></a><span class=kd>var</span><span class=w> </span><span class=nx>user</span><span class=p>;</span><span class=w> </span><span class=c1>// Значення не визначено, тип не визначено</span>
</span><span id=__span-71-2><a id=__codelineno-71-2 name=__codelineno-71-2 href=#__codelineno-71-2></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>user</span><span class=p>);</span><span class=w> </span><span class=c1>//невизначено</span>
</span></code></pre></div> <p>Будь-яку змінну можна очистити, встановивши їй значення undefined.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-72-1><a id=__codelineno-72-1 name=__codelineno-72-1 href=#__codelineno-72-1></a><span class=nx>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>undefined</span><span class=p>;</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=73-null>73. Що таке значення null<a class=headerlink href=#73-null title="Permanent link">&para;</a></h3> <p>Значення null означає навмисну відсутність будь-якого значення об'єкта. Це одне з примітивних значень JavaScript. Тип нульового значення - об'єкт. Ви можете очистити змінну, встановивши значення null.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-73-1><a id=__codelineno-73-1 name=__codelineno-73-1 href=#__codelineno-73-1></a><span class=kd>var</span><span class=w> </span><span class=nx>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span>
</span><span id=__span-73-2><a id=__codelineno-73-2 name=__codelineno-73-2 href=#__codelineno-73-2></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>user</span><span class=p>);</span><span class=w> </span><span class=c1>//об&#39;єкт</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=74-null-undefined>74. Яка різниця між значенням null та undefined<a class=headerlink href=#74-null-undefined title="Permanent link">&para;</a></h3> <p>Нижче наведено основні відмінності між null та undefined,</p> <table> <thead> <tr> <th>Null</th> <th>Undefined</th> </tr> </thead> <tbody> <tr> <td>Це значення присвоєння, яке вказує на те, що змінна вказує на об'єкт, на який немає об'єкта.</td> <td>Це не значення присвоєння, коли змінна оголошена, але їй ще не присвоєно значення.</td> </tr> <tr> <td>Тип null - об'єкт</td> <td>Тип undefined - undefined</td> </tr> <tr> <td>Значення null - це примітивне значення, що представляє нульове, порожнє або неіснуюче посилання. Значення undefined - це примітивне значення, що використовується, коли змінній ще не присвоєно значення.</td> <td>Невизначене значення - це примітивне значення, яке використовується, коли змінній не присвоєно значення.</td> </tr> <tr> <td>Вказує на відсутність значення для змінної</td> <td>Вказує на відсутність самої змінної</td> </tr> <tr> <td>Перетворено в нуль (0) під час виконання примітивних операцій</td> <td>Перетворено в NaN під час виконання примітивних операцій</td> </tr> </tbody> </table> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=75-eval>75. Що таке функція eval<a class=headerlink href=#75-eval title="Permanent link">&para;</a></h3> <p>Функція eval() обчислює JavaScript-код, представлений у вигляді рядка. Рядок може бути виразом JavaScript, змінною, оператором або послідовністю операторів.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-74-1><a id=__codelineno-74-1 name=__codelineno-74-1 href=#__codelineno-74-1></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>eval</span><span class=p>(</span><span class=s2>&quot;1 + 2&quot;</span><span class=p>));</span><span class=w> </span><span class=c1>// 3</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=76-window-document>76. Яка різниця між об'єктом window та document<a class=headerlink href=#76-window-document title="Permanent link">&para;</a></h3> <p>Нижче наведено основні відмінності між вікном і документом,</p> <table> <thead> <tr> <th>Вікно</th> <th>Документ</th> </tr> </thead> <tbody> <tr> <td>Це елемент кореневого рівня на будь-якій веб-сторінці</td> <td>Він є прямим дочірнім елементом віконного об'єкта. Це також відоме як модель об'єктів документа (DOM)</td> </tr> <tr> <td>За замовчуванням об'єкт window доступний неявно на сторінці</td> <td>Ви можете отримати до нього доступ за допомогою window.document або document.</td> </tr> <tr> <td>Він має такі методи, як alert(), confirm(), і такі властивості, як document, location</td> <td>Він надає такі методи, як getElementById, getElementsByTagName, createElement тощо</td> </tr> </tbody> </table> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=77-javascript>77. Як ви отримуєте доступ до історії у JavaScript<a class=headerlink href=#77-javascript title="Permanent link">&para;</a></h3> <p>Об'єкт window.history містить історію браузера. Ви можете завантажити попередні та наступні URL-адреси в історії за допомогою методів back() та next().</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-75-1><a id=__codelineno-75-1 name=__codelineno-75-1 href=#__codelineno-75-1></a><span class=kd>function</span><span class=w> </span><span class=nx>goBack</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-75-2><a id=__codelineno-75-2 name=__codelineno-75-2 href=#__codelineno-75-2></a><span class=w>  </span><span class=nb>window</span><span class=p>.</span><span class=nx>history</span><span class=p>.</span><span class=nx>back</span><span class=p>();</span>
</span><span id=__span-75-3><a id=__codelineno-75-3 name=__codelineno-75-3 href=#__codelineno-75-3></a><span class=p>}</span>
</span><span id=__span-75-4><a id=__codelineno-75-4 name=__codelineno-75-4 href=#__codelineno-75-4></a><span class=kd>function</span><span class=w> </span><span class=nx>goForward</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-75-5><a id=__codelineno-75-5 name=__codelineno-75-5 href=#__codelineno-75-5></a><span class=w>  </span><span class=nb>window</span><span class=p>.</span><span class=nx>history</span><span class=p>.</span><span class=nx>forward</span><span class=p>();</span>
</span><span id=__span-75-6><a id=__codelineno-75-6 name=__codelineno-75-6 href=#__codelineno-75-6></a><span class=p>}</span>
</span></code></pre></div> <p><strong>Примітка:</strong> Ви також можете отримати доступ до історії без префікса window.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=78-caps-lock>78. Як ви визначаєте, чи включена клавіша Caps Lock, чи ні<a class=headerlink href=#78-caps-lock title="Permanent link">&para;</a></h3> <p>Подія <code>mouseEvent getModifierState()</code> використовується для повернення булевого значення, яке вказує, чи активовано вказану клавішу-модифікатор, чи ні. Такі модифікатори, як CapsLock, ScrollLock і NumLock активуються при натисканні на них, і деактивуються при повторному натисканні.</p> <p>Розглянемо на прикладі вхідного елемента, щоб визначити поведінку ввімкненого/вимкненого CapsLock,</p> <div class="language-html highlight"><pre><span></span><code><span id=__span-76-1><a id=__codelineno-76-1 name=__codelineno-76-1 href=#__codelineno-76-1></a><span class=p>&lt;</span><span class=nt>input</span> <span class=na>type</span><span class=o>=</span><span class=s>&quot;password&quot;</span> <span class=na>onmousedown</span><span class=o>=</span><span class=s>&quot;enterInput(event)&quot;</span> <span class=p>/&gt;</span>
</span><span id=__span-76-2><a id=__codelineno-76-2 name=__codelineno-76-2 href=#__codelineno-76-2></a>
</span><span id=__span-76-3><a id=__codelineno-76-3 name=__codelineno-76-3 href=#__codelineno-76-3></a><span class=p>&lt;</span><span class=nt>p</span> <span class=na>id</span><span class=o>=</span><span class=s>&quot;feedback&quot;</span><span class=p>&gt;&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span><span id=__span-76-4><a id=__codelineno-76-4 name=__codelineno-76-4 href=#__codelineno-76-4></a>
</span><span id=__span-76-5><a id=__codelineno-76-5 name=__codelineno-76-5 href=#__codelineno-76-5></a><span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
</span><span id=__span-76-6><a id=__codelineno-76-6 name=__codelineno-76-6 href=#__codelineno-76-6></a><span class=w>  </span><span class=kd>function</span><span class=w> </span><span class=nx>enterInput</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-76-7><a id=__codelineno-76-7 name=__codelineno-76-7 href=#__codelineno-76-7></a><span class=w>    </span><span class=kd>var</span><span class=w> </span><span class=nx>flag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>e</span><span class=p>.</span><span class=nx>getModifierState</span><span class=p>(</span><span class=s2>&quot;CapsLock&quot;</span><span class=p>);</span>
</span><span id=__span-76-8><a id=__codelineno-76-8 name=__codelineno-76-8 href=#__codelineno-76-8></a><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>flag</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-76-9><a id=__codelineno-76-9 name=__codelineno-76-9 href=#__codelineno-76-9></a><span class=w>      </span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&quot;feedback&quot;</span><span class=p>).</span><span class=nx>innerHTML</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;CapsLock активовано&quot;</span><span class=p>;</span>
</span><span id=__span-76-10><a id=__codelineno-76-10 name=__codelineno-76-10 href=#__codelineno-76-10></a><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-76-11><a id=__codelineno-76-11 name=__codelineno-76-11 href=#__codelineno-76-11></a><span class=w>      </span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&quot;feedback&quot;</span><span class=p>).</span><span class=nx>innerHTML</span><span class=w> </span><span class=o>=</span>
</span><span id=__span-76-12><a id=__codelineno-76-12 name=__codelineno-76-12 href=#__codelineno-76-12></a><span class=w>        </span><span class=s2>&quot;CapsLock не активовано&quot;</span><span class=p>;</span>
</span><span id=__span-76-13><a id=__codelineno-76-13 name=__codelineno-76-13 href=#__codelineno-76-13></a><span class=w>    </span><span class=p>}</span>
</span><span id=__span-76-14><a id=__codelineno-76-14 name=__codelineno-76-14 href=#__codelineno-76-14></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-76-15><a id=__codelineno-76-15 name=__codelineno-76-15 href=#__codelineno-76-15></a><span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=79-isnan>79. Що таке функція isNaN<a class=headerlink href=#79-isnan title="Permanent link">&para;</a></h3> <p>Функція isNaN() використовується для визначення того, чи є значення недопустимим числом (Not-a-Number) чи ні. Тобто, ця функція повертає true, якщо значення дорівнює NaN. В іншому випадку повертається false.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-77-1><a id=__codelineno-77-1 name=__codelineno-77-1 href=#__codelineno-77-1></a><span class=nb>isNaN</span><span class=p>(</span><span class=s2>&quot;Hello&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>//істина</span>
</span><span id=__span-77-2><a id=__codelineno-77-2 name=__codelineno-77-2 href=#__codelineno-77-2></a><span class=nb>isNaN</span><span class=p>(</span><span class=s2>&quot;100&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>//false</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=80-undefined>80. Яка різниця між змінними, які не оголошені, та змінними, які мають значення undefined<a class=headerlink href=#80-undefined title="Permanent link">&para;</a></h3> <p>Нижче наведено основні відмінності між неоголошеними (не визначеними) та невизначеними змінними,</p> <table> <thead> <tr> <th>undeclared</th> <th>undefined</th> </tr> </thead> <tbody> <tr> <td>Ці змінні не існують у програмі і не оголошені</td> <td>Ці змінні оголошені у програмі, але їм не присвоєно жодного значення</td> </tr> <tr> <td>При спробі прочитати значення неоголошеної змінної виникає помилка виконання програми</td> <td>При спробі прочитати значення невизначеної змінної повертається невизначене значення.</td> </tr> </tbody> </table> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=81>81. Що таке глобальні змінні<a class=headerlink href=#81 title="Permanent link">&para;</a></h3> <p>Глобальні змінні - це змінні, які доступні по всьому коду без обмеження області видимості. Для оголошення локальної змінної використовується ключове слово var, але якщо його опустити, то вона стане глобальною змінною</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-78-1><a id=__codelineno-78-1 name=__codelineno-78-1 href=#__codelineno-78-1></a><span class=nx>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&quot;Hello&quot;</span><span class=p>;</span><span class=w> </span><span class=c1>// var пропущено, вона стає глобальною змінною</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=82>82. Які проблеми із глобальними змінними<a class=headerlink href=#82 title="Permanent link">&para;</a></h3> <p>Проблема глобальних змінних полягає у конфлікті імен змінних локальної та глобальної області видимості. Також складно налагоджувати і тестувати код, який використовує глобальні змінні.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=83-nan>83. Що таке властивість NaN<a class=headerlink href=#83-nan title="Permanent link">&para;</a></h3> <p>Властивість NaN - це глобальна властивість, яка представляє значення "Не-число", тобто вказує на те, що значення не є дійсним числом. Дуже рідко використовують NaN у програмі, але його можна використовувати як значення, що повертається, у кількох випадках</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-79-1><a id=__codelineno-79-1 name=__codelineno-79-1 href=#__codelineno-79-1></a><span class=nb>Math</span><span class=p>.</span><span class=nx>sqrt</span><span class=p>(</span><span class=o>-</span><span class=mf>1</span><span class=p>);</span>
</span><span id=__span-79-2><a id=__codelineno-79-2 name=__codelineno-79-2 href=#__codelineno-79-2></a><span class=nb>parseInt</span><span class=p>(</span><span class=s2>&quot;Hello&quot;</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=84-isfinite>84. Яка мета функції isFinite<a class=headerlink href=#84-isfinite title="Permanent link">&para;</a></h3> <p>Функція isFinite() використовується для визначення того, чи є число скінченним, законним числом. Вона повертає false, якщо значення +нескінченність, -нескінченність або NaN (Not-a-Number), інакше повертає true.</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-80-1><a id=__codelineno-80-1 name=__codelineno-80-1 href=#__codelineno-80-1></a><span class=nb>isFinite</span><span class=p>(</span><span class=kc>Infinity</span><span class=p>);</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-80-2><a id=__codelineno-80-2 name=__codelineno-80-2 href=#__codelineno-80-2></a><span class=nb>isFinite</span><span class=p>(</span><span class=kc>NaN</span><span class=p>);</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-80-3><a id=__codelineno-80-3 name=__codelineno-80-3 href=#__codelineno-80-3></a><span class=nb>isFinite</span><span class=p>(</span><span class=o>-</span><span class=kc>Infinity</span><span class=p>);</span><span class=w> </span><span class=c1>// false</span>
</span><span id=__span-80-4><a id=__codelineno-80-4 name=__codelineno-80-4 href=#__codelineno-80-4></a>
</span><span id=__span-80-5><a id=__codelineno-80-5 name=__codelineno-80-5 href=#__codelineno-80-5></a><span class=nb>isFinite</span><span class=p>(</span><span class=mf>100</span><span class=p>);</span><span class=w> </span><span class=c1>// true</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=85-event-flow>85. Що таке потік подій (event flow)<a class=headerlink href=#85-event-flow title="Permanent link">&para;</a></h3> <p>Потік подій - це порядок надходження подій на веб-сторінку. Коли ви клацаєте елемент, вкладений в інші елементи, перш ніж ваш клік досягне місця призначення або цільового елемента, він повинен викликати подію кліку для кожного з його батьківських елементів, починаючи зверху з глобального об'єкта вікна. Існує два способи проходження події</p> <ol> <li>Зверху вниз (перехоплення події)</li> <li>Знизу догори (бульбашковий потік подій)</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=86-event-bubbling>86. Що таке всплиття подій (event bubbling)<a class=headerlink href=#86-event-bubbling title="Permanent link">&para;</a></h3> <p>Розповсюдження подій - це тип поширення подій, коли подія спочатку спрацьовує на внутрішньому цільовому елементі, а потім послідовно спрацьовує на предках (батьках) цільового елемента в тій самій ієрархії вкладеності, доки не досягне зовнішнього DOM-елемента.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=87-event-capturing>87. Що таке захоплення подій (event capturing)<a class=headerlink href=#87-event-capturing title="Permanent link">&para;</a></h3> <p>Захоплення події - це тип поширення події, коли подія спочатку захоплюється зовнішнім елементом, а потім послідовно спрацьовує на нащадках (дочірніх елементах) цільового елемента в тій самій ієрархії вкладеності, доки не досягне найпотаємнішого елемента DOM.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=88-javascript>88. Як ви відправляєте форму за допомогою JavaScript<a class=headerlink href=#88-javascript title="Permanent link">&para;</a></h3> <p>Ви можете відправити форму за допомогою <code>document.forms[0].submit()</code>. Вся інформація з форми надсилається за допомогою обробника події onsubmit</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-81-1><a id=__codelineno-81-1 name=__codelineno-81-1 href=#__codelineno-81-1></a><span class=kd>function</span><span class=w> </span><span class=nx>submit</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-81-2><a id=__codelineno-81-2 name=__codelineno-81-2 href=#__codelineno-81-2></a><span class=w>  </span><span class=nb>document</span><span class=p>.</span><span class=nx>forms</span><span class=p>[</span><span class=mf>0</span><span class=p>].</span><span class=nx>submit</span><span class=p>();</span>
</span><span id=__span-81-3><a id=__codelineno-81-3 name=__codelineno-81-3 href=#__codelineno-81-3></a><span class=p>}</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=89>89. Як ви знаходите деталі операційної системи<a class=headerlink href=#89 title="Permanent link">&para;</a></h3> <p>Об'єкт window.navigator містить інформацію про особливості операційної системи браузера відвідувача. Деякі з властивостей операційної системи доступні у розділі властивостей платформи,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-82-1><a id=__codelineno-82-1 name=__codelineno-82-1 href=#__codelineno-82-1></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>navigator</span><span class=p>.</span><span class=nx>platform</span><span class=p>);</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=90-document-load-domcontentloaded>90. Яка різниця між подіями document load та DOMContentLoaded<a class=headerlink href=#90-document-load-domcontentloaded title="Permanent link">&para;</a></h3> <p>Подія <code>DOMContentLoaded</code> спрацьовує, коли початковий HTML-документ повністю завантажено і проаналізовано, не чекаючи на завершення завантаження ресурсів (таблиць стилів, зображень і підкадрів). Тоді як подія load спрацьовує, коли завантажується вся сторінка, включаючи всі залежні ресурси (таблиці стилів, зображення).</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=91-native-host-user>91. Яка різниця між вбудованими (native), господарськими (host) та користувацькими (user) об'єктами<a class=headerlink href=#91-native-host-user title="Permanent link">&para;</a></h3> <p>"Нативні об'єкти" - це об'єкти, які є частиною мови JavaScript, визначені специфікацією ECMAScript. Наприклад, String, Math, RegExp, Object, Function та інші основні об'єкти, визначені в специфікації ECMAScript. "Хост-об'єкти" - це об'єкти, що надаються браузером або середовищем виконання (Node). Наприклад, вікно, XmlHttpRequest, DOM-вузли тощо вважаються хост-об'єктами. Користувацькі об'єкти - це об'єкти, визначені в javascript-коді. Наприклад, об'єкти User, створені для інформації про профіль.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=92-javascript>92. Які інструменти або техніки використовуються для відлагодження коду JavaScript<a class=headerlink href=#92-javascript title="Permanent link">&para;</a></h3> <p>Для налагодження JavaScript можна використовувати наступні інструменти або методи</p> <ol> <li>Chrome Devtools</li> <li>оператор відладчика</li> <li>Старий добрий оператор console.log</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=93-promises-callbacks>93. Які переваги та недоліки обіцянок (promises) порівняно зі зворотніми викликами (callbacks)<a class=headerlink href=#93-promises-callbacks title="Permanent link">&para;</a></h3> <p>Нижче наведено перелік переваг та недоліків обіцянок над зворотними викликами,</p> <p><strong>Плюси:</strong></p> <ol> <li>Це дозволяє уникнути пекла зворотних дзвінків, які неможливо прочитати</li> <li>Легко писати послідовний асинхронний код з .then()</li> <li>Легко писати паралельний асинхронний код з Promise.all()</li> <li>Вирішує деякі з поширених проблем зворотного виклику (виклик занадто пізно, занадто рано, багато разів і ковтання помилок/винятків)</li> </ol> <p><strong>Можливі недоліки</strong></p> <ol> <li>Мало складного коду</li> <li>Потрібно завантажувати поліфіл, якщо ES6 не підтримується</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=94-property>94. Яка різниця між атрибутом та властивістю (property)<a class=headerlink href=#94-property title="Permanent link">&para;</a></h3> <p>Атрибути визначаються в HTML-розмітці, тоді як властивості визначаються в DOM. Наприклад, наведений нижче HTML-елемент має 2 атрибути type і value,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-83-1><a id=__codelineno-83-1 name=__codelineno-83-1 href=#__codelineno-83-1></a><span class=o>&lt;</span><span class=nx>input</span><span class=w> </span><span class=nx>type</span><span class=o>=</span><span class=s2>&quot;text&quot;</span><span class=w> </span><span class=nx>value</span><span class=o>=</span><span class=s2>&quot;Name:&quot;</span><span class=o>&gt;</span>
</span></code></pre></div> <p>Ви можете отримати значення атрибута, як показано нижче,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-84-1><a id=__codelineno-84-1 name=__codelineno-84-1 href=#__codelineno-84-1></a><span class=kd>const</span><span class=w> </span><span class=nx>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>document</span><span class=p>.</span><span class=nx>querySelector</span><span class=p>(</span><span class=s2>&quot;input&quot;</span><span class=p>);</span>
</span><span id=__span-84-2><a id=__codelineno-84-2 name=__codelineno-84-2 href=#__codelineno-84-2></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>input</span><span class=p>.</span><span class=nx>getAttribute</span><span class=p>(</span><span class=s2>&quot;value&quot;</span><span class=p>));</span><span class=w> </span><span class=c1>// Доброго ранку</span>
</span><span id=__span-84-3><a id=__codelineno-84-3 name=__codelineno-84-3 href=#__codelineno-84-3></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>input</span><span class=p>.</span><span class=nx>value</span><span class=p>);</span><span class=w> </span><span class=c1>// Good morning</span>
</span></code></pre></div> <p>And after you change the value of the text field to "Good evening", it becomes like</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-85-1><a id=__codelineno-85-1 name=__codelineno-85-1 href=#__codelineno-85-1></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>input</span><span class=p>.</span><span class=nx>getAttribute</span><span class=p>(</span><span class=s2>&quot;value&quot;</span><span class=p>));</span><span class=w> </span><span class=c1>// Good evening</span>
</span><span id=__span-85-2><a id=__codelineno-85-2 name=__codelineno-85-2 href=#__codelineno-85-2></a><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>input</span><span class=p>.</span><span class=nx>value</span><span class=p>);</span><span class=w> </span><span class=c1>// Good evening</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=95-same-origin-policy>95. Що таке політика однакового походження (same-origin policy)<a class=headerlink href=#95-same-origin-policy title="Permanent link">&para;</a></h3> <p>Політика однакового походження - це політика, яка не дозволяє JavaScript робити запити через межі домену. Походження визначається як комбінація схеми URI, імені хоста і номера порту. Якщо ви ввімкнете цю політику, вона не дозволить шкідливому скрипту на одній сторінці отримати доступ до конфіденційних даних на іншій веб-сторінці за допомогою моделі об'єктів документа (DOM).</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=96-void-0>96. Яка мета фрази void 0<a class=headerlink href=#96-void-0 title="Permanent link">&para;</a></h3> <p>Void(0) is used to prevent the page from refreshing. This will be helpful to eliminate the unwanted side-effect, because it will return the undefined primitive value. It is commonly used for HTML documents that use href="JavaScript:Void(0);" within an <code>&lt;a&gt;</code> element. i.e, when you click a link, the browser loads a new page or refreshes the same page. But this behavior will be prevented using this expression. For example, the below link notify the message without reloading the page <div class="language-javascript highlight"><pre><span></span><code><span id=__span-86-1><a id=__codelineno-86-1 name=__codelineno-86-1 href=#__codelineno-86-1></a><span class=o>&lt;</span><span class=nx>a</span><span class=w> </span><span class=nx>href</span><span class=o>=</span><span class=s2>&quot;JavaScript:void(0);&quot;</span><span class=w> </span><span class=nx>onclick</span><span class=o>=</span><span class=s2>&quot;alert(&#39;Well done!&#39;)&quot;</span><span class=o>&gt;</span>
</span><span id=__span-86-2><a id=__codelineno-86-2 name=__codelineno-86-2 href=#__codelineno-86-2></a><span class=w>  </span><span class=nx>Click</span><span class=w> </span><span class=nx>Me</span><span class=o>!</span>
</span><span id=__span-86-3><a id=__codelineno-86-3 name=__codelineno-86-3 href=#__codelineno-86-3></a><span class=o>&lt;</span><span class=err>/a&gt;</span>
</span></code></pre></div></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=97-javascript>97. Чи є JavaScript компільованою чи інтерпретованою мовою<a class=headerlink href=#97-javascript title="Permanent link">&para;</a></h3> <p>JavaScript - это интерпретируемый, а не компилируемый язык. Интерпретатор в браузере считывает код JavaScript, интерпретирует каждую строку и запускает его на выполнение. В настоящее время в современных браузерах используется технология Just-In-Time (JIT) компиляции, которая компилирует JavaScript в исполняемый байт-код непосредственно в момент его запуска.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=98-javascript>98. Чи є JavaScript чутливою до регістру мовою<a class=headerlink href=#98-javascript title="Permanent link">&para;</a></h3> <p>Так, JavaScript - це мова, чутлива до регістру. Ключові слова мови, змінні, назви функцій та об'єктів, а також будь-які інші ідентифікатори завжди повинні вводитися з великої літери.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=99-java-javascript>99. Чи існує якась зв'язок між Java та JavaScript<a class=headerlink href=#99-java-javascript title="Permanent link">&para;</a></h3> <p>Ні, це абсолютно різні мови програмування і не мають нічого спільного між собою. Але обидві вони є об'єктно-орієнтованими мовами програмування і, як і багато інших мов, мають схожий синтаксис для основних функцій (if, else, for, switch, break, continue і т.д.).</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=100-events>100. Що таке події (events)<a class=headerlink href=#100-events title="Permanent link">&para;</a></h3> <p>Події - це "речі", які відбуваються з елементами HTML. Коли JavaScript використовується на HTML-сторінках, він може "реагувати" на ці події. Ось деякі приклади подій HTML,</p> <ol> <li>Веб-сторінка завершила завантаження</li> <li>Змінено поле введення</li> <li>Кнопка була натиснута</li> </ol> <p>Опишемо поведінку події кліку для елемента button,</p> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-87-1><a id=__codelineno-87-1 name=__codelineno-87-1 href=#__codelineno-87-1></a><span class=w> </span><span class=o>&lt;!</span><span class=nx>doctype</span><span class=w> </span><span class=nx>html</span><span class=o>&gt;</span>
</span><span id=__span-87-2><a id=__codelineno-87-2 name=__codelineno-87-2 href=#__codelineno-87-2></a><span class=w> </span><span class=o>&lt;</span><span class=nx>html</span><span class=o>&gt;</span>
</span><span id=__span-87-3><a id=__codelineno-87-3 name=__codelineno-87-3 href=#__codelineno-87-3></a><span class=w>  </span><span class=o>&lt;</span><span class=nx>head</span><span class=o>&gt;</span>
</span><span id=__span-87-4><a id=__codelineno-87-4 name=__codelineno-87-4 href=#__codelineno-87-4></a><span class=w>    </span><span class=o>&lt;</span><span class=nx>script</span><span class=o>&gt;</span>
</span><span id=__span-87-5><a id=__codelineno-87-5 name=__codelineno-87-5 href=#__codelineno-87-5></a><span class=w>      </span><span class=kd>function</span><span class=w> </span><span class=nx>greeting</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-87-6><a id=__codelineno-87-6 name=__codelineno-87-6 href=#__codelineno-87-6></a><span class=w>        </span><span class=nx>alert</span><span class=p>(</span><span class=s1>&#39;Hello! Good morning&#39;</span><span class=p>);</span>
</span><span id=__span-87-7><a id=__codelineno-87-7 name=__codelineno-87-7 href=#__codelineno-87-7></a><span class=w>      </span><span class=p>}</span>
</span><span id=__span-87-8><a id=__codelineno-87-8 name=__codelineno-87-8 href=#__codelineno-87-8></a><span class=w>    </span><span class=o>&lt;</span><span class=err>/script&gt;</span>
</span><span id=__span-87-9><a id=__codelineno-87-9 name=__codelineno-87-9 href=#__codelineno-87-9></a><span class=w>  </span><span class=o>&lt;</span><span class=err>/head&gt;</span>
</span><span id=__span-87-10><a id=__codelineno-87-10 name=__codelineno-87-10 href=#__codelineno-87-10></a><span class=w>  </span><span class=o>&lt;</span><span class=nx>body</span><span class=o>&gt;</span>
</span><span id=__span-87-11><a id=__codelineno-87-11 name=__codelineno-87-11 href=#__codelineno-87-11></a><span class=w>    </span><span class=o>&lt;</span><span class=nx>button</span><span class=w> </span><span class=nx>type</span><span class=o>=</span><span class=s2>&quot;button&quot;</span><span class=w> </span><span class=nx>onclick</span><span class=o>=</span><span class=s2>&quot;greeting()&quot;</span><span class=o>&gt;</span><span class=nx>Click</span><span class=w> </span><span class=nx>me</span><span class=o>&lt;</span><span class=err>/button&gt;</span>
</span><span id=__span-87-12><a id=__codelineno-87-12 name=__codelineno-87-12 href=#__codelineno-87-12></a><span class=w>  </span><span class=o>&lt;</span><span class=err>/body&gt;</span>
</span><span id=__span-87-13><a id=__codelineno-87-13 name=__codelineno-87-13 href=#__codelineno-87-13></a><span class=w> </span><span class=o>&lt;</span><span class=err>/html&gt;</span>
</span><span id=__span-87-14><a id=__codelineno-87-14 name=__codelineno-87-14 href=#__codelineno-87-14></a><span class=w> </span><span class=sb>```</span>
</span><span id=__span-87-15><a id=__codelineno-87-15 name=__codelineno-87-15 href=#__codelineno-87-15></a>
</span><span id=__span-87-16><a id=__codelineno-87-16 name=__codelineno-87-16 href=#__codelineno-87-16></a><span class=sb>---</span>
</span><span id=__span-87-17><a id=__codelineno-87-17 name=__codelineno-87-17 href=#__codelineno-87-17></a>
</span><span id=__span-87-18><a id=__codelineno-87-18 name=__codelineno-87-18 href=#__codelineno-87-18></a><span class=sb># Відповіді - &#39;Java&#39;</span>
</span><span id=__span-87-19><a id=__codelineno-87-19 name=__codelineno-87-19 href=#__codelineno-87-19></a>
</span><span id=__span-87-20><a id=__codelineno-87-20 name=__codelineno-87-20 href=#__codelineno-87-20></a><span class=sb>### 1. Типи даних у Java</span>
</span><span id=__span-87-21><a id=__codelineno-87-21 name=__codelineno-87-21 href=#__codelineno-87-21></a><span class=sb>* boolean - true/false</span>
</span><span id=__span-87-22><a id=__codelineno-87-22 name=__codelineno-87-22 href=#__codelineno-87-22></a><span class=sb>* byte - -128 до 127, 1 байт</span>
</span><span id=__span-87-23><a id=__codelineno-87-23 name=__codelineno-87-23 href=#__codelineno-87-23></a><span class=sb>* short - (+/-)3276(7/8), 2 байти</span>
</span><span id=__span-87-24><a id=__codelineno-87-24 name=__codelineno-87-24 href=#__codelineno-87-24></a><span class=sb>* int - (+/-)214748364(7/8), 4 байти</span>
</span><span id=__span-87-25><a id=__codelineno-87-25 name=__codelineno-87-25 href=#__codelineno-87-25></a><span class=sb>* long - (+/-)9 223 372 036 854 775 80(7/8), 8 байт</span>
</span><span id=__span-87-26><a id=__codelineno-87-26 name=__codelineno-87-26 href=#__codelineno-87-26></a><span class=sb>* double - з плаваючою крапкою, 8 байт</span>
</span><span id=__span-87-27><a id=__codelineno-87-27 name=__codelineno-87-27 href=#__codelineno-87-27></a><span class=sb>* float - із плаваючою крапкою, 4 байти</span>
</span><span id=__span-87-28><a id=__codelineno-87-28 name=__codelineno-87-28 href=#__codelineno-87-28></a><span class=sb>* char - символ у кодуванні UTF-16 (0 до 65535), 2 байти</span>
</span><span id=__span-87-29><a id=__codelineno-87-29 name=__codelineno-87-29 href=#__codelineno-87-29></a>
</span><span id=__span-87-30><a id=__codelineno-87-30 name=__codelineno-87-30 href=#__codelineno-87-30></a>
</span><span id=__span-87-31><a id=__codelineno-87-31 name=__codelineno-87-31 href=#__codelineno-87-31></a><span class=sb>### 2. Відмінності об&#39;єкта від примітивних типів даних</span>
</span><span id=__span-87-32><a id=__codelineno-87-32 name=__codelineno-87-32 href=#__codelineno-87-32></a><span class=sb>* примітивні типи виграють у продуктивності та займаній пам&#39;яті</span>
</span><span id=__span-87-33><a id=__codelineno-87-33 name=__codelineno-87-33 href=#__codelineno-87-33></a><span class=sb>* </span>
</span><span id=__span-87-34><a id=__codelineno-87-34 name=__codelineno-87-34 href=#__codelineno-87-34></a>
</span><span id=__span-87-35><a id=__codelineno-87-35 name=__codelineno-87-35 href=#__codelineno-87-35></a>
</span><span id=__span-87-36><a id=__codelineno-87-36 name=__codelineno-87-36 href=#__codelineno-87-36></a><span class=sb>### 3. Різниця передачі параметрів за посиланням і за значенням</span>
</span><span id=__span-87-37><a id=__codelineno-87-37 name=__codelineno-87-37 href=#__codelineno-87-37></a><span class=sb>*Передача за значенням (by value)* - значення фактичних параметрів копіюються. Метод, що викликається, створює свою копію значень аргументів і потім її використовує. Оскільки робота ведеться з копією, на вихідний параметр це ніяк не впливає.</span>
</span><span id=__span-87-38><a id=__codelineno-87-38 name=__codelineno-87-38 href=#__codelineno-87-38></a>
</span><span id=__span-87-39><a id=__codelineno-87-39 name=__codelineno-87-39 href=#__codelineno-87-39></a><span class=sb>*Передача за посиланням (by reference)* - параметри передаються як посилання (адреса) на вихідну змінну. Метод, що викликається, не створює свою копію, а посилається на вихідне значення. Отже, зміни, зроблені в методі, що викликається, також будуть відображені у вихідному значенні.</span>
</span><span id=__span-87-40><a id=__codelineno-87-40 name=__codelineno-87-40 href=#__codelineno-87-40></a>
</span><span id=__span-87-41><a id=__codelineno-87-41 name=__codelineno-87-41 href=#__codelineno-87-41></a><span class=sb>    Java завжди передає параметри за значенням! Однак посилання вказують на один і той самий об&#39;єкт у купі (heap), що призводить до змін параметра навіть у зовнішніх методах.</span>
</span><span id=__span-87-42><a id=__codelineno-87-42 name=__codelineno-87-42 href=#__codelineno-87-42></a>
</span><span id=__span-87-43><a id=__codelineno-87-43 name=__codelineno-87-43 href=#__codelineno-87-43></a>
</span><span id=__span-87-44><a id=__codelineno-87-44 name=__codelineno-87-44 href=#__codelineno-87-44></a><span class=sb>### 4. Bytecode</span>
</span><span id=__span-87-45><a id=__codelineno-87-45 name=__codelineno-87-45 href=#__codelineno-87-45></a><span class=sb>Усі ЯП можна умовно розділити на компільовані та інтерпретовані. У Java використовується третій підхід - байт-код. Вихідний код Java перетворюється компілятором на байт-код (а не машинний код). A байт-код Java перетворюється на машинний код за допомогою спеціального інтерпретатора - JVM.</span>
</span><span id=__span-87-46><a id=__codelineno-87-46 name=__codelineno-87-46 href=#__codelineno-87-46></a>
</span><span id=__span-87-47><a id=__codelineno-87-47 name=__codelineno-87-47 href=#__codelineno-87-47></a><span class=sb>### 5. JVM, JDK, JRE</span>
</span><span id=__span-87-48><a id=__codelineno-87-48 name=__codelineno-87-48 href=#__codelineno-87-48></a><span class=sb>*JVM (Java Virtual Machine)* - віртуальна машина відповідає за саме виконання коду. Вона працює з байткодом (тим, що міститься всередині файлів із розширенням .class).</span>
</span><span id=__span-87-49><a id=__codelineno-87-49 name=__codelineno-87-49 href=#__codelineno-87-49></a>
</span><span id=__span-87-50><a id=__codelineno-87-50 name=__codelineno-87-50 href=#__codelineno-87-50></a><span class=sb>*JRE (Java Runtime Environment)* - оточення, необхідне для запуску Java-програм. Включає в себе стандартну бібліотеку. До неї входять, як базові пакети lang, util, так і пакети для роботи з різними форматами, БД, користувацьким інтерфейсом. JVM теж частина JRE.</span>
</span><span id=__span-87-51><a id=__codelineno-87-51 name=__codelineno-87-51 href=#__codelineno-87-51></a>
</span><span id=__span-87-52><a id=__codelineno-87-52 name=__codelineno-87-52 href=#__codelineno-87-52></a><span class=sb>*JDK (Java Development Kit)* - набір програм для розробки. Включає в себе JRE, завантажувач коду java, компілятор javac, архіватор jar, генератор документації javadoc та інші утиліти, потрібні під час розробки.</span>
</span><span id=__span-87-53><a id=__codelineno-87-53 name=__codelineno-87-53 href=#__codelineno-87-53></a>
</span><span id=__span-87-54><a id=__codelineno-87-54 name=__codelineno-87-54 href=#__codelineno-87-54></a>
</span><span id=__span-87-55><a id=__codelineno-87-55 name=__codelineno-87-55 href=#__codelineno-87-55></a><span class=sb>### 6. Ознаки JavaBean</span>
</span><span id=__span-87-56><a id=__codelineno-87-56 name=__codelineno-87-56 href=#__codelineno-87-56></a><span class=sb>1. Усі властивості приватні (для доступу геттери/сеттери)</span>
</span><span id=__span-87-57><a id=__codelineno-87-57 name=__codelineno-87-57 href=#__codelineno-87-57></a><span class=sb>2) Відкритий конструктор без аргументів</span>
</span><span id=__span-87-58><a id=__codelineno-87-58 name=__codelineno-87-58 href=#__codelineno-87-58></a><span class=sb>3. Реалізує Serializable</span>
</span><span id=__span-87-59><a id=__codelineno-87-59 name=__codelineno-87-59 href=#__codelineno-87-59></a>
</span><span id=__span-87-60><a id=__codelineno-87-60 name=__codelineno-87-60 href=#__codelineno-87-60></a>
</span><span id=__span-87-61><a id=__codelineno-87-61 name=__codelineno-87-61 href=#__codelineno-87-61></a><span class=sb>### 7. OutOfMemoryError</span>
</span><span id=__span-87-62><a id=__codelineno-87-62 name=__codelineno-87-62 href=#__codelineno-87-62></a><span class=sb>Помилка виникає при нестачі фізичної пам&#39;яті для виділення додатку. Через що додатком падає без інформації в логах або потоці виведення про те, де і чому це сталося.</span>
</span><span id=__span-87-63><a id=__codelineno-87-63 name=__codelineno-87-63 href=#__codelineno-87-63></a>
</span><span id=__span-87-64><a id=__codelineno-87-64 name=__codelineno-87-64 href=#__codelineno-87-64></a>
</span><span id=__span-87-65><a id=__codelineno-87-65 name=__codelineno-87-65 href=#__codelineno-87-65></a><span class=sb>### 8. Стектрейс і як його отримати</span>
</span><span id=__span-87-66><a id=__codelineno-87-66 name=__codelineno-87-66 href=#__codelineno-87-66></a><span class=sb>Stacktrace (стек викликів) - послідовність викликів функцій у програмі.</span>
</span><span id=__span-87-67><a id=__codelineno-87-67 name=__codelineno-87-67 href=#__codelineno-87-67></a><span class=sb>```</span><span class=nx>java</span>
</span><span id=__span-87-68><a id=__codelineno-87-68 name=__codelineno-87-68 href=#__codelineno-87-68></a><span class=nx>StackTraceElement</span><span class=p>[]</span><span class=w> </span><span class=nx>stackTraceElements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>Thread</span><span class=p>.</span><span class=nx>currentThread</span><span class=p>().</span><span class=nx>getStackTrace</span><span class=p>();</span>
</span><span id=__span-87-69><a id=__codelineno-87-69 name=__codelineno-87-69 href=#__codelineno-87-69></a><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=nx>StackTraceElement</span><span class=w> </span><span class=nx>element</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=nx>stackTraceElements</span><span class=p>)</span>
</span><span id=__span-87-70><a id=__codelineno-87-70 name=__codelineno-87-70 href=#__codelineno-87-70></a><span class=w>    </span><span class=p>{</span>
</span><span id=__span-87-71><a id=__codelineno-87-71 name=__codelineno-87-71 href=#__codelineno-87-71></a><span class=w>       </span><span class=nx>System</span><span class=p>.</span><span class=nx>out</span><span class=p>.</span><span class=nx>println</span><span class=p>(</span><span class=nx>element</span><span class=p>.</span><span class=nx>getMethodName</span><span class=p>());</span>
</span><span id=__span-87-72><a id=__codelineno-87-72 name=__codelineno-87-72 href=#__codelineno-87-72></a><span class=w>    </span><span class=p>}</span>
</span></code></pre></div> <h3 id=9-object>9. Всі методи класу object<a class=headerlink href=#9-object title="Permanent link">&para;</a></h3> <div class="language-java highlight"><pre><span></span><code><span id=__span-88-1><a id=__codelineno-88-1 name=__codelineno-88-1 href=#__codelineno-88-1></a><span class=c1>//Вертає строкове представлення об&#39;єкта</span>
</span><span id=__span-88-2><a id=__codelineno-88-2 name=__codelineno-88-2 href=#__codelineno-88-2></a><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>toString</span><span class=p>()</span>
</span><span id=__span-88-3><a id=__codelineno-88-3 name=__codelineno-88-3 href=#__codelineno-88-3></a>
</span><span id=__span-88-4><a id=__codelineno-88-4 name=__codelineno-88-4 href=#__codelineno-88-4></a><span class=c1>//Використовуються для порівняння об&#39;єктів</span>
</span><span id=__span-88-5><a id=__codelineno-88-5 name=__codelineno-88-5 href=#__codelineno-88-5></a><span class=kd>public</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hashCode</span><span class=p>()</span>
</span><span id=__span-88-6><a id=__codelineno-88-6 name=__codelineno-88-6 href=#__codelineno-88-6></a><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>equals</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>obj</span><span class=p>)</span>
</span><span id=__span-88-7><a id=__codelineno-88-7 name=__codelineno-88-7 href=#__codelineno-88-7></a>
</span><span id=__span-88-8><a id=__codelineno-88-8 name=__codelineno-88-8 href=#__codelineno-88-8></a><span class=c1>//Вертає спеціальний об&#39;єкт, який описує поточний клас</span>
</span><span id=__span-88-9><a id=__codelineno-88-9 name=__codelineno-88-9 href=#__codelineno-88-9></a><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=n>Class</span><span class=w> </span><span class=nf>getClass</span><span class=p>()</span>
</span><span id=__span-88-10><a id=__codelineno-88-10 name=__codelineno-88-10 href=#__codelineno-88-10></a>
</span><span id=__span-88-11><a id=__codelineno-88-11 name=__codelineno-88-11 href=#__codelineno-88-11></a><span class=c1>//Методи для контролю доступу до об&#39;єкта з різних ниток/потоків(threads). Керування синхронізацією ниток</span>
</span><span id=__span-88-12><a id=__codelineno-88-12 name=__codelineno-88-12 href=#__codelineno-88-12></a><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>notify</span><span class=p>()</span>
</span><span id=__span-88-13><a id=__codelineno-88-13 name=__codelineno-88-13 href=#__codelineno-88-13></a><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>notifyAll</span><span class=p>()</span>
</span><span id=__span-88-14><a id=__codelineno-88-14 name=__codelineno-88-14 href=#__codelineno-88-14></a><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>wait</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>timeout</span><span class=p>)</span>
</span><span id=__span-88-15><a id=__codelineno-88-15 name=__codelineno-88-15 href=#__codelineno-88-15></a><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>wait</span><span class=p>(</span><span class=kt>long</span><span class=w> </span><span class=n>timeout</span><span class=p>,</span><span class=w> </span><span class=n>intnanos</span><span class=p>)</span>
</span><span id=__span-88-16><a id=__codelineno-88-16 name=__codelineno-88-16 href=#__codelineno-88-16></a><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>wait</span><span class=p>()</span>
</span><span id=__span-88-17><a id=__codelineno-88-17 name=__codelineno-88-17 href=#__codelineno-88-17></a>
</span><span id=__span-88-18><a id=__codelineno-88-18 name=__codelineno-88-18 href=#__codelineno-88-18></a><span class=c1>//Дозволяє &quot;звільнити&quot; рідні не-Java ресурси: закрити файли, потоки тощо.</span>
</span><span id=__span-88-19><a id=__codelineno-88-19 name=__codelineno-88-19 href=#__codelineno-88-19></a><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>finalize</span><span class=p>()</span>
</span><span id=__span-88-20><a id=__codelineno-88-20 name=__codelineno-88-20 href=#__codelineno-88-20></a>
</span><span id=__span-88-21><a id=__codelineno-88-21 name=__codelineno-88-21 href=#__codelineno-88-21></a><span class=c1>//Дозволяє клонувати об&#39;єкт: створює дублікат об&#39;єкта</span>
</span><span id=__span-88-22><a id=__codelineno-88-22 name=__codelineno-88-22 href=#__codelineno-88-22></a><span class=kd>protected</span><span class=w> </span><span class=kd>native</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>clone</span><span class=p>()</span>
</span></code></pre></div> <h3 id=10-try-with-resources-try-catch-finally>10. Різниця між try-with-resources і try-catch-finally<a class=headerlink href=#10-try-with-resources-try-catch-finally title="Permanent link">&para;</a></h3> <p>try-with-resources аналог традиційного та детального блоку try-catch-finally. Реалізація ресурсу повинна виконуватися в try(). Ресурси автоматично закриваються після try(), замість ручного закриття в блоці finally у try-catch-finally. <div class="language-java highlight"><pre><span></span><code><span id=__span-89-1><a id=__codelineno-89-1 name=__codelineno-89-1 href=#__codelineno-89-1></a><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>FileReader</span><span class=w> </span><span class=n>fileReader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FileReader</span><span class=p>(</span><span class=s>&quot;D:\\\test.txt&quot;</span><span class=p>);)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-89-2><a id=__codelineno-89-2 name=__codelineno-89-2 href=#__codelineno-89-2></a><span class=p>...</span>
</span><span id=__span-89-3><a id=__codelineno-89-3 name=__codelineno-89-3 href=#__codelineno-89-3></a><span class=p>}</span>
</span><span id=__span-89-4><a id=__codelineno-89-4 name=__codelineno-89-4 href=#__codelineno-89-4></a><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>){</span>
</span><span id=__span-89-5><a id=__codelineno-89-5 name=__codelineno-89-5 href=#__codelineno-89-5></a><span class=w>      </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span>
</span><span id=__span-89-6><a id=__codelineno-89-6 name=__codelineno-89-6 href=#__codelineno-89-6></a><span class=p>}</span>
</span></code></pre></div></p> <h3 id=11_2>11. Конструктори та їхні типи<a class=headerlink href=#11_2 title="Permanent link">&para;</a></h3> <ol> <li> <p><em>Конструктор за замовчуванням</em> - не описаний у класі явно, а створений автоматично компілятором.</p> </li> <li> <p><em>Конструктор без аргументів</em> <div class="language-java highlight"><pre><span></span><code><span id=__span-90-1><a id=__codelineno-90-1 name=__codelineno-90-1 href=#__codelineno-90-1></a><span class=kd>public</span><span class=w> </span><span class=nf>BankAccount</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-90-2><a id=__codelineno-90-2 name=__codelineno-90-2 href=#__codelineno-90-2></a><span class=w>    </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&quot;&quot;</span><span class=p>;</span>
</span><span id=__span-90-3><a id=__codelineno-90-3 name=__codelineno-90-3 href=#__codelineno-90-3></a><span class=w>    </span><span class=n>opened</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LocalDateTime</span><span class=p>.</span><span class=na>now</span><span class=p>();</span>
</span><span id=__span-90-4><a id=__codelineno-90-4 name=__codelineno-90-4 href=#__codelineno-90-4></a><span class=w>    </span><span class=n>баланс</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0.0d</span><span class=p>;</span>
</span><span id=__span-90-5><a id=__codelineno-90-5 name=__codelineno-90-5 href=#__codelineno-90-5></a><span class=p>}</span>
</span></code></pre></div></p> </li> </ol> <h3 id=12_2>12. Параметризований конструктор<a class=headerlink href=#12_2 title="Permanent link">&para;</a></h3> <p><div class="language-java highlight"><pre><span></span><code><span id=__span-91-1><a id=__codelineno-91-1 name=__codelineno-91-1 href=#__codelineno-91-1></a><span class=kd>public</span><span class=w> </span><span class=nf>BankAccount</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>LocalDateTime</span><span class=w> </span><span class=n>opened</span><span class=p>,</span><span class=w> </span><span class=kt>double</span><span class=w> </span><span class=n>balance</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-91-2><a id=__codelineno-91-2 name=__codelineno-91-2 href=#__codelineno-91-2></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>name</span><span class=p>;</span>
</span><span id=__span-91-3><a id=__codelineno-91-3 name=__codelineno-91-3 href=#__codelineno-91-3></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>opened</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>opened</span><span class=p>;</span>
</span><span id=__span-91-4><a id=__codelineno-91-4 name=__codelineno-91-4 href=#__codelineno-91-4></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=p>;</span>
</span><span id=__span-91-5><a id=__codelineno-91-5 name=__codelineno-91-5 href=#__codelineno-91-5></a><span class=p>}</span>
</span></code></pre></div> <em>Конструктор копіювання</em> - спеціальний конструктор, який застосовується коли необхідно створити копію складного об'єкта, але при цьому ми не хочемо використовувати метод clone(). <em>Зв'язані конструктори</em> - один конструктор викликає інший з цього ж класу.</p> <h3 id=13_1>13. Побітові операції<a class=headerlink href=#13_1 title="Permanent link">&para;</a></h3> <p><em>Порозрядні операції</em> - виконуються над окремими двійковими розрядами або бітами чисел. У цих операціях як операнди можуть виступати тільки цілі числа. <strong>Логічні операції</strong>: * &amp; (логічне І / множення) - якщо в обох операндів значення розрядів дорівнює 1, то операція повертає 1, інакше повертається число 0 * | (логічне АБО / додавання) - повертається одиниця, якщо хоча б у одного числа в даному розряді є одиниця * ^ (логічне виключне АБО / XOR) - Якщо у нас значення поточного розряду в обох чисел різні, то повертається 1, інакше повертається 0 * ~ (логічне заперечення) - інвертує всі розряди числа: якщо значення розряду дорівнює 1, то воно стає 0</p> <h3 id=14-immutable-object>14. Кратка характеристика immutable object і навіщо вони потрібні<a class=headerlink href=#14-immutable-object title="Permanent link">&para;</a></h3> <p><em>Іммутабельний (незмінний/immutable) об'єкт</em> - об'єкт, який після ініціалізації не може змінити свій стан. Тобто якщо в коді є посилання на екземпляр імутабельного класу, то будь-які зміни в ньому призводять до створення нового екземпляра. Імутабельність дає змогу будувати стабільніші програми, і її принципи часто застосовуються у фундаментальних частинах софту.</p> <h3 id=15-immutable>15. Вимоги для створення immutable класу<a class=headerlink href=#15-immutable title="Permanent link">&para;</a></h3> <ul> <li>Оголошено як final, щоб від нього не можна було успадковувати. Інакше дочірні класи можуть порушити імутабельність.</li> <li>Усі поля класу мають бути приватними відповідно до принципів інкапсуляції.</li> <li>Повинні бути параметризовані конструктори для коректного створення екземпляра, через які здійснюється первісна ініціалізація полів класу.</li> <li>У класі не повинно бути сеттерів, для виключення можливості зміни стану після інстанціювання</li> <li>Для полів-колекцій необхідно робити глибокі копії, щоб гарантувати їхню незмінність.</li> </ul> <h3 id=16-immutable-java>16. Об'єкти яких стандартних класів immutable в Java<a class=headerlink href=#16-immutable-java title="Permanent link">&para;</a></h3> <ul> <li>String</li> <li>Усі класи-обгортки над примітивними типами (Boolean, Integer, Byte, Long...)</li> <li>BigInteger і BigDecimal</li> <li>Об'єкти класу java.lang.StackTraceElement</li> <li>File</li> <li>UUID</li> <li>Об'єкти класів пакета java.time</li> <li>Locale</li> </ul> <h3 id=17-immutable-object>17. Переваги immutable object перед звичайними об'єктами<a class=headerlink href=#17-immutable-object title="Permanent link">&para;</a></h3> <ul> <li>Потокобезпека - можна вільно використовувати одночасно з різних ниток.</li> <li>Є хорошими ключами в map.</li> <li>Відмінно підходять для зберігання констант.</li> <li>"Атомарність щодо збою" - якщо immutable об'єкт викине виняток, то він все одно не залишиться в небажаному (зламаному) стані.</li> <li>Прості в реалізації та тестуванні</li> <li>Не потрібні такі додаткові механізми як конструктор копіювання і реалізація клону.</li> </ul> <hr> <h1 id=-typescript>Відповіді - 'Typescript'<a class=headerlink href=#-typescript title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1-typescript>1. Перелічіть вбудовані типи у Typescript<a class=headerlink href=#1-typescript title="Permanent link">&para;</a></h3> <p>Вони також називаються примітивними типами у TypeScript: * Тип <strong>Number</strong>: використовується для представлення значень числового типу і представляє значення з плаваючою комою подвійної точності. <div class="language-js highlight"><pre><span></span><code><span id=__span-92-1><a id=__codelineno-92-1 name=__codelineno-92-1 href=#__codelineno-92-1></a><span class=kd>var</span><span class=w> </span><span class=nx>variable_name</span><span class=o>:</span><span class=nx>number</span><span class=p>;</span>
</span></code></pre></div> * Тип <strong>Рядок</strong>: представляє послідовність символів, що зберігається у вигляді коду Unicode UTF-16. Це той самий тип, що і примітивний тип JavaScript. <div class="language-js highlight"><pre><span></span><code><span id=__span-93-1><a id=__codelineno-93-1 name=__codelineno-93-1 href=#__codelineno-93-1></a><span class=kd>var</span><span class=w> </span><span class=nx>variable_name</span><span class=o>:</span><span class=nx>string</span><span class=p>;</span>
</span></code></pre></div> * Тип <strong>Boolean</strong>: у Typescript використовується для представлення логічного значення. Коли ми використовуємо тип Boolean, ми отримуємо висновок тільки у вигляді true або false. Це також те ж саме, що і примітивний тип JavaScript. <div class="language-js highlight"><pre><span></span><code><span id=__span-94-1><a id=__codelineno-94-1 name=__codelineno-94-1 href=#__codelineno-94-1></a><span class=kd>var</span><span class=w> </span><span class=nx>variable_name</span><span class=o>:</span><span class=nx>bool</span><span class=p>;</span>
</span></code></pre></div> * Тип <strong>Null</strong>: представляє собою нульовий літерал, і на саме значення нульового типу не можна безпосередньо посилатися. <div class="language-js highlight"><pre><span></span><code><span id=__span-95-1><a id=__codelineno-95-1 name=__codelineno-95-1 href=#__codelineno-95-1></a><span class=kd>var</span><span class=w> </span><span class=nx>variable_name</span><span class=o>:</span><span class=nx>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span>
</span></code></pre></div> * Тип <strong>Undefined</strong>: це тип невизначеного літералу. Цей тип вбудованих типів є підтипом усіх типів. <div class="language-js highlight"><pre><span></span><code><span id=__span-96-1><a id=__codelineno-96-1 name=__codelineno-96-1 href=#__codelineno-96-1></a><span class=kd>var</span><span class=w> </span><span class=nx>variable_name</span><span class=o>:</span><span class=nx>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>undefined</span><span class=p>;</span>
</span></code></pre></div></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2-typescript>2. Що таке модулі в Typescript?<a class=headerlink href=#2-typescript title="Permanent link">&para;</a></h3> <p>Модулі в Typescript допомагають в організації коду.<br> Існує 2 типи модулів - внутрішні та зовнішні</p> <ul> <li> <p><strong>Внутрішні модулі</strong> тепер можна замінювати за допомогою простору імен Typescript.</p> </li> <li> <p><strong>Зовнішні модулі</strong> використовуються для визначення та завантаження залежностей між декількома зовнішніми js-файлами. Якщо використовується тільки один js-файл, то зовнішні модулі не потрібні.</p> </li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3-typescript>3. Що таке Typescript і чому його варто використовувати?<a class=headerlink href=#3-typescript title="Permanent link">&para;</a></h3> <p>TypeScript - це вільна мова програмування з відкритим вихідним кодом, розроблена і підтримувана компанією Microsoft. Вона є строгою синтаксичною підмножиною JavaScript і додає до мови необов'язкову статичну типізацію та об'єктно-орієнтоване програмування на основі класів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4-typescript>4. Поясніть, що таке узагальнення в TypeScript<a class=headerlink href=#4-typescript title="Permanent link">&para;</a></h3> <p>За допомогою узагальнень можна створити компонент або функцію для роботи з різними типами, а не з одним.</p> <div class="language-js highlight"><pre><span></span><code><span id=__span-97-1><a id=__codelineno-97-1 name=__codelineno-97-1 href=#__codelineno-97-1></a><span class=cm>/** Визначення класу з узагальненим параметром */</span>
</span><span id=__span-97-2><a id=__codelineno-97-2 name=__codelineno-97-2 href=#__codelineno-97-2></a><span class=kd>class</span><span class=w> </span><span class=nx>Queue</span><span class=o>&lt;</span><span class=nx>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-97-3><a id=__codelineno-97-3 name=__codelineno-97-3 href=#__codelineno-97-3></a><span class=w>  </span><span class=kr>private</span><span class=w> </span><span class=nx>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[];</span>
</span><span id=__span-97-4><a id=__codelineno-97-4 name=__codelineno-97-4 href=#__codelineno-97-4></a><span class=w>  </span><span class=nx>push</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>item</span><span class=o>:</span><span class=w> </span><span class=nx>T</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>data</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>item</span><span class=p>);</span>
</span><span id=__span-97-5><a id=__codelineno-97-5 name=__codelineno-97-5 href=#__codelineno-97-5></a><span class=w>  </span><span class=nx>pop</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=o>:</span><span class=w> </span><span class=nx>T</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>data</span><span class=p>.</span><span class=nx>shift</span><span class=p>();</span>
</span><span id=__span-97-6><a id=__codelineno-97-6 name=__codelineno-97-6 href=#__codelineno-97-6></a><span class=p>}</span>
</span><span id=__span-97-7><a id=__codelineno-97-7 name=__codelineno-97-7 href=#__codelineno-97-7></a>
</span><span id=__span-97-8><a id=__codelineno-97-8 name=__codelineno-97-8 href=#__codelineno-97-8></a><span class=kd>const</span><span class=w> </span><span class=nx>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Queue</span><span class=o>&lt;</span><span class=nx>number</span><span class=o>&gt;</span><span class=p>();</span>
</span><span id=__span-97-9><a id=__codelineno-97-9 name=__codelineno-97-9 href=#__codelineno-97-9></a><span class=nx>queue</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=mf>0</span><span class=p>);</span>
</span><span id=__span-97-10><a id=__codelineno-97-10 name=__codelineno-97-10 href=#__codelineno-97-10></a><span class=nx>queue</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=s2>&quot;1&quot;</span><span class=p>);</span><span class=w> </span><span class=c1>// ERROR : не можна проштовхнути рядок. Допускаються тільки числа</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5-typescript-javascript>5. Що таке TypeScript і чому я повинен використовувати його замість JavaScript?<a class=headerlink href=#5-typescript-javascript title="Permanent link">&para;</a></h3> <p><strong>TypeScript</strong> - це підмножина JavaScript, яка в першу чергу надає необов'язкову статичну типізацію, класи та інтерфейси. Однією з головних переваг є те, що IDE надають більш багате середовище для виявлення поширених помилок під час <em>набору коду</em>. Для великого JavaScript-проекту використання TypeScript може призвести до створення більш надійного програмного забезпечення, при цьому його можна буде розгортати там, де виконується звичайний JavaScript-додаток.</p> <p>Детальніше: * TypeScript підтримує нові стандарти ECMAScript і компілює їх у (старіші) цілі ECMAScript за вашим вибором. Це означає, що ви можете використовувати функції ES2015 і пізніших версій, такі як модулі, лямбда-функції, класи, оператор поширення, деструктуризацію вже сьогодні. * Код JavaScript є коректним кодом TypeScript; TypeScript є підмножиною JavaScript. * TypeScript додає підтримку типів до JavaScript. Система типів TypeScript відносно багата і включає: інтерфейси, перерахування, гібридні типи, узагальнення, об'єднання та перетин типів, модифікатори доступу та багато іншого. TypeScript робить введення тексту трохи простішим і набагато менш явним завдяки використанню виведення типів. * Досвід розробки за допомогою TypeScript є значним покращенням у порівнянні з JavaScript. Компілятор TypeScript в режимі реального часу інформує IDE про свою багату інформацію про типи. * З увімкненими суворими перевірками на нуль (прапорець компілятора <code>--strictNullChecks</code>) компілятор TypeScript не дозволить присвоювати змінній значення undefined, якщо ви явно не оголосите, що вона має тип nullable. * Для використання TypeScript вам потрібен процес збірки для компіляції в код JavaScript. Компілятор TypeScript може вбудовувати інформацію про вихідну карту у згенеровані файли .js або створювати окремі файли .map. Це дозволяє вам встановлювати точки зупинки та перевіряти змінні під час виконання безпосередньо у вашому TypeScript-коді. * TypeScript має відкритий вихідний код (ліцензія Apache 2, див. github) і підтримується Microsoft. *Андерс Хейлсберг (Anders Hejlsberg), провідний архітектор C#, очолює проект.</p> <p><strong>Джерело:</strong> <a href=https://stackoverflow.com/questions/12694530/what-is-typescript-and-why-would-i-use-it-in-place-of-javascript>stackoverflow.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=6-typescript>6. Що таке TypeScript і навіщо він потрібен?<a class=headerlink href=#6-typescript title="Permanent link">&para;</a></h3> <p>JavaScript - це єдина мова клієнтської частини, яка універсально підтримується всіма браузерами. Але JavaScript не є найкраще спроектованою мовою. Він не є об'єктно-орієнтованою мовою на основі класів, не підтримує успадкування на основі класів, має ненадійну динамічну типізацію і не має перевірки помилок під час компіляції. А TypeScript вирішує всі ці проблеми. Іншими словами, TypeScript - це спроба "виправити" проблеми JavaScript.</p> <p>TypeScript - це вільна мова програмування з відкритим вихідним кодом, розроблена і підтримувана корпорацією Microsoft. Вона є строгою підмножиною JavaScript і додає до мови <strong>необов'язкову статичну типізацію</strong> та <strong>об'єктно-орієнтоване програмування на основі класів</strong>. TypeScript досить простий у вивченні та використанні для розробників, знайомих з C#, Java та всіма сильними типізованими мовами. Зрештою, "TypeScript - це мова, яка генерує прості файли JavaScript".</p> <p>Як зазначено на <a href=http://www.typescriptlang.org/ >офіційному сайті TypeScript</a>, "TypeScript дозволяє вам писати JavaScript так, як ви дійсно хочете. TypeScript - це типізована підмножина JavaScript, яка компілюється у звичайний JavaScript. Будь-який браузер. Будь-який хост. Будь-яка операційна система. З відкритим вихідним кодом". Де "<strong>типізований</strong>" означає, що він враховує типи змінних, параметрів і функцій.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=7-typescript_1>7. Які переваги має TypeScript?<a class=headerlink href=#7-typescript_1 title="Permanent link">&para;</a></h3> <p>TypeScript має наступні переваги.</p> <ul> <li>Допомагає у структуруванні коду.</li> <li>Використовуйте об'єктно-орієнтоване програмування на основі класів.</li> <li>Накладає вказівки щодо кодування.</li> <li>Пропонує перевірку типу.</li> <li>Перевірка помилок під час компіляції.</li> <li>Інтелект.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=8-typescript>8. Чи потрібно компілювати файли TypeScript і чому?<a class=headerlink href=#8-typescript title="Permanent link">&para;</a></h3> <p>Так, потрібно.<br> TypeScript - це просто мова, браузери з розширеннями не можуть її інтерпретувати. Перетворення з TypeScript на JavaScript називається компіляцією. Компіляція не означає, що в цьому випадку створюється двійковий код. Для цього виду перекладу замість терміну компіляція також використовується термін трансполяція.</p> <p>🔗 <strong>Джерело:</strong> <a href=https://stackoverflow.com/questions/45125284/why-is-angular-compiled>stackoverflow.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=9-typescript>9. Як викликати конструктор базового класу з дочірнього класу в TypeScript?<a class=headerlink href=#9-typescript title="Permanent link">&para;</a></h3> <p>Ми можемо викликати конструктор базового класу з допомогою <code>super()</code>.</p> <p>🔗 <strong>Джерело:</strong> <a href=http://www.talkingdotnet.com/typescript-interview-questions/ >http://www.talkingdotnet.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=10-typescript-javascript>10. Яка різниця між TypeScript та JavaScript?<a class=headerlink href=#10-typescript-javascript title="Permanent link">&para;</a></h3> <ul> <li>Це об'єктно-орієнтована мова програмування (не в чистому вигляді).</li> <li>Тут використовується статична типізація (ми можемо оголосити змінну декількома способами). наприклад: var num : number.</li> <li>У неї є інтерфейси.</li> <li>Має функцію необов'язкового параметра.</li> <li>Має функцію залишкового параметра.</li> <li>Підтримує узагальнення.</li> <li>Підтримує модулі</li> <li>Інтерфейсами є число, рядок тощо.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=11-typescript>11. Що таке інтерфейс у TypeScript?<a class=headerlink href=#11-typescript title="Permanent link">&para;</a></h3> <p>Один з основних принципів TypeScript полягає в тому, що перевірка типу фокусується на <em>формі</em>, яку мають значення.</p> <p>Інтерфейс - це віртуальна структура, яка існує тільки в контексті TypeScript. Компілятор TypeScript використовує інтерфейси виключно для перевірки типів.</p> <p>Коли ви визначаєте свій інтерфейс, ви говорите, що будь-який об'єкт (не екземпляр класу), якому надається цей контракт, повинен бути об'єктом, що містить властивості інтерфейсу.</p> <p>🔗 <strong>Джерело:</strong> <a href=https://medium.com/front-end-hacking/typescript-class-vs-interface-99c0ae1c2136>medium.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=12-typescript>12. Коли використовувати інтерфейси, а коли класи в TypeScript?<a class=headerlink href=#12-typescript title="Permanent link">&para;</a></h3> <p>Якщо вам потрібно/бажано створити екземпляр, можливо, користувацького об'єкта, отримуючи при цьому переваги перевірки типів таких речей, як аргументи, типи повернення або узагальнення - клас має сенс. </p> <p>Якщо ви не створюєте екземпляри - у нашому розпорядженні є інтерфейси, перевага яких полягає у тому, що вони не генерують жодного вихідного коду, але дозволяють нам дещо "віртуально" перевіряти типи нашого коду.</p> <p><strong>Джерело:</strong> <a href=https://toddmotto.com/classes-vs-interfaces-in-typescript>toddmotto.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=13-typescript>13. Яка різниця між класами та інтерфейсами у TypeScript?<a class=headerlink href=#13-typescript title="Permanent link">&para;</a></h3> <p>Ми використовуємо класи як фабрики об'єктів. Клас визначає план того, як має виглядати і діяти об'єкт, а потім реалізує цей план, ініціалізуючи властивості класу та визначаючи методи. Класи присутні на всіх етапах нашого коду.</p> <p>На відміну від класів, інтерфейс - це віртуальна структура, яка існує лише в контексті TypeScript. Компілятор TypeScript використовує інтерфейси виключно для перевірки типів. Після того, як код буде транскрибовано на цільову мову, він буде позбавлений інтерфейсів.</p> <p>Клас може визначати фабрику або синглтон, забезпечуючи ініціалізацію своїх властивостей та реалізацію методів, інтерфейс - це просто структурний контракт, який визначає, які властивості об'єкта повинні мати ім'я та тип.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=14-typescript>14. Що таке "Декоратори" у TypeScript?<a class=headerlink href=#14-typescript title="Permanent link">&para;</a></h3> <p>Декоратор - це спеціальний тип оголошення, який може бути доданий до оголошення класу, методу, аксесора, властивості або параметра. Декоратори - це функції, які приймають свою ціль як аргумент. За допомогою декораторів ми можемо запускати довільний код навколо цільового виконання або навіть повністю замінити ціль новим визначенням.</p> <p>В ECMAScript 2016 (і Typescript) ми можемо декорувати 4 речі: конструктори, методи, властивості та параметри. </p> <p><strong>Джерело:</strong> <a href=https://www.sparkbit.pl/typescript-decorators/ >www.sparkbit.pl</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=15-gettersetter-typescript>15. Що таке getter/setter в TypeScript<a class=headerlink href=#15-gettersetter-typescript title="Permanent link">&para;</a></h3> <p>TypeScript підтримує <strong>getter/setter</strong> як спосіб перехоплення доступу до члена об'єкта. Це дає вам можливість мати більш тонкий контроль над тим, як здійснюється доступ до члена кожного об'єкта.</p> <div class="language-js highlight"><pre><span></span><code><span id=__span-98-1><a id=__codelineno-98-1 name=__codelineno-98-1 href=#__codelineno-98-1></a><span class=kd>class</span><span class=w> </span><span class=nx>foo</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-98-2><a id=__codelineno-98-2 name=__codelineno-98-2 href=#__codelineno-98-2></a><span class=w>  </span><span class=kr>private</span><span class=w> </span><span class=nx>_bar</span><span class=o>:</span><span class=kr>boolean</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span>
</span><span id=__span-98-3><a id=__codelineno-98-3 name=__codelineno-98-3 href=#__codelineno-98-3></a>
</span><span id=__span-98-4><a id=__codelineno-98-4 name=__codelineno-98-4 href=#__codelineno-98-4></a><span class=w>  </span><span class=nx>get</span><span class=w> </span><span class=nx>bar</span><span class=p>()</span><span class=o>:</span><span class=kr>boolean</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-98-5><a id=__codelineno-98-5 name=__codelineno-98-5 href=#__codelineno-98-5></a><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_bar</span><span class=p>;</span>
</span><span id=__span-98-6><a id=__codelineno-98-6 name=__codelineno-98-6 href=#__codelineno-98-6></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-98-7><a id=__codelineno-98-7 name=__codelineno-98-7 href=#__codelineno-98-7></a><span class=w>  </span><span class=nx>set</span><span class=w> </span><span class=nx>bar</span><span class=p>(</span><span class=nx>theBar</span><span class=o>:</span><span class=kr>boolean</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-98-8><a id=__codelineno-98-8 name=__codelineno-98-8 href=#__codelineno-98-8></a><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=nx>_bar</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>theBar</span><span class=p>;</span>
</span><span id=__span-98-9><a id=__codelineno-98-9 name=__codelineno-98-9 href=#__codelineno-98-9></a><span class=w>  </span><span class=p>}</span>
</span><span id=__span-98-10><a id=__codelineno-98-10 name=__codelineno-98-10 href=#__codelineno-98-10></a><span class=p>}</span>
</span><span id=__span-98-11><a id=__codelineno-98-11 name=__codelineno-98-11 href=#__codelineno-98-11></a>
</span><span id=__span-98-12><a id=__codelineno-98-12 name=__codelineno-98-12 href=#__codelineno-98-12></a><span class=kd>var</span><span class=w> </span><span class=nx>myBar</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>myFoo</span><span class=p>.</span><span class=nx>bar</span><span class=p>;</span><span class=w> </span><span class=c1>// коректно (отримати)</span>
</span><span id=__span-98-13><a id=__codelineno-98-13 name=__codelineno-98-13 href=#__codelineno-98-13></a><span class=nx>myFoo</span><span class=p>.</span><span class=nx>bar</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w> </span><span class=c1>// коректно (встановити)</span>
</span></code></pre></div> <p><strong>Джерело:</strong> <a href=http://www.typescriptlang.org/docs/handbook/classes.html>typescriptlang.org</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=16-null-undefined-typescript>16. Як можна перевірити null та undefined у TypeScript?<a class=headerlink href=#16-null-undefined-typescript title="Permanent link">&para;</a></h3> <p>Просто використовуйте: <div class="language-js highlight"><pre><span></span><code><span id=__span-99-1><a id=__codelineno-99-1 name=__codelineno-99-1 href=#__codelineno-99-1></a><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-99-2><a id=__codelineno-99-2 name=__codelineno-99-2 href=#__codelineno-99-2></a><span class=p>}</span>
</span></code></pre></div> Він обчислить <code>істину</code>, якщо <code>значення</code> не є істиною:</p> <ul> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>NaN</code></li> <li>порожній рядок <code>''</code></li> <li><code>0</code></li> <li><code>false</code></li> </ul> <p>TypesScript включає в себе правила JavaScript.</p> <p><strong>Джерело:</strong> <a href=https://stackoverflow.com/questions/28975896/is-there-a-dedicated-function-to-check-null-and-undefined-in-typescript>stackoverflow.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=17-typescript>17. Як реалізувати константи класу в TypeScript?<a class=headerlink href=#17-typescript title="Permanent link">&para;</a></h3> <p>У TypeScript не можна використовувати ключове слово <code>const</code> для оголошення властивостей класу. Це призводить до того, що компілятор видає помилку "Член класу не може мати ключове слово const". TypeScript 2.0 має модифікатор <code>readonly</code>:</p> <div class="language-js highlight"><pre><span></span><code><span id=__span-100-1><a id=__codelineno-100-1 name=__codelineno-100-1 href=#__codelineno-100-1></a><span class=kd>class</span><span class=w> </span><span class=nx>MyClass</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-100-2><a id=__codelineno-100-2 name=__codelineno-100-2 href=#__codelineno-100-2></a><span class=w>    </span><span class=nx>readonly</span><span class=w> </span><span class=nx>myReadonlyProperty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1</span><span class=p>;</span>
</span><span id=__span-100-3><a id=__codelineno-100-3 name=__codelineno-100-3 href=#__codelineno-100-3></a>
</span><span id=__span-100-4><a id=__codelineno-100-4 name=__codelineno-100-4 href=#__codelineno-100-4></a><span class=w>    </span><span class=nx>myMethod</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-100-5><a id=__codelineno-100-5 name=__codelineno-100-5 href=#__codelineno-100-5></a><span class=w>        </span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>myReadonlyProperty</span><span class=p>);</span>
</span><span id=__span-100-6><a id=__codelineno-100-6 name=__codelineno-100-6 href=#__codelineno-100-6></a><span class=w>    </span><span class=p>}</span>
</span><span id=__span-100-7><a id=__codelineno-100-7 name=__codelineno-100-7 href=#__codelineno-100-7></a><span class=p>}</span>
</span><span id=__span-100-8><a id=__codelineno-100-8 name=__codelineno-100-8 href=#__codelineno-100-8></a>
</span><span id=__span-100-9><a id=__codelineno-100-9 name=__codelineno-100-9 href=#__codelineno-100-9></a><span class=ow>new</span><span class=w> </span><span class=nx>MyClass</span><span class=p>().</span><span class=nx>myReadonlyProperty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>5</span><span class=p>;</span><span class=w> </span><span class=c1>// помилка, readonly</span>
</span></code></pre></div> <p>Джерело:** <a href=https://stackoverflow.com/questions/37265275/how-to-implement-class-constants-in-typescript>stackoverflow.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=18-typescript>18. Чи можна використовувати TypeScript на бекенді і як?<a class=headerlink href=#18-typescript title="Permanent link">&para;</a></h3> <p>Typescript працює не тільки для браузерного або фронтенд-коду, ви також можете використовувати його для написання бекенд-додатків. Наприклад, ви можете вибрати Node.js і отримати додаткову безпеку типів та інші абстракції, які пропонує ця мова.</p> <ol> <li>Встановіть компілятор Typescript за замовчуванням </li> </ol> <p><div class="language-sh highlight"><pre><span></span><code><span id=__span-101-1><a id=__codelineno-101-1 name=__codelineno-101-1 href=#__codelineno-101-1></a>npm<span class=w> </span>i<span class=w> </span>-g<span class=w> </span>typescript
</span></code></pre></div> 2. Компілятор TypeScript отримує параметри у вигляді файлу tsconfig.json, який визначає, куди покласти зібрані файли, і загалом дуже схожий на конфіг babel або webpack.</p> <p><div class="language-sh highlight"><pre><span></span><code><span id=__span-102-1><a id=__codelineno-102-1 name=__codelineno-102-1 href=#__codelineno-102-1></a><span class=o>{</span>
</span><span id=__span-102-2><a id=__codelineno-102-2 name=__codelineno-102-2 href=#__codelineno-102-2></a><span class=w>  </span><span class=s2>&quot;compilerOptions&quot;</span>:<span class=w> </span><span class=o>{</span>
</span><span id=__span-102-3><a id=__codelineno-102-3 name=__codelineno-102-3 href=#__codelineno-102-3></a><span class=w>    </span><span class=s2>&quot;target&quot;</span>:<span class=w> </span><span class=s2>&quot;es5&quot;</span>,
</span><span id=__span-102-4><a id=__codelineno-102-4 name=__codelineno-102-4 href=#__codelineno-102-4></a><span class=w>    </span><span class=s2>&quot;module&quot;</span>:<span class=w> </span><span class=s2>&quot;commonjs&quot;</span>,
</span><span id=__span-102-5><a id=__codelineno-102-5 name=__codelineno-102-5 href=#__codelineno-102-5></a><span class=w>    </span><span class=s2>&quot;declaration&quot;</span>:<span class=w> </span>true,
</span><span id=__span-102-6><a id=__codelineno-102-6 name=__codelineno-102-6 href=#__codelineno-102-6></a><span class=w>    </span><span class=s2>&quot;outDir&quot;</span>:<span class=w> </span><span class=s2>&quot;build&quot;</span>
</span><span id=__span-102-7><a id=__codelineno-102-7 name=__codelineno-102-7 href=#__codelineno-102-7></a><span class=w>  </span><span class=o>}</span>
</span><span id=__span-102-8><a id=__codelineno-102-8 name=__codelineno-102-8 href=#__codelineno-102-8></a><span class=o>}</span>
</span></code></pre></div> 3. Скомпілювати ts файли</p> <p><div class="language-sh highlight"><pre><span></span><code><span id=__span-103-1><a id=__codelineno-103-1 name=__codelineno-103-1 href=#__codelineno-103-1></a>tsc
</span></code></pre></div> 4. Запустити</p> <div class="language-js highlight"><pre><span></span><code><span id=__span-104-1><a id=__codelineno-104-1 name=__codelineno-104-1 href=#__codelineno-104-1></a><span class=nx>node</span><span class=w> </span><span class=nx>build</span><span class=o>/</span><span class=nx>index</span><span class=p>.</span><span class=nx>js</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=19-typescript->19. Чи підтримує TypeScript всі об'єктно-орієнтовані принципи?<a class=headerlink href=#19-typescript- title="Permanent link">&para;</a></h3> <p>Відповідь - <strong>ТАК</strong>. Існує 4 основних принципи об'єктно-орієнтованого програмування: </p> <ul> <li>Інкапсуляція, </li> <li>Успадкування, </li> <li>абстрагування та </li> <li>поліморфізм. </li> </ul> <p>TypeScript може реалізувати всі чотири принципи за допомогою меншого та чистішого синтаксису.</p> <p><strong>Джерело:</strong> <a href=https://jonathanmh.com/typescript-node-js-tutorial-backend-beginner/ >jonathanmh.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=20-typescript>20. Які об'єктно-орієнтовані терміни підтримуються у TypeScript?<a class=headerlink href=#20-typescript title="Permanent link">&para;</a></h3> <p>TypeScript підтримує наступні об'єктно-орієнтовані терміни:</p> <ul> <li>Модулі</li> <li>Класи</li> <li>Інтерфейси</li> <li>типи даних</li> <li>функції-члени</li> </ul> <p><strong>Джерело:</strong> <a href=http://www.talkingdotnet.com/typescript-interview-questions/ >http://www.talkingdotnet.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=21-typescript-map>21. Що таке файл TypeScript Map?<a class=headerlink href=#21-typescript-map title="Permanent link">&para;</a></h3> <p>Файли `.map' - це файли мапи джерел, які дозволяють інструментам зіставляти код JavaScript, що виводиться, з вихідними файлами TypeScript, які його створили. Багато відладчиків (наприклад, Visual Studio або інструменти для розробників Chrome) можуть споживати ці файли, тому ви можете налагоджувати файл TypeScript замість файлу JavaScript.</p> <p><strong>Джерело:</strong> <a href=https://stackoverflow.com/questions/17493738/what-is-a-typescript-map-file>stackoverflow.com</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=22-typescript>22. Чи можливі в TypeScript сильно типізовані функції в якості параметрів?<a class=headerlink href=#22-typescript title="Permanent link">&para;</a></h3> <p>Розглянемо код:</p> <p><div class="language-js highlight"><pre><span></span><code><span id=__span-105-1><a id=__codelineno-105-1 name=__codelineno-105-1 href=#__codelineno-105-1></a><span class=kd>class</span><span class=w> </span><span class=nx>Foo</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-105-2><a id=__codelineno-105-2 name=__codelineno-105-2 href=#__codelineno-105-2></a><span class=w>    </span><span class=nx>save</span><span class=p>(</span><span class=nx>callback</span><span class=o>:</span><span class=w> </span><span class=nb>Function</span><span class=p>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=ow>void</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-105-3><a id=__codelineno-105-3 name=__codelineno-105-3 href=#__codelineno-105-3></a><span class=w>        </span><span class=c1>//Виконати збереження</span>
</span><span id=__span-105-4><a id=__codelineno-105-4 name=__codelineno-105-4 href=#__codelineno-105-4></a><span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>result</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=nx>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>42</span><span class=p>;</span><span class=w> </span><span class=c1>//Отримуємо число з операції збереження</span>
</span><span id=__span-105-5><a id=__codelineno-105-5 name=__codelineno-105-5 href=#__codelineno-105-5></a><span class=w>        </span><span class=c1>//Чи можна на етапі компіляції зробити так, щоб функція зворотного виклику отримувала єдиний параметр типу number?</span>
</span><span id=__span-105-6><a id=__codelineno-105-6 name=__codelineno-105-6 href=#__codelineno-105-6></a><span class=w>        </span><span class=nx>callback</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
</span><span id=__span-105-7><a id=__codelineno-105-7 name=__codelineno-105-7 href=#__codelineno-105-7></a><span class=w>    </span><span class=p>}</span>
</span><span id=__span-105-8><a id=__codelineno-105-8 name=__codelineno-105-8 href=#__codelineno-105-8></a><span class=p>}</span>
</span><span id=__span-105-9><a id=__codelineno-105-9 name=__codelineno-105-9 href=#__codelineno-105-9></a>
</span><span id=__span-105-10><a id=__codelineno-105-10 name=__codelineno-105-10 href=#__codelineno-105-10></a><span class=kd>var</span><span class=w> </span><span class=nx>foo</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Foo</span><span class=p>();</span>
</span><span id=__span-105-11><a id=__codelineno-105-11 name=__codelineno-105-11 href=#__codelineno-105-11></a><span class=kd>var</span><span class=w> </span><span class=nx>callback</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>result</span><span class=o>:</span><span class=w> </span><span class=nx>string</span><span class=p>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=ow>void</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-105-12><a id=__codelineno-105-12 name=__codelineno-105-12 href=#__codelineno-105-12></a><span class=w>    </span><span class=nx>alert</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
</span><span id=__span-105-13><a id=__codelineno-105-13 name=__codelineno-105-13 href=#__codelineno-105-13></a><span class=p>}</span>
</span><span id=__span-105-14><a id=__codelineno-105-14 name=__codelineno-105-14 href=#__codelineno-105-14></a><span class=nx>foo</span><span class=p>.</span><span class=nx>save</span><span class=p>(</span><span class=nx>callback</span><span class=p>);</span>
</span></code></pre></div> Чи можна зробити параметр result у функції save безпечним за типом? Перепишіть код для демонстрації.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=23-typescript>23. Чи є цей код TypeScript коректним? Поясніть чому<a class=headerlink href=#23-typescript title="Permanent link">&para;</a></h3> <p>Розглянемо: <div class="language-js highlight"><pre><span></span><code><span id=__span-106-1><a id=__codelineno-106-1 name=__codelineno-106-1 href=#__codelineno-106-1></a><span class=kd>class</span><span class=w> </span><span class=nx>Point</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-106-2><a id=__codelineno-106-2 name=__codelineno-106-2 href=#__codelineno-106-2></a><span class=w>    </span><span class=nx>x</span><span class=o>:</span><span class=w> </span><span class=nx>number</span><span class=p>;</span>
</span><span id=__span-106-3><a id=__codelineno-106-3 name=__codelineno-106-3 href=#__codelineno-106-3></a><span class=w>    </span><span class=nx>y</span><span class=o>:</span><span class=w> </span><span class=nx>number</span><span class=p>;</span>
</span><span id=__span-106-4><a id=__codelineno-106-4 name=__codelineno-106-4 href=#__codelineno-106-4></a><span class=p>}</span>
</span><span id=__span-106-5><a id=__codelineno-106-5 name=__codelineno-106-5 href=#__codelineno-106-5></a>
</span><span id=__span-106-6><a id=__codelineno-106-6 name=__codelineno-106-6 href=#__codelineno-106-6></a><span class=kr>interface</span><span class=w> </span><span class=nx>Point3d</span><span class=w> </span><span class=k>extends</span><span class=w> </span><span class=nx>Point</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-106-7><a id=__codelineno-106-7 name=__codelineno-106-7 href=#__codelineno-106-7></a><span class=w>    </span><span class=nx>z</span><span class=o>:</span><span class=w> </span><span class=nx>number</span><span class=p>;</span>
</span><span id=__span-106-8><a id=__codelineno-106-8 name=__codelineno-106-8 href=#__codelineno-106-8></a><span class=p>}</span>
</span><span id=__span-106-9><a id=__codelineno-106-9 name=__codelineno-106-9 href=#__codelineno-106-9></a>
</span><span id=__span-106-10><a id=__codelineno-106-10 name=__codelineno-106-10 href=#__codelineno-106-10></a><span class=kd>let</span><span class=w> </span><span class=nx>point3d</span><span class=o>:</span><span class=w> </span><span class=nx>Point3d</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=nx>x</span><span class=o>:</span><span class=w> </span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=nx>y</span><span class=o>:</span><span class=w> </span><span class=mf>2</span><span class=p>,</span><span class=w> </span><span class=nx>z</span><span class=o>:</span><span class=w> </span><span class=mf>3</span><span class=p>};</span>
</span></code></pre></div></p> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong>.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=24-typescript>24. Які існують різні компоненти TypeScript?<a class=headerlink href=#24-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=25-typescript>25. Як TypeScript є необов'язково статично типізованою мовою<a class=headerlink href=#25-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=26-typescript>26. Який модифікатор доступу за замовчуванням для членів класу у TypeScript?<a class=headerlink href=#26-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=27_1>27. Як зробити класи, визначені в модулі, доступними за межами модуля?<a class=headerlink href=#27_1 title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=28_1>28. Що не так з цим кодом?<a class=headerlink href=#28_1 title="Permanent link">&para;</a></h3> <p><strong>Деталі питання:</strong></p> <div class="language-js highlight"><pre><span></span><code><span id=__span-107-1><a id=__codelineno-107-1 name=__codelineno-107-1 href=#__codelineno-107-1></a><span class=c1>// щось не так</span>
</span><span id=__span-107-2><a id=__codelineno-107-2 name=__codelineno-107-2 href=#__codelineno-107-2></a><span class=kd>function</span><span class=w> </span><span class=nx>reverse</span><span class=p>(</span><span class=nx>s</span><span class=o>:</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=o>:</span><span class=w> </span><span class=nb>String</span><span class=p>;</span>
</span></code></pre></div> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=29-typescript>29. Чи підтримує TypeScript перевантаження функцій?<a class=headerlink href=#29-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=30-javascript-typescript>30. Як використовувати зовнішні бібліотеки простого JavaScript у TypeScript?<a class=headerlink href=#30-javascript-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=31-typescript>31. Що таке типізація в TypeScript?<a class=headerlink href=#31-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=32-vs>32. Яка різниця між операторами "інтерфейс vs тип"?<a class=headerlink href=#32-vs title="Permanent link">&para;</a></h3> <p><strong>Деталі питання:</strong></p> <div class="language-js highlight"><pre><span></span><code><span id=__span-108-1><a id=__codelineno-108-1 name=__codelineno-108-1 href=#__codelineno-108-1></a><span class=kr>interface</span><span class=w> </span><span class=nx>X</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-108-2><a id=__codelineno-108-2 name=__codelineno-108-2 href=#__codelineno-108-2></a><span class=w>    </span><span class=nx>a</span><span class=o>:</span><span class=w> </span><span class=nx>number</span>
</span><span id=__span-108-3><a id=__codelineno-108-3 name=__codelineno-108-3 href=#__codelineno-108-3></a><span class=w>    </span><span class=nx>b</span><span class=o>:</span><span class=w> </span><span class=nx>string</span>
</span><span id=__span-108-4><a id=__codelineno-108-4 name=__codelineno-108-4 href=#__codelineno-108-4></a><span class=p>}</span>
</span><span id=__span-108-5><a id=__codelineno-108-5 name=__codelineno-108-5 href=#__codelineno-108-5></a>
</span><span id=__span-108-6><a id=__codelineno-108-6 name=__codelineno-108-6 href=#__codelineno-108-6></a><span class=nx>type</span><span class=w> </span><span class=nx>X</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-108-7><a id=__codelineno-108-7 name=__codelineno-108-7 href=#__codelineno-108-7></a><span class=w>    </span><span class=nx>a</span><span class=o>:</span><span class=w> </span><span class=nx>number</span>
</span><span id=__span-108-8><a id=__codelineno-108-8 name=__codelineno-108-8 href=#__codelineno-108-8></a><span class=w>    </span><span class=nx>b</span><span class=o>:</span><span class=w> </span><span class=nx>string</span>
</span><span id=__span-108-9><a id=__codelineno-108-9 name=__codelineno-108-9 href=#__codelineno-108-9></a><span class=p>};</span>
</span></code></pre></div> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=33-typescript>33. Як би ви перевантажили конструктор класу у TypeScript?<a class=headerlink href=#33-typescript title="Permanent link">&para;</a></h3> <p>Дивіться 👉 <strong><a href=https://www.fullstack.cafe/TypeScript>Відповідь</a></strong></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=34-wrong>34. Поясніть, чому цей код позначено як WRONG?<a class=headerlink href=#34-wrong title="Permanent link">&para;</a></h3> <p><strong>Деталі питання:</strong></p> <div class="language-js highlight"><pre><span></span><code><span id=__span-109-1><a id=__codelineno-109-1 name=__codelineno-109-1 href=#__codelineno-109-1></a><span class=cm>/* WRONG */</span>
</span><span id=__span-109-2><a id=__codelineno-109-2 name=__codelineno-109-2 href=#__codelineno-109-2></a><span class=kr>interface</span><span class=w> </span><span class=nx>Fetcher</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-109-3><a id=__codelineno-109-3 name=__codelineno-109-3 href=#__codelineno-109-3></a><span class=w>    </span><span class=nx>getObject</span><span class=p>(</span><span class=nx>done</span><span class=o>:</span><span class=w> </span><span class=p>(</span><span class=nx>data</span><span class=o>:</span><span class=w> </span><span class=nx>any</span><span class=p>,</span><span class=w> </span><span class=nx>elapsedTime</span><span class=o>?:</span><span class=w> </span><span class=nx>number</span><span class=p>)</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=ow>void</span><span class=p>)</span><span class=o>:</span><span class=w> </span><span class=ow>void</span><span class=p>;</span>
</span><span id=__span-109-4><a id=__codelineno-109-4 name=__codelineno-109-4 href=#__codelineno-109-4></a><span class=p>}</span>
</span></code></pre></div> <hr> <h1 id=-cicd>Відповіді - 'CI/CD'<a class=headerlink href=#-cicd title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1-cicd>1. Що таке CI/CD<a class=headerlink href=#1-cicd title="Permanent link">&para;</a></h3> <ul> <li> <p>Безперервна інтеграція (Continuous Integration/CI)* - методологія розробки та набір практик, у яких код вносяться невеликі зміни з частими комитами. Оскільки більшість сучасних додатків розробляються з використанням різних платформ та інструментів, то виникає потреба в механізмі інтеграції та тестуванні змін, що вносяться. Мета CI — забезпечити послідовний та автоматизований спосіб складання, пакування та тестування додатків.</p> </li> <li> <p>Безперервне постачання (Continuous Delivery/CD)* - ґрунтується на автоматизації складання та тестування, яке вводить безперервна інтеграція. Вона передбачає переведення ручних кроків, необхідних для випуску складання додатків у продакшн, на автоматизований процес.</p> </li> </ul> <p><em>Безперервне розгортання (Continuous Deployment/CD)</em> - після автоматизації релізу залишається один ручний етап: схвалення та запуск розгортання в продакшен. Практика безперервного розгортання скасовує це, не вимагаючи безпосереднього затвердження з боку розробника. Усі зміни автоматично розгортаються.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2-cicd>2. Послідовність виконання CI/CD процесу на проекті<a class=headerlink href=#2-cicd title="Permanent link">&para;</a></h3> <ol> <li>Написання коду</li> <li>Складання</li> <li>Тестування</li> <li>Реліз</li> <li>Розгортання</li> <li>Підтримка та моніторинг</li> <li>Планування</li> </ol> <p><img alt=IMG src=images/CI_CD.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3-ci>3. Як автоматичне тестування інтегрується в CI<a class=headerlink href=#3-ci title="Permanent link">&para;</a></h3> <p>Безперервна інтеграція та безперервне постачання потребують безперервного тестування. Безперервне тестування часто реалізується у вигляді набору різних автоматизованих тестів (регресійних, продуктивності та інших), які виконуються у CI/CD-конвеєрі.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4>4. Які інструменти для генерації репорту після виконання автоматичних тестів ви знаєте<a class=headerlink href=#4 title="Permanent link">&para;</a></h3> <ul> <li>Allure, Serenity *</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5>5. Яку інформацію має містити звіт про виконання автоматичних тестів<a class=headerlink href=#5 title="Permanent link">&para;</a></h3> <p>Виходячи з пріоритетів цільової аудиторії, ми маємо визначити, яку інформацію має містити звіт. Відповідно, в ході проекту інформація повинна консолідуватися за тим напрямком, який необхідно відобразити. Ми можемо виділити три групи цільових аудиторій: 1. Технічні користувачі - Test-manager. Для них пріоритетне розуміння ходу тестування, які виникають проблеми, як вони вирішуються, побудова самого процесу тестування, опис методів і технологій, що застосовуються. 2. Product Manager, вони ж Менеджери продукту. Їх фокус сконцентрований на термінах виконання, вичавках із результатів тестування без зайвих технічних подробиць та на загальній статистиці (цифрові та порівняльні метрики). 3. Бізнес-користувачі. Зазвичай це є ті люди, які приймають рішення щодо завершення тестування. Вони ж визначають якість виконаної роботи. Для них, насамперед, важливим є кінцевий результат у максимально короткому та ясному форматі (так\ні), наочне подання інформації (графіки, діаграми), експертна думка про можливість випуску продукту в промислове середовище тощо, без поглиблення в деталі .</p> <hr> <h1 id=->Відповіді - 'Основні принципи програмування'<a class=headerlink href=#- title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1-http>1. Статуси відповідей HTTP<a class=headerlink href=#1-http title="Permanent link">&para;</a></h3> <p>Коди згруповано в 5 класів: 1. інформаційні 100 - 199 2. Успішні 200 - 299 3. Перенаправлення 300 - 399 4. Клієнтські помилки 400 - 499 5. Серверні помилки 500 - 599</p> <p>Детальніше <a href=https://developer.mozilla.org/ru/docs/Web/HTTP/Status>https://developer.mozilla.org/ru/docs/Web/HTTP/Status</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2-dry-kiss-yagni>2. Що таке DRY, KISS, YAGNI<a class=headerlink href=#2-dry-kiss-yagni title="Permanent link">&para;</a></h3> <p><strong>DRY</strong> (Don't Repeat Yourself - Не повторюйся) Уникайте повторного написання коду, виносячи в абстракції завдання і дані, що часто використовуються. Кожна частина вашого коду або інформації повинна знаходитися в однині в доступному місці. Це один із принципів коду, що читається.</p> <p><strong>KISS</strong> (Keep It Simple, Stupid/Keep It Simple and Straightforward - Будь простіше) Не вигадуйте до завдання складнішого рішення, ніж йому потрібно. Простота коду - понад усе, тому що простий код - найбільш зрозумілий.</p> <p><strong>YAGNI</strong> (You Aren't Gonna Need It - Вам це не знадобиться) Якщо пишете код, будьте впевнені, що він вам знадобиться. Не пишіть код, якщо думаєте, що він стане в нагоді пізніше. Якщо ви займаєтеся рефакторинг методу, класу або файлу, не бійтеся видаляти зайві методи. Навіть якщо раніше вони були корисними – тепер вони не потрібні.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3-gof>3. Які патерни GOF вам відомі? Наведіть приклади їхнього використання<a class=headerlink href=#3-gof title="Permanent link">&para;</a></h3> <p><em>Стратегія (Strategy)</em> - пропонує визначити сімейство подібних алгоритмів, які часто змінюються чи розширюються, і винести в власні класи, звані стратегіями. <strong>Приклад</strong>: спосіб побудови маршруту в навігаторі (для авто, пішохода, велосипедиста, громадським транспортом)</p> <p><em>Будівельник (Builder)</em> - поділяє створення складного об'єкта та ініціалізацію його стану так, що однаковий процес побудови може створити об'єкти з різним станом. <strong>Приклад</strong>: <em>позбавлення від зайвих опцій конструктора (Lombok та створення екземплярів класу), StringBuilder</em></p> <p><em>Ітератор (Iterator)</em> - надає спосіб послідовного доступу до елементів множини незалежно від внутрішнього пристрою. <strong>Приклад</strong>: <em>foreach</em></p> <p><em>Одиночка (Singleton)</em> - гарантує, що клас має лише один екземпляр і надає глобальний струм доступу до нього. <strong>Приклад</strong>: <em>загальний доступ до бази даних із різних частин програми, selenium driver</em></p> <p><em>Фабричний метод (Factory Method)</em> - визначає інтерфейс до створення об'єкта, але дозволяє підкласам вирішувати, який клас інстанціювати. Дозволяє делегувати створення об'єкта підкласів.</p> <p><em>Абстрактна фабрика (Abstarct Factory)</em> - надає інтерфейс для створення груп пов'язаних чи залежних об'єктів, не вказуючи їх конкретний клас.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4-pageobject-pagefactory>4. PageObject та PageFactory<a class=headerlink href=#4-pageobject-pagefactory title="Permanent link">&para;</a></h3> <p><em>Page Object</em> - патерн при якому кожної сторінки тестованого докладання створюється окремий об'єкт, методи якого інкапсулюють логіку роботи з окремими елементами. Дозволяє зменшити кількість коду та спростити його підтримку. * Page Factory * - реалізація патерну Factory для створення екземплярів сторінок вбудована в Selenium.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5-collections>5. Яка ієрархія Collections<a class=headerlink href=#5-collections title="Permanent link">&para;</a></h3> <p><em>Інтерфейси</em>: * Collection * List * Set * Map * Sorted Set * Sorted Map * Queue</p> <p><em>Класи</em>: * Lists: * ArrayList * LinkedList * Vector(deprecated) * Sets * HashSet * LinkedHashSet * TreeSet * Maps * HashMap * TreeMap * HashTable (deprecated) * LinkedHashMap * Queue * Priority Queue</p> <p><img alt=IMG src=images/difficulty.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=6-thread-class-runnable-interface>6. Різниця між Thread class та Runnable interface<a class=headerlink href=#6-thread-class-runnable-interface title="Permanent link">&para;</a></h3> <p>Багатопоточність програми Java організується за допомогою інтерфейсу Runnable і класу Thread, який успадковується від Runnable. Перший спосіб більш гнучкий, другий – простіше. Коли власний клас повинен успадковуватися від іншого класу (не Thread), доводиться використовувати успадкування від інтерфейсу Runnable, т.к. в Java немає множинного успадкування класів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=7-string-stringbuffer-stringbuilder>7. Різниця між String, Stringbuffer і Stringbuilder<a class=headerlink href=#7-string-stringbuffer-stringbuilder title="Permanent link">&para;</a></h3> <p><strong>String</strong> Рядки в Java є імунними (не можуть бути змінені). При зміні об'єкта String Java щоразу створюється абсолютно новий об'єкт. При використанні оператора new для створення в пам'яті купи щоразу буде створюватись новий об'єкт String. При використанні літералу об'єкта ("some string"), якщо такий об'єкт вже існує в купі, новий об'єкт не з'явиться, а змінна змінна буде вказувати на існуючий об'єкт.</p> <p><strong>StringBuilder</strong> Клас StringBuilder є альтернативою класу String, оскільки створює мутабельний (змінюваний) набір символів. Клас StringBuilder не забезпечує синхронізацію: екземпляри класу StringBuilder не можуть спільно використовувати кілька потоків. Для операцій з рядками в середовищі, що не є багатопотоковим, варто використовувати StringBuilder, тому що він швидше, ніж StringBuffer.</p> <p><strong>StringBuffer</strong> Клас StringBuffer також створює змінний рядковий об'єкт і містить самі методи, як і StringBuilder. Різниця між ними в тому, що клас StringBuffer є потокобезпечним і синхронізованим: екземпляри класу StringBuffer можуть спільно використовуватися кількома потоками. Для операцій із рядками у багатопотокових середовищах варто використовувати StringBuffer.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=8-final-finally-finalize>8. Різниця між final, finally та finalize<a class=headerlink href=#8-final-finally-finalize title="Permanent link">&para;</a></h3> <p><em>final</em> – модифікатор, який застосовується до змінних, полів, методів та класів. Змінна або поле стає незмінною і потребує ініціалізації. Фінальний метод не можна перевизначити у спадкоємцях. Фінальний клас неспроможна мати спадкоємців взагалі.</p> <p><em>finally</em> – частина мовної конструкції try-catch-finally.</p> <p><em>finalize</em> - метод класу Object. Складальник сміття викликає його для об'єктів, на які більше немає посилань і які позначені для збору сміття. Deprecated з Java 9.</p> <hr> <h1 id=-_1>Відповіді - 'Теорія тестування'<a class=headerlink href=#-_1 title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1>1. Що таке тестування<a class=headerlink href=#1 title="Permanent link">&para;</a></h3> <p>Тестування - це процес перевірки програмного продукту з метою виявлення помилок, дефектів і недоробок, а також оцінки його якості.<br> Воно включає в себе створення і виконання тестових сценаріїв з метою переконатися у відповідності продукту заданим вимогам і очікуванням користувачів. Ще включає в себе планування, проєктування і, власне, виконання тестів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2_1>2. Навіщо тестувати програмне забезпечення<a class=headerlink href=#2_1 title="Permanent link">&para;</a></h3> <p>Тестування ПЗ необхідне для забезпечення надійності, якості та функціональності продукту.<br> Воно допомагає виявити помилки на ранніх стадіях розробки, знижує ризики неполадок у роботі, покращує користувацький досвід і довіру до продукту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3>3. Які існують етапи тестування<a class=headerlink href=#3 title="Permanent link">&para;</a></h3> <p>Загалом виділяють 7 етапів тестування:<br> 1. <strong>Робота з вимогами.</strong><br> 1.1 Знайомство з вимогами замовника. Обговорення, що має являти собою підсумковий продукт 2. <strong>Розробка стратегії тестування.</strong><br> 2.1 Оцінка термінів тестування, виявлення середовища тестування, об'єднання всієї інформації, отриманої під час роботи з вимогами. 3. <strong>Створення тестової документації.</strong><br> 3.1 Написання сценаріїв, які дадуть змогу перевірити функціонал. 4. <strong>Тестування прототипу.</strong><br> 4.1 Тестування основного функціоналу продукту, коригування цілей, додавання фічей. 5. <strong>Основне тестування.</strong><br> 5.1 Виконання загальної перевірки продукту. 6. <strong>Стабілізація.</strong><br> 6.1 На цьому етапі відбувається робота над усуненням багів. 7. <strong>Експлуатація.</strong><br> 7.1 Проводиться регрес-тестування, усунення помилок, які знайшов кінцевий користувач.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4_1>4. Які типи тестування можна назвати<a class=headerlink href=#4_1 title="Permanent link">&para;</a></h3> <p>Залежно від потреб процес тестування повинен бути організований відповідним чином. Отже, ми можемо визначити 4 види тестування програмного забезпечення:</p> <ol> <li>функціональне тестування (Functional testing);</li> <li>нефункціональне тестування (Non-functional testing);</li> <li>структурне тестування (Structural testing);</li> <li>тестування змін (Change related testing).</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5_1>5. Які рівні тестування ви знаєте<a class=headerlink href=#5_1 title="Permanent link">&para;</a></h3> <p>Тестування на різних рівнях проводиться протягом усього життєвого циклу розробки і супроводу ПЗ. Рівень тестування визначає те, над чим виробляються тести: над окремим модулем, групою модулів або системою в цілому. Проведення тестування на всіх рівнях системи – це запорука успішної реалізації та здачі проекту.</p> <ul> <li> <p>Рівні тестування (Testing levels):</p> <ul> <li>Компонентне або Модульне тестування (Component testing or Unit testing)</li> <li>Інтеграційне тестування (Integration testing)</li> <li>Системне тестування (System testing)</li> <li>Приймальне тестування (Acceptance testing)</li> </ul> </li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=6_1>6. Які техніки проектування тестів ви знаєте<a class=headerlink href=#6_1 title="Permanent link">&para;</a></h3> <ul> <li><strong>Техніки, що базуються на досвіді й інтуїції</strong><ul> <li>Спеціалізоване тестування (Ad hoc testing).</li> <li>Дослідне тестування (Exploratory testing)</li> </ul> </li> <li><strong>Техніки, що базуються на специфікації</strong><ul> <li>Еквівалентне розділення (Equivalence partitioning).</li> <li>Аналіз граничних значень (Boundary-value analysis).</li> <li>Таблиці прийняття рішень (Decision table)</li> <li>Тести на основі скінченого автомату (Finite-state machine-based)</li> <li>Тестування на основі формальної специфікації (Testing from formal specification)</li> <li>Випадкове тестування (Random testing)</li> </ul> </li> <li><strong>Техніки, орієнтовані на код</strong><ul> <li>Тести, що базуються на блок-схемі (Control-flow-based criteria).</li> <li>Тести на основі потоків даних (Data-flow-based criteria)</li> <li>Тестування, орієнтоване на дефекти (Fault-based techniques)</li> <li>Передбачення помилок (Error guessing)</li> <li>Тестування мутацій (Mutation testing).</li> <li>Операційний профіль (Operational profile)</li> <li>Тестування на основі надійності інженерного процессу (Software Reliability Engineered Testing)</li> <li>Техніки, що базуються на природі застосування (Techniques based on the nature of the application)</li> </ul> </li> <li><strong>Комбінації технік</strong><ul> <li>Функціональне тестування та структурне тестування (Functional and structural)</li> </ul> </li> </ul> <p>Детальніше: <a href=https://elib.lntu.edu.ua/sites/default/files/elib_upload/%D0%A2%D0%B5%D1%81%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F/page18.html>https://elib.lntu.edu.ua/sites/default/files/elib_upload/%D0%A2%D0%B5%D1%81%D1%82%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F/page18.html</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=7>7. Що таке техніка аналізу класів еквівалентності<a class=headerlink href=#7 title="Permanent link">&para;</a></h3> <p>Поділ на класи еквівалентності – це техніка, при якій функціонал (діапазон можливих вхідних значень) розділяється на групи значень еквівалентних за своєю дією на систему.</p> <p>Нижче розглянемо приклад поділу на класи еквівалентності.</p> <p>Є поле з допустимим діапазоном значень введення від 1 до 1000. Вводити весь діапазон — досить довгий процес. Тим більше, є ще неприпустимі значення (спецсимволи, негативні числа, букви і та ін.), введення яких потрібно перевірити.</p> <p>Як говорилося вище, всі значення одного класу еквівалентності однаково впливають на систему, тобто допустимі значення система приймає, а недопустимі – ні. В поле повинно бути заборонено введення неприпустимих значень.</p> <p>Таким чином, можна виділити два класи еквівалентності:</p> <ul> <li>Можна вибрати зі значень числа від 1 до 1000.</li> <li>Неприпустимі значення: числа від -∞ до 0, від 1001 до + ∞, а також всі інші літери і символи.</li> </ul> <p>Клас з неприпустимими значеннями можна розбити на кілька:</p> <ul> <li>Від - ∞ до 0.</li> <li>Від 1001 до + ∞.</li> <li>Спеціальні символи (# @ + - / _:; " 'і т.д.).</li> <li>Літери.</li> </ul> <p>В результаті, завдяки класам еквівалентності можна використовувати мінімум 5 тестів для тестування поля введення. Наприклад, в поле ввести наступні дані: 46, -37, 1773, Ім'я, $ _ = #.</p> <p>Техніку поділу на класи еквівалентності застосовують для скорочення числа тестів, при цьому зберігаючи прийнятне тестове покриття. Дана техніка підходить також для текстових або інших типів даних.</p> <p><strong>Кроки застосування техніки поділу на класи еквівалентності наступні:</strong></p> <ol> <li>Визначити класи еквівалентності. Від правильності виконання даного кроку залежить ефективність майбутнього тестування.</li> <li>Вибрати представника кожного класу.</li> <li>Виконати тести.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=8>8. Що таке техніка аналізу межових значень? В чому цінність цієї техніки<a class=headerlink href=#8 title="Permanent link">&para;</a></h3> <p>Ця техніка фокусується на тестуванні в крайніх точках діапазонів даних, таких як мінімальні та максимальні значення. Вона дає змогу виявити помилки, пов'язані з некоректним опрацюванням крайніх випадків.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=9-regression-confirmation>9. Що таке Regression і Confirmation тестування, в чому різниця між ними<a class=headerlink href=#9-regression-confirmation title="Permanent link">&para;</a></h3> <blockquote> <p>Confirmation testing (re-testing) - Тестування, у якому виконуються тестові сценарії, які були пройдені під час останнього запуску, з метою підтвердити успішність виправлень.</p> <p>Регресійне тестування – це набір тестів, спрямованих на виявлення дефектів у вже протестованих модулях додатка.<br> Робиться це зовсім не для того, щоб остаточно переконатися у відсутності багів, а для пошуку та виправлення регресійних помилок.<br> Регресійні помилки – ті ж баги, але з’являються вони не при написанні програми, а при додаванні в існуючий білд нової частини програми або виправлення інших багів, що і стає причиною виникнення нових дефектів у вже протестованому продукті.</p> </blockquote> <p>Таким чином, ми можемо сказати, що мета регресійного тестування – переконатися, що виправлення одних багів не стало причиною виникнення інших і що оновлення білду не створило нових дефектів у вже перевіреному коді.</p> <p>Є кілька видів регресійних тестів:</p> <ul> <li>Верифікаційні тести. Проводять для перевірки виправлення виявленого та відкритого раніше бага.</li> <li>Тестування верифікації версії. Містить принципи димного тестування та тестування зборки: перевірка працездатності основної функціональності програми в кожній новій версії.</li> <li>Безпосередньо саме регресійне тестування – повторне виконання всіх тестів, які були написані та проведені раніше. Вони виконуються по вже існуючих тест-кейсам незалежно від того, були в ході їх проходження знайдені баги, чи ні.</li> <li>Тестування в новому білді вже виправлених багів в старих білдах. Це виконується для того, щоб перевірити, чи не відновило оновлення білду старих дефектів.</li> </ul> <p>Деякі положення щодо того, як проводити регресійне тестування:</p> <ul> <li>Даний вид тестування проводиться в кожному новому білді.</li> <li>Починати потрібно з верифікації версії (тестування зборки та димне тестування).</li> <li>Перевірка виправлених багів.</li> <li>Регресійне тестування, в основному, не покриває весь додаток, а тільки ті ділянки, які тим чи іншим способом «стикаються» зі змінами в білді.</li> </ul> <p>Далі тестуються вже закриті раніше баги.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=10_1>10. Як часто варто проводити регресійне тестування продукту<a class=headerlink href=#10_1 title="Permanent link">&para;</a></h3> <p>1) Регресійне тестування рекомендується проводити кілька разів (3-5). Тому, з метою економії дорогоцінного часу (і, може бути, для позбавлення від «рутинності») в регресійних тестах активно використовують засоби автоматизації тестування. 2) Проведення фінального регресійного тестування, для якого відбираються тести по пріоритету, що визначаються найбільшою кількістю знайдених помилок.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=11_3>11. Які існують види інтеграційного тестування<a class=headerlink href=#11_3 title="Permanent link">&para;</a></h3> <p>Існує три різні підходи до інтеграційного тестування: 1. інтеграційне тестування згори вниз 2. інтеграційне тестування знизу вгору 3. сендвіч-інтеграційне тестування.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=12-configuration-testing>12. Що таке Configuration testing<a class=headerlink href=#12-configuration-testing title="Permanent link">&para;</a></h3> <p>Конфігураційне тестування(Configuration Testing) - спеціальний вид тестування, спрямований на перевірку роботи програмного забезпечення при різних конфігураціях системи (заявлених платформах, підтримуваних драйвери, при різних конфігураціях комп'ютерів і т. Д.)</p> <p>Залежно від типу проекту конфигурационное тестування може мати різні цілі:</p> <ol> <li> <p>Проект по профілізації роботи системи. Мета тестування: визначити оптимальну конфігурацію обладнання, що забезпечує необхідні характеристики продуктивності та часу реакції тестованої системи.</p> </li> <li> <p>Проект з міграції системи з однієї платформи на іншу. Мета тестування: Перевірити об'єкт тестування на сумісність з оголошеним в специфікації обладнанням, операційними системами та програмними продуктами третіх фірм.</p> </li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=13-exploratory-testing>13. Що таке Exploratory testing<a class=headerlink href=#13-exploratory-testing title="Permanent link">&para;</a></h3> <p>Дослідницьке тестування (exploratory testing) – це одночасне вивчення програмного продукту, проєктування тестів і їх виконання. Тестувальник активно контролює проєктування тестів в той час, як ці тести виконуються, і використовує отриману під час тестування інформацію для проєктування нових тестів.</p> <p>Якщо кожен наступний тест, який виконує тестувальник, вибирається за результатами попереднього тесту, це означає, що ми використовуємо дослідницьке тестування.</p> <p>Цей підхід можна застосувати до будь-якого виду тестування. Ще один важливий момент полягає в тому, що дослідницьке тестування – це не тільки виконання тестів. Тестувальники можуть застосовувати дослідницький підхід і при розробці нових тестів на початку ітерації, і при аналізі вже завершених тестів. Також, дослідницьке тестування не повинно виконуватися недбало, в поспіху і без підготовки.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=14-ui->14. Які існують UI-стандарти<a class=headerlink href=#14-ui- title="Permanent link">&para;</a></h3> <p>Існує багато різних UI-стандартів, які використовуються для розробки користувацьких інтерфейсів.<br> Деякі з них є загальноприйнятими у галузі програмної розробки та дизайну. Ось декілька прикладів таких стандартів:</p> <ol> <li> <p><strong>Material Design</strong>: Розроблений компанією Google, цей стандарт використовує візуальні та рухові ефекти для створення сучасних та легких у використанні користувацьких інтерфейсів. Material Design акцентується на реалістичний вигляд, використання тіней, кольорів та анімацій.</p> </li> <li> <p><strong>iOS Human Interface Guidelines</strong>: Розроблений компанією Apple, цей стандарт визначає рекомендації та принципи для розробки інтерфейсів додатків для пристроїв Apple. Він ставить акцент на простоту, чіткість та консистентність в дизайні.</p> </li> <li> <p><strong>Bootstrap</strong>: Це фреймворк для веб-розробки, який надає набір стандартних компонентів та стилів, що допомагають швидше створювати сучасні та адаптивні веб-інтерфейси.</p> </li> <li> <p><strong>Flat Design</strong>: Цей стиль дизайну характеризується використанням плоских елементів, яскравих кольорів та мінімалістичних деталей. Flat design намагається забезпечити простоту та прямолінійність.</p> </li> <li> <p><strong>Material Design Lite (MDL)</strong>: Це легка версія Material Design, яка надає компоненти та стилі для швидкої імплементації веб-інтерфейсів.</p> </li> <li> <p><strong>Windows User Experience Guidelines</strong>: Стандарти розробки інтерфейсів для операційних систем Windows, розроблені компанією Microsoft. Вони надають рекомендації для розробників, як реалізувати інтерфейси, що відповідають стилю Windows.</p> </li> <li> <p><strong>Semantic UI</strong>: Це ще один фреймворк для веб-розробки, який намагається забезпечити логічний та семантичний підхід до створення інтерфейсів.</p> </li> <li> <p><strong>Foundation</strong>: Це інший варіант фреймворка для веб-розробки, який надає набір інструментів для швидкого створення адаптивних та дружніх до мобільних пристроїв інтерфейсів.</p> </li> <li> <p>Це лише кілька прикладів існуючих UI-стандартів. Вибір стандарту залежить від потреб вашого проекту, цільової аудиторії та інших факторів.</p> </li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=15-blackgreywhite-box-testing>15. Що таке Black/Grey/White Box Testing<a class=headerlink href=#15-blackgreywhite-box-testing title="Permanent link">&para;</a></h3> <ul> <li> <ul> <li>Тестування білої скриньки (white box testing)* - тестування, що базується на аналізі внутрішньої структури компонента або системи та на знанні вихідного коду, до якого тестувальник (як правило, це програміст) має повний доступ.</li> </ul> </li> <li> <p><em>Тестування сірої скриньки (gray box testing)</em> - тестування, орієнтоване на імітацію роботи користувачів, в умовах, коли частина внутрішньої структури програми відома.</p> </li> <li> <p><em>Тестування чорної скриньки (black box testing)</em> - тестування, що базується на аналізі функціональної або нефункціональної специфікації системи, за якого програма розглядається як об'єкт, внутрішня структура якого невідома.</p> </li> </ul> <h6 id=_2>######################################################################################################<a class=headerlink href=#_2 title="Permanent link">&para;</a></h6> <p><strong>Black Box(чорна скринька)</strong></p> <p>Summary: Ми не знаємо, як влаштована тестована система.</p> <p>Тестування методом "чорної скриньки", також відоме як тестування, що ґрунтується на специфікації, або тестування поведінки, - техніка тестування, що ґрунтується на роботі винятково із зовнішніми інтерфейсами тестованої системи.</p> <p>Згідно з ISTQB:</p> <p>тестування чорної скриньки - це:</p> <ul> <li> <p>тестування, як функціональне, так і нефункціональне, що не передбачає знання внутрішнього устрою компонента або системи.</p> </li> <li> <p>тест-дизайн, заснований на техніці чорної скриньки - процедура написання або вибору тест-кейсів на основі аналізу функціональної або нефункціональної специфікації компонента або системи без знання її внутрішнього устрою.</p> </li> </ul> <p>Чому саме "чорна скринька"? Програма, що тестується, для тестувальника - як чорний непрозорий ящик, вмісту якого він не бачить. Метою цієї техніки є пошук помилок у таких категоріях:</p> <ul> <li> <p>неправильно реалізовані або відсутні функції;</p> </li> <li> <p>помилки інтерфейсу;</p> </li> <li> <p>помилки в структурах даних або організації доступу до зовнішніх баз даних;</p> </li> <li> <p>помилки поведінки або недостатня продуктивність системи;</p> </li> </ul> <p>Таким чином, ми не маємо уявлення про структуру і внутрішній устрій системи. Потрібно концентруватися на тому, що програма робить, а не на тому, як вона це робить.</p> <p>Приклад:</p> <p>Тестувальник проводить тестування веб-сайту, не знаючи особливостей його реалізації, використовуючи тільки передбачені розробником поля введення та кнопки. Джерело очікуваного результату - специфікація.</p> <p>Оскільки це тип тестування, за визначенням він може включати інші його види. Тестування чорної скриньки може бути як функціональним, так і нефункціональним. Функціональне тестування передбачає перевірку роботи функцій системи, а нефункціональне - відповідно, загальні характеристики нашої програми.</p> <p>Техніка чорної скриньки застосовна на всіх рівнях тестування (від модульного до приймального), для яких існує специфікація. Наприклад, під час здійснення системного або інтеграційного тестування, вимоги або функціональна специфікація будуть основою для написання тест-кейсів.</p> <p>Техніки тест-дизайну, що базуються на використання чорної скриньки, включають:</p> <ul> <li> <p>класи еквівалентності;</p> </li> <li> <p>аналіз граничних значень;</p> </li> <li> <p>таблиці рішень;</p> </li> <li> <p>діаграми зміни стану;</p> </li> <li> <p>тестування всіх пар.</p> </li> </ul> <p>Переваги:</p> <ul> <li> <p>тестування проводиться з позиції кінцевого користувача і може допомогти виявити неточності та суперечності в специфікації;</p> </li> <li> <p>тестувальнику немає необхідності знати мови програмування і заглиблюватися в особливості реалізації програми;</p> </li> <li> <p>тестування може здійснюватися фахівцями, незалежними від відділу розробки, що допомагає уникнути упередженого ставлення;</p> </li> <li> <p>можна починати писати тест-кейси, щойно готова специфікація.</p> </li> </ul> <p>Недоліки:</p> <ul> <li> <p>тестується тільки дуже обмежена кількість шляхів виконання програми;</p> </li> <li> <p>без чіткої специфікації (а це скоріше реальність на багатьох проєктах) досить важко скласти ефективні тест-кейси;</p> </li> <li> <p>деякі тести можуть виявитися надлишковими, якщо вони вже були проведені розробником на рівні модульного тестування;</p> </li> </ul> <p>Протилежністю техніки чорної скриньки є тестування методом білої скриньки, мова про яке піде нижче.</p> <h6 id=_3><a class=headerlink href=#_3 title="Permanent link">&para;</a></h6> <p><strong>White Box (біла скринька)</strong></p> <p>Summary: Нам відомі всі деталі реалізації тестованої програми.</p> <p>Тестування методом білої скриньки (також: прозорої, відкритої, скляної скриньки; засноване на коді або структурне тестування) - метод тестування програмного забезпечення, який передбачає, що внутрішня структура/пристрій/реалізація системи відомі тестувальнику. Ми вибираємо вхідні значення, ґрунтуючись на знанні коду, який буде їх обробляти. Так само ми знаємо, яким має бути результат цієї обробки. Знання всіх особливостей тестованої програми та її реалізації - обов'язкові для цієї техніки. Тестування білої скриньки - заглиблення у внутрішній устрій системи, за межі її зовнішніх інтерфейсів.</p> <p>Згідно з ISTQB:</p> <p>тестування білої скриньки - це:</p> <ul> <li> <p>тестування, засноване на аналізі внутрішньої структури компонента або системи.</p> </li> <li> <p>тест-дизайн, заснований на техніці білої скриньки - процедура написання або вибору тест-кейсів на основі аналізу внутрішнього устрою системи або компонента.</p> </li> </ul> <p>Чому "білий ящик"? Програма, що тестується, для тестувальника - прозора скринька, вміст якої він прекрасно бачить.</p> <p>Приклад:</p> <p>Тестувальник, який зазвичай є програмістом, вивчає реалізацію коду поля введення на веб-сторінці, визначає всі передбачені (як правильні, так і неправильні) і не передбачені користувацькі введення, і порівнює фактичний результат виконання програми з очікуваним. При цьому очікуваний результат визначається саме тим, як має працювати код програми.</p> <p>Тестування методом білої скриньки схоже на роботу механіка, який вивчає двигун машини, щоб зрозуміти, чому вона не заводиться.</p> <p>Техніка білої скриньки може бути застосована на різних рівнях тестування - від модульного до системного, але головним чином застосовується саме для реалізації модульного тестування компонента його автором.</p> <p>Переваги:</p> <ul> <li> <p>тестування може здійснюватися на ранніх етапах: немає необхідності чекати створення користувацького інтерфейсу;</p> </li> <li> <p>можна провести більш ретельне тестування, з покриттям великої кількості шляхів виконання програми.</p> </li> </ul> <p>Недоліки:</p> <ul> <li> <p>для виконання тестування білої скриньки необхідна велика кількість спеціальних знань</p> </li> <li> <p>при використанні автоматизації тестування на цьому рівні, підтримка тестових скриптів може виявитися досить накладною, якщо програма часто змінюється.</p> </li> </ul> <h6 id=_4><a class=headerlink href=#_4 title="Permanent link">&para;</a></h6> <p><strong>Grey Box (сіра скринька)</strong></p> <p>Summary: Нам відомі тільки деякі особливості реалізації тестованої системи.</p> <p>Тестування методом сірої скриньки - метод тестування програмного забезпечення, який передбачає комбінацію White Box і Black Box підходів. Тобто, внутрішній устрій програми нам відомий лише частково. Передбачається, наприклад, доступ до внутрішньої структури та алгоритмів роботи ПЗ для написання максимально ефективних тест-кейсів, але саме тестування проводиться за допомогою техніки чорної скриньки, тобто, з позиції користувача.</p> <p>Цю техніку тестування також називають методом напівпрозорого ящика: щось ми бачимо, а щось - ні.</p> <p>Приклад:</p> <p>Тестувальник вивчає код програми для того, щоб краще розуміти принципи її роботи та вивчити можливі шляхи її виконання. Таке знання допоможе написати тест-кейс, який напевно перевірятиме певну функціональність.</p> <p>Техніка сірої скриньки застосовна на різних рівнях тестування - від модульного до системного, але головним чином застосовується на інтеграційному рівні для перевірки взаємодії різних модулів програми.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=16-performance-testing>16. Що таке Performance Testing<a class=headerlink href=#16-performance-testing title="Permanent link">&para;</a></h3> <p>Тестування продуктивності (Performance Testing) – визначає наскільки тестований додаток стабільний, а також досліджує показники швидкості реакції програми на зовнішні впливи при різному за характером та інтенсивністю навантаження. Метою тестування є виявлення недоліків і вразливостей в системі, визначення швидкості завантаження даних і їх обробки, надійності програми.</p> <p>Тестування параметрів роботи системи можна проводити за допомогою:</p> <ul> <li>визначення допустимої кількості користувачів додатка;</li> <li>вимірювання часу виконання тієї чи іншої операції системи;</li> <li>визначення допустимих меж продуктивності програми з різними рівнями навантаження.</li> <li> <p>Тестування продуктивності можна розділити на наступні підвиди:</p> </li> <li> <p>навантажувальне;</p> </li> <li>стресове;</li> <li>стабільності;</li> <li>конфігураційне.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=17-smoke-sanity>17. Що таке Smoke і Sanity тестування і в чому різниця між ними<a class=headerlink href=#17-smoke-sanity title="Permanent link">&para;</a></h3> <p>Smoke Testing - швидке поверхневе тестування основних функцій після складання, щоб переконатися, що система готова для глибшого тестування. Sanity Testing - перевірка основних функцій і фіксованих дефектів після їх виправлення для переконання, що продукт готовий до більш повного тестування. Основна різниця - фокус і мета тестування.</p> <p>Переваги димового тестування:</p> <ul> <li>відразу знаходяться проблеми інтеграції;,</li> <li>тестування розкриває проблеми на ранній стадії;</li> <li>забезпечує певний рівень впевненості в тому, що зміни в програмному забезпеченні не зробили несприятливої дії на основні області системи;</li> <li>збій при димовому тестуванні призводить до негайної відмови від цієї збірки програмного забезпечення.</li> </ul> <p><strong>Декілька важливих особливостей санітарного тестування:</strong></p> <ul> <li>є поверхневим тестуванням з концентрацією на детальному тестуванні деяких вибраних функцій;</li> <li>є підмножиною регресійного тестування;</li> <li>виконується тоді, коли у тестувальників відсутня достатня кількість часу для детального тестування;</li> <li>перевірка працездатності зазвичай не документується;</li> <li>є коротким, швидким тестуванням для того, щоб переконатися, що зміни працюють так, як очікувалося, і відповідно до технічних документів;</li> <li>тестування працездатності виконується для перевірки виправлення незначних помилок і незначних функціональних змін.</li> </ul> <p><strong>Переваги санітарного тестування:</strong></p> <ul> <li>фокусується тільки на певних функціях програмного забезпечення;</li> <li>не виходить на рівень структури проекту, тому розробникам дуже важко зрозуміти, як виправити проблеми, виявлені під час перевірки працездатності;</li> <li>виконується тільки для деяких обмежених функцій, тому, якщо є які-небудь проблеми з іншими функціями, їх буде складно відловити;</li> <li>перевірка працездатності, як правило, не документується, тому ті ж самі перевірки в майбутньому можуть бути випущені.</li> </ul> <p>Приклади використання димового і санітарного тестування Розглянемо детальніше ці види тестування на прикладі реальних кейсів.</p> <p><strong>Приклад димового тестування. Припустимо, що в тестованому проекті є п'ять модулів, таких як:</strong></p> <ul> <li>вхід в систему;</li> <li>перегляд користувача;</li> <li>сторінка відомостей про користувача;</li> <li>створення нового користувача;</li> <li>створення завдань і так далі. </li> </ul> <p>Таким чином, в цих п'ятьох модулях, в першу чергу, розробник виконує димове тестування, виконуючи всі основні функції цих модулів, а саме:</p> <ul> <li>користувач може увійти з дійсними обліковими даними;</li> <li>користувач НЕ може увійти з недійсними обліковими даними;</li> <li>після входу може бути створений новий користувач або ні;</li> <li>чи доступний для використання створений користувач або ні. </li> </ul> <p>Такий або подібний набір мінімальних тестів завжди виконується командою розробників перед відправкою білда для повної перевірки тестувальниками.</p> <p>Приклад санітарного тестування. Знову припустимо, що в нашому проекті є п'ять модулів, таких як:</p> <ul> <li>вхід в систему;</li> <li>перегляд користувача;</li> <li>сторінка відомостей про користувача;</li> <li>створення нового користувача;</li> <li>створення завдань і так далі. </li> </ul> <p>Під час тестування виявився баг на сторінці входу в систему, наприклад, на сторінці входу в систему поле для введення пароля приймає менше шести символів, що не відповідає вимогам, оскільки у вимогах вказано, що пароль має бути не менше шести символів.</p> <p>Команда тестування повідомила про помилку команду розробників, щоб вони виправили її. Далі команда розробників виправляє помилку і передає її команді тестування, яка перевіряє також і інші модулі додатка, щоб переконатися, що перевірка виправлення помилки не впливає на функціональність інших модулів. Але завжди слід пам'ятати, що група тестування перевіряє тільки екстремальну функціональність модулів, не заглиблюючись в тестування деталей,через відсутність часу, це і є санітарне тестування.</p> <p>Санітарне тестування виконується після того, як збірка пройшла Smoke тестування і була прийнята командою QA для подальшого тестування. Sanity перевірка включає перевірку основних функціональних можливостей з найдрібнішими деталями, наприклад, чи виправлена проблема з полем для введення пароля і чи не з'явилися ще якісь помилки, пов'язані з цим полем.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=18-traceability-matrix>18. Що таке Traceability Matrix<a class=headerlink href=#18-traceability-matrix title="Permanent link">&para;</a></h3> <p>Матриця відповідності вимог (Requirement Traceability Matrix) – це документ, який відображає та відстежує вимоги користувача за допомогою тестових випадків (тест-кейсів). Він фіксує всі вимоги, запропоновані клієнтом, та дає можливість відстеження вимог в одному документі, який надається наприкінці життєвого циклу розробки програмного забезпечення. Основна мета матриці відповідності вимог – підтвердити, що всі вимоги перевіряються за допомогою тестових випадків, щоб кожна функціональність була перевірена під час тестування програмного забезпечення. Матриця відповідності містить вимоги з усіма можливими тестовими сценаріями та випадками, а також їхнім поточним станом. Це допомагає команді тестувальників зрозуміти рівень тестування конкретного продукту.</p> <p>Які параметри включити в матрицю відповідності вимог?</p> <ul> <li>Ідентифікатор вимоги.</li> <li>Тип і опис вимоги.</li> <li>Тестові випадки зі статусом.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=19-sanity-testing>19. Що таке Sanity Testing<a class=headerlink href=#19-sanity-testing title="Permanent link">&para;</a></h3> <p>Санітарне тестування: використовується щоразу, коли ми отримуємо відносно стабільний білд ПЗ, щоб визначити працездатність у деталях. Іншими словами, тут відбувається валідація того, що важливі частини функціональності системи працюють згідно з вимогами на низькому рівні.</p> <ul> <li>Націлене на встановлення факту того, що певні частини AUT так само працюють, як годиться, після мінорних змін або виправлень багів</li> <li>Метою є перевірити загальний стан системи в деталях, щоб приступити до більш ретельного тестування</li> <li>Перевірка дефектів не є метою Sanity</li> <li>Санітарне тестування виконується перед регресійним і після smoke-тестів</li> <li>Частіше виконується вручну</li> <li>Підмножина приймального тестування</li> <li>Санітарне може виконуватися без тест-кейсів, але знання тестованої системи обов'язкове</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=20-end-to-end>20. Що таке End-to-End тест<a class=headerlink href=#20-end-to-end title="Permanent link">&para;</a></h3> <p>Наскрізне тестування - це методологія тестування програмного забезпечення для перевірки потоку додатків від початку до кінця. Метою наскрізного тестування є імітація реального сценарію користувача та перевірка системи, що перевіряється, та її компонентів для інтеграції та цілісності даних. Ніхто не хоче, щоб про нього знали своїми помилками та недбалістю, як і у випадку з Тестерами. Коли тестувальникам призначається заявка на тестування, з цього моменту вони беруть на себе відповідальність, і вона також виступає в якості платформи для демонстрації своїх практичних та технічних знань з тестування.</p> <p>Отже, щоб описати це технічно, щоб забезпечити повне тестування, необхідно виконати "Тестування наскрізне"</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=21_1>21. Що таке тестування безпеки<a class=headerlink href=#21_1 title="Permanent link">&para;</a></h3> <p>Тестування безпеки – комплекс досліджень програмного продукту, спрямований на пошук і виявлення дефектів, пов’язаних із збереженням даних користувача, а саме:</p> <p>Цілісність. Обмеження кола користувачів, що мають доступ до даних, визначення ступеня шкоди, завданої при втраті тих чи інших даних.</p> <p>Доступність. Являє собою вимоги до того, що ресурси повинні бути доступні авторизованому користувачеві, внутрішньому об’єкту або пристрою. Як правило, чим більш критичний ресурс – тим вище рівень доступності повинен бути.</p> <p>Конфіденційність. Приховування певних ресурсів або інформації. Під конфіденційністю можна розуміти обмеження доступу до ресурсу деякої категорії користувачів, або іншими словами, за яких умов користувач авторизований отримати доступ до даного ресурсу.</p> <p>У ході тестування найчастіше тестувальник грає роль зловмисника та починає маніпулювати різними чином додатком:</p> <ul> <li>Намагається дізнатися пароль за допомогою зовнішніх засобів.</li> <li>Атакує систему за допомогою спеціальних утиліт, які аналізують захист.</li> <li>Придушує, приголомшує систему (в надії, що вона відмовиться обслуговувати інших клієнтів).</li> <li>Цілеспрямовано введить помилки в надії проникнути в систему в ході відновлення.</li> <li>Переглядає несекретні дані в надії знайти ключ для входу в систему</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=22>22. Що таке тестування на основі ризиків<a class=headerlink href=#22 title="Permanent link">&para;</a></h3> <p>Risk based testing — це тестування проекту з увагою на ризики. Risk based testing — використовує ризики як метод для визначення пріоритетності та виокремлення певних тестів у процесі тест дизайну.</p> <p>Логіка Тест Дизайну</p> <p>Виходячи із того, що Ризик — це ймовірність виникнення небажаного результату. І цей результат пов’язаний з впливом. Тестування на основі ризику передбачає в першу чергу тестування функціональностей, які мають найбільший вплив та ймовірність збою. І у найбільш критичних місцях.</p> <p>Risk-based testing включає аналіз та вимірювання метрик у цих критичних місцях</p> <p>Також може включати використання аналітичних інструментів, які не зовсім належать до компетенції QA, проте допомагають нам обрати нам більш ефективні тести.</p> <p>Коли недостатньо часу для тестування всіх функціональних можливостей, ми таким самим чином ПРІОРИТЕЗУЄМО.</p> <p>Головна ЛОГІКА =&gt; зменшити загальний ризик. Зменшити ймовірність виникнення дефектів, особливо багів з високим впливом на систему, які можуть вплинути максимально болісно на неї.</p> <p>Risk-based testing слід розпочинати на початку проекту та використовувати ці знання у тест-плані.</p> <p>Мета тестування означає зробити проект не абсолютно безризиковим проектом.</p> <p>А провести тестування за найкращими методологіями управління ризиками для досягнення результату проекту, який співвідносить ризики з якістю, особливостями, бюджетом та графіком.</p> <p>Як провести Risk-based testing ? Відповідь: дуже просто!</p> <ul> <li>Складіть пріоритетний перелік ризиків.</li> <li>Проведіть тестування, яке вивчає кожен ризик.</li> <li>По мірі “випаровування” ризиків і появи нових, спрямовуйте свої тестові зусилля, щоб фокусуватися на поточному скоупі.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=23>23. Що таке динамічне тестування<a class=headerlink href=#23 title="Permanent link">&para;</a></h3> <p>Динамічне тестування – тип тестування, який передбачає запуск програмного коду. Таким чином, аналізується поведінка програми під час її роботи.</p> <p>Для виконання динамічного тестування необхідно, щоб програмний код, що тестується, був написаний, скомпільований та запущений. При цьому, може виконуватися перевірка зовнішніх параметрів роботи програми: завантаження процесора, використання пам’яті, час відповіді та т.д. – тобто, її продуктивність.</p> <p>Динамічне тестування є частиною процесу валідації програмного забезпечення.</p> <p>Окрім того динамічне тестування може включати різні підвиди, кожен з яких залежить від:</p> <ul> <li>доступу до коду (тестування методом чорного, білого та сірого ящика);</li> <li>рівня тестування (модульне, інтеграційне, системне та прийомочне тестування);</li> <li>сфери використання програми (функціональне, навантажувальне, тестування безпеки та ін.).</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=24_1>24. Що таке "парадокс пестициду"<a class=headerlink href=#24_1 title="Permanent link">&para;</a></h3> <p>На більшості проєктів трапляються такі ситуації, коли чим більше ми тестуємо продукт, тим більший імунітет виробляється у багів, які ми намагаємося знайти, використовуючи наші тестові набори. Коли одні і ті самі тести повторюються знову та знову, то врешті-решт вони перестають знаходити нові баги. У такій ситуації, навіть детально описаний тест-кейсами, функціонал може бути не протестований досить ретельно і до користувачів можуть потрапити серйозні баги.</p> <p>Так само як і у комах, у багів ПЗ, що тестується може розвинутися опір до одного і того ж пестициду, тобто сформуватися імунітет до вже існуючих тест-кейсів. Такий феномен і називається ефектом пестициду. Цей термін близько 30 років тому придумав американський інженер Борис Бейзер. Суть цього ефекту полягає в тому, що багатократне застосування однакових методів з часом стає неефективним, оскільки шкідники, що вижили, вже мають імунітет.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=25-stlc-entry-exit-criteria>25. Опишіть основні фази STLC? Надайте визначення Entry і Exit Criteria<a class=headerlink href=#25-stlc-entry-exit-criteria title="Permanent link">&para;</a></h3> <p><strong>Основні фази Циклу життя тестування програмного забезпечення (STLC) та визначення Entry і Exit Criteria:</strong></p> <ol> <li><strong>Планування:</strong> Першою фазою STLC є планування. На цьому етапі формується стратегія тестування, визначаються завдання, ресурси, графік і бюджет тестування. Визначення Entry Criteria включає збір та аналіз вимог, завдань, ресурсів, плану тестування тощо. Exit Criteria можуть включати схвалення плану тестування та наявність всіх необхідних ресурсів.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> План тестування затверджено і узгоджено всіма стейкхолдерами.</p> <p><strong>Приклад Exit Criteria:</strong> Створено і затверджено план тестування, зібрані всі необхідні ресурси (людські, матеріальні, технічні).</p> <ol> <li><strong>Аналіз вимог:</strong> На цьому етапі тестувальники аналізують вимоги до програмного забезпечення, щоб зрозуміти, як воно повинно працювати. В цьому контексті вони також визначають тести, які слід виконати. Entry Criteria тут може включати наявність документації з вимогами.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> Документація з вимогами готова та затверджена.</p> <p><strong>Приклад Exit Criteria:</strong> Всі необхідні тести визначені та документовані.</p> <ol> <li><strong>Дизайн тестових випадків:</strong> На цьому етапі розробляються конкретні тестові сценарії на основі аналізованих вимог. Це включає створення тест-кейсів, скриптів тестування та інших необхідних документів. Entry Criteria може вимагати наявності визначених вимог та аналізу.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> Вимоги зазначені і проаналізовані.</p> <p><strong>Приклад Exit Criteria:</strong> Створені тест-кейси для всіх вимог.</p> <ol> <li><strong>Виконання тестових випадків:</strong> На цьому етапі виконуються тест-кейси згідно з попередньо розробленими сценаріями. Вхідним критерієм може бути наявність розроблених тест-кейсів та налаштованого тестового середовища.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> Тест-кейси розроблені.</p> <p><strong>Приклад Exit Criteria:</strong> Всі заплановані тест-кейси виконані.</p> <ol> <li><strong>Аналіз результатів тестування:</strong> На цьому етапі аналізуються результати виконання тестових випадків. Виявлені дефекти документуються і відправляються на виправлення. Вхідним критерієм може бути завершене виконання тестових випадків.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> Виконання тестових випадків завершено.</p> <p><strong>Приклад Exit Criteria:</strong> Дефекти документовані та вислані для виправлення.</p> <ol> <li><strong>Документування та звітність:</strong> На цьому етапі створюються звіти та документація, яка включає в себе результати тестування, дефекти, аналіз продукту тощо. Вхідним критерієм може бути завершення тестування та наявність всіх необхідних даних.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> Тестування завершено, результати зібрані.</p> <p><strong>Приклад Exit Criteria:</strong> Створені звіти і документація.</p> <ol> <li><strong>Завершення тестування:</strong> На останньому етапі процесу STLC проводиться оцінка того, чи виконані всі задачі, чи досягнуті поставлені цілі та якість тестування. Вхідними критеріями можуть бути завершені звіти та документація.</li> </ol> <p><strong>Приклад Entry Criteria:</strong> Створені звіти та документація.</p> <p><strong>Приклад Exit Criteria:</strong> Всі задачі та цілі тестування досягнуті.</p> <p>Ці фази та критерії входу-виходу допомагають забезпечити систематичний та організований підхід до тестування програмного забезпечення та підтримують високу якість продукту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=26-bug-error-failure-fault>26. Що таке Bug, Error, Failure, Fault<a class=headerlink href=#26-bug-error-failure-fault title="Permanent link">&para;</a></h3> <ol> <li> <p><strong>Bug (дефект):</strong> Дефект, також відомий як баг або помилка, є несправністю або неправильним функціонуванням програмного продукту. Дефекти можуть виникнути через помилки в коді, недоліки в проектуванні або неправильне виконання функціональності. Наприклад, якщо веб-сторінка відображає неправильний текст на кнопці або програма зависає при відкритті файлу, це можуть бути приклади дефектів.</p> </li> <li> <p><strong>Error (помилка):</strong> Помилка - це невірна дія або неправильний код, які призводять до некоректної роботи програми. Помилки зазвичай виникають під час розробки, і вони можуть бути виправлені перед випуском продукту. Наприклад, якщо програма видає помилку в результаті некоректного математичного розрахунку, це може бути помилка.</p> </li> <li> <p><strong>Failure (невдача):</strong> Невдача - це некоректна робота програмного продукту в реальних умовах, коли вона не відповідає очікуванням користувача або вимогам. Невдачі спричиняють незадовільний досвід користувача і можуть виникнути через дефекти або помилки. Наприклад, якщо браузерне додаток не завантажується або зависає при взаємодії з користувачем, це може бути невдача.</p> </li> <li> <p><strong>Fault (дефект):</strong> Дефект, відомий також як вада або дефективний модуль, - це конкретний елемент програми, який викликає помилку або невдачу. Дефекти можуть бути вбудовані в код під час розробки і можуть призвести до некоректної роботи в окремих частинах програмного продукту. Наприклад, невірна імплементація функції обчислення суми може бути дефектом.</p> </li> </ol> <p>Узагальнюючи, помилки і дефекти у програмному забезпеченні можуть призводити до невдач і відсутності очікуваного функціонування продукту. Розрізняючи ці терміни, команди тестування можуть точніше ідентифікувати, відслідковувати та виправляти проблеми, що виникають під час розробки та експлуатації програмного забезпечення.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=27_2>27. Які є атрибути звіту про помилку? Які основні поля для заповнення<a class=headerlink href=#27_2 title="Permanent link">&para;</a></h3> <p><strong>Атрибути звіту про помилку та основні поля для заповнення:</strong></p> <p>Звіти про помилки (баги) є критично важною частиною процесу тестування програмного забезпечення, оскільки вони допомагають ідентифікувати, документувати та виправляти дефекти, які виявлені під час тестування. Для ефективного та якісного звітування про помилки, необхідно дотримуватися певних атрибутів та заповнювати основні поля звіту.</p> <p><strong>Основні атрибути та поля звіту про помилку:</strong></p> <p>1 - <strong>Заголовок:</strong><br> Заголовок звіту повинен бути коротким, але інформативним. Він повинен чітко вказувати на основну проблему або опис помилки.</p> <p><em>Приклад:</em> </p> <p>"Помилка при вході до системи з використанням Google-акаунту."</p> <p>2 - <strong>Опис помилки:</strong><br> Це докладний опис помилки або дефекту. Варто вказати всі дії, які призвели до помилки, та описати очікуване поведінка порівняно з фактично спостереженим.</p> <p><em>Приклад:</em> </p> <p>"Після натискання кнопки 'Увійти через Google', замість переходу на сторінку авторизації відбувається перенаправлення на головну сторінку."</p> <p>3 - <strong>Кроки для відтворення:</strong><br> Цей розділ містить послідовність кроків, необхідних для відтворення помилки. Чітке і точне описання допоможе розробникам легко знайти та виправити дефект.</p> <p><em>Приклад:</em> </p> <ol> <li>Зайти на сторінку авторизації.</li> <li>Натиснути кнопку "Увійти через Google".</li> <li>Спостерегти перенаправлення на головну сторінку.</li> </ol> <p>4 - <strong>Очікуване та фактичне поведінка:</strong><br> Ці поля вказують на те, яка мала б бути правильна поведінка програми (очікувана) та яка фактично відбувається (фактична). Це допомагає розробникам швидше розібратися в проблемі.</p> <p><em>Приклад:</em> - Очікуване: Після натискання кнопки "Увійти через Google" користувач має бути перенаправлений на сторінку авторизації. - Фактичне: Користувач перенаправляється на головну сторінку.</p> <p>5 - <strong>Прикріплення файлів:</strong><br> Якщо можливо, до звіту можна додати скріншоти, відео чи інші файли, що допоможуть розуміти проблему. Це особливо корисно для візуалізації складних або незрозумілих ситуацій.</p> <p>6 - <strong>Приоритет та серйозність:</strong><br> Зазвичай помилки мають присвоєні рівні приоритету (важливість для виправлення) та серйозності (вплив на систему). Це допомагає розробникам та тестувальникам спрямовувати зусилля на найбільш важливі аспекти.</p> <p><em>Приклад:</em></p> <ul> <li>Приоритет: Високий</li> <li>Серйозність: Критична (помилка блокує доступ до системи)</li> </ul> <p>7 - <strong>Середовище:</strong><br> Вказати, на якому обладнанні, операційній системі та браузері виявлено помилку. Деякі помилки можуть бути специфічними для певних середовищ.</p> <p><em>Приклад:</em></p> <ul> <li>Середовище: Windows 10, Google Chrome 92.</li> </ul> <p>8 - <strong>Версія програмного забезпечення:</strong><br> Якщо дефект стосується певної версії програми, це важливо вказати.</p> <p><em>Приклад:</em></p> <ul> <li>Версія ПЗ: 2.1.0</li> </ul> <p>Коректне та докладне заповнення цих атрибутів та полів допомагає розробникам швидше розібратися в дефекті та виправити</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=28_2>28. Яка різниця між пріоритетом і серйозністю<a class=headerlink href=#28_2 title="Permanent link">&para;</a></h3> <p><strong>Серйозність (Severity)</strong> – це атрибут, що характеризує вплив дефекту на працездатність програми.</p> <p><strong>Пріоритет (Priority)</strong> – це атрибут, який вказує на черговість виконання завдання або усунення дефекту. Можна сказати, що це інструмент менеджера з планування робіт. Чим вище пріоритет, тим швидше потрібно виправити дефект.</p> <p><strong>Градація серйозних дефектів (Severity)</strong></p> <ul> <li> <p><strong>S1 Блокуюча (Blocker)</strong> Блокуюча помилка, що приводить додаток в неробочий стан, в результаті якого подальша робота з тестованою системою або її ключовими функціями стає неможлива. Рішення проблеми необхідно для подальшого функціонування системи.</p> </li> <li> <p><strong>S2 Критична (Critical)</strong> Критична помилка, неправильно працює ключова бізнес-логіка, діра в системі безпеки, проблема, яка призвела до тимчасового падіння сервера або приводить в неробочий стан деяку частину системи, без можливості вирішення проблеми, використовуючи інші вхідні точки. Рішення проблеми необхідно для подальшої роботи з ключовими функціями тестируемої системою.</p> </li> <li> <p><strong>S3 Значна (Major)</strong> Значна помилка, частина основної бізнес-логіки працює некоректно. Помилка не критична або є можливість для роботи з тестованою функцією, використовуючи інші вхідні точки.</p> </li> <li> <p><strong>S4 Незначна (Minor)</strong> Незначна помилка, що не порушує бізнес-логіку частини програми, що тестується, очевидна проблема для користувача інтерфейсу.</p> </li> <li> <p><strong>S5 Тривіальна (Trivial)</strong> Тривіальна помилка, яка не стосується бізнес-логіки додатка, погано відтворена проблема, малопомітна за допомогою користувацького інтерфейсу, проблема сторонніх бібліотек або сервісів, проблема, не надає ніякого впливу на загальну якість продукту.</p> </li> </ul> <p><strong>Градація Пріоритету дефекту (Priority)</strong></p> <ul> <li> <p><strong>P1 Високий (High)</strong> Помилка повинна бути виправлена якомога швидше, так як її наявність є критичною для проекту.</p> </li> <li> <p><strong>P2 Середній (Medium)</strong> Помилка повинна бути виправлена, її наявність не є критичною, але вимагає обов'язкового вирішення.</p> </li> <li> <p><strong>P3 Низький (Low)</strong> Помилка повинна бути виправлена, її наявність не є критичною, і не вимагає термінового вирішення.</p> </li> </ul> <p><strong>Порядок виправлення помилок з їх пріоритетами:</strong></p> <p><code>High -&gt; Medium -&gt; Low</code></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=29_1>29. Наведіть приклади серйозної, але не пріоритетної помилки<a class=headerlink href=#29_1 title="Permanent link">&para;</a></h3> <p>Серйозна помилка, яка не є найвищим пріоритетом, може включати ситуації, де функціональність продукту порушена, але це не критично для його базової роботи або основних функцій. Оцінюючи серйозність помилок, необхідно враховувати вплив на користувачів та важливість конкретної функції.</p> <p>Один із прикладів може бути специфічний стиль відображення повідомлень про помилки на веб-сайті. Якщо стиль не відповідає вимогам дизайну, це може бути помилкою. Однак, ця помилка не впливає на коректну роботу сайту або його здатність надавати основні функції. Така помилка може бути помічена під час тестування і залишитися для подальшого виправлення.</p> <p>Інший приклад - некоректний порядок відображення даних у звіті. Ця помилка може вплинути на зручність використання звіту, але якщо інформація все одно доступна, це може бути помилка меншого пріоритету. Наприклад, в адміністративній панелі звіти можуть відображатися у зворотньому хронологічному порядку, але це може не відповідати очікуваному порядку.</p> <p>Важливо враховувати, що значення "серйозності" та "пріоритету" може відрізнятися в різних контекстах та для різних продуктів. У деяких випадках, навіть якщо помилка не критична, вона може бути важливою для поліпшення користувацького досвіду, тому важливо ретельно аналізувати і оцінювати всі знайдені помилки.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=30>30. В чому різниця між валідацією і верифікацією<a class=headerlink href=#30 title="Permanent link">&para;</a></h3> <p>Верифікація (verification): Підтвердження наданням об’єктивних доказів того, що встановлені вимоги були виконані. Примітки:</p> <ol> <li>Термін “верифікований” використовують для позначення відповідного статусу.</li> <li>Діяльність з підтвердження вимоги може включати в себе: · Здійснення альтернативних розрахунків; · Порівняння специфікації на новий проект з аналогічною документацією на проект; · Проведення випробувань і демонстрацій; · Аналіз документів до їх випуску.</li> </ol> <p>Валідація (validation): Підтвердження наданням об’єктивних доказів того, що вимоги, призначені для конкретного використання або застосування, виконані. Примітки:</p> <ol> <li>Термін “валідація” використовують для позначення відповідного статусу.</li> <li>Умови застосування можуть бути реальними або змодельованими.</li> </ol> <p>Об’єктивне свідчення (objective evidence): Дані, що підтверджують наявність або істинність чого-небудь. Вимога (requirement): Потреба або очікування, яке встановлено, зазвичай передбачається чи є обов’язковим Специфікація (specification): Документ, що встановлює вимоги. Випробування (test): Визначення однієї або декількох характеристик відповідно до встановленої процедури. [ГОСТ ISO 9000-2011.]</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=31>31. Навіщо потрібна тестова документація і які її види<a class=headerlink href=#31 title="Permanent link">&para;</a></h3> <p>Тестова документація є важною складовою процесу тестування програмного забезпечення, оскільки вона сприяє ефективній організації та плануванню всіх аспектів тестування. Вона забезпечує структурований підхід до роботи тестувальників, допомагає відстежувати процес та результати тестування, а також забезпечує належний рівень документації для комунікації між всіма учасниками проекту, зокрема між розробниками, тестувальниками та менеджерами.</p> <p><strong>Важливість тестової документації:</strong></p> <ol> <li> <p><strong>Планування та організація:</strong> Тестова документація допомагає визначити стратегію тестування, план роботи, обсяг ресурсів та розподіл обов'язків між командою. Наприклад, Тест-План визначає загальний підхід до тестування та допомагає встановити пріоритети.</p> </li> <li> <p><strong>Визначення тестових вимог:</strong> Тестова документація допомагає чітко визначити тестові вимоги, які повинні бути випробувані. Це дозволяє переконатися, що продукт відповідає вимогам замовника. </p> </li> <li> <p><strong>Структурованість і організація:</strong> Велика кількість тестових випробувань вимагає структурованості та систематичного підходу. Документація допомагає зберігати та відстежувати результати тестування, що спрощує процес знаходження та виправлення помилок.</p> </li> <li> <p><strong>Відстеження результатів:</strong> Тестова документація дозволяє зберігати і відстежувати результати тестування для кожного етапу. Це допомагає швидше виявляти та усувати недоліки.</p> </li> </ol> <p><strong>Види тестової документації:</strong></p> <ol> <li> <p><strong>Тест-План:</strong> Детальний план тестування, який описує стратегію, обсяг, ресурси, ризики та графік тестування. </p> </li> <li> <p><strong>Тестові Сценарії:</strong> Конкретні інструкції для проведення тестів. Це можуть бути позитивні та негативні сценарії, що описують очікувані результати.</p> </li> <li> <p><strong>Тестова Документація до Дефектів:</strong> Звіти про виявлені дефекти, які включають опис проблеми, шаги для відтворення та результати тестування.</p> </li> <li> <p><strong>Traceability Matrix (Матриця Відстеження):</strong> Відображення взаємозв'язку між вимогами, тестовими випробуваннями та їх результатами.</p> </li> <li> <p><strong>Тестова Документація до Об'єкта Тестування:</strong> Опис основних характеристик, вимог та очікуваних результатів для кожного об'єкта тестування.</p> </li> <li> <p><strong>Тест-Сценарій для Автоматизованих Тестів:</strong> Докладний опис того, як автоматизований тест повинен бути виконаний.</p> </li> <li> <p><strong>Тестові Дати та Завдання:</strong> Розклад тестів, терміни виконання та обсяг завдань для членів команди.</p> </li> </ol> <p><strong>Приклад:</strong></p> <p>Допустимо, ви тестуєте веб-додаток для онлайн-магазину. Ви створюєте Тест-План, де вказуєте, що проведете тестування на різних браузерах, зробите функціональне та інтеграційне тестування. Далі, для кожного тестового сценарію ви пишете докладні інструкції, наприклад, "Валідація корзини покупок". У вас також є Traceability Matrix, де відображено, які вимоги покриває кожен тестовий сценарій.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=32->32. Що таке тест-план? Які елементи він має<a class=headerlink href=#32- title="Permanent link">&para;</a></h3> <p><strong>Тест-план</strong> - це документ, що описує план тестування для конкретного проекту або продукту. Він визначає стратегію, підходи, ресурси, розклад та оцінки вартості тестування. Тест-план є ключовим інструментом, який допомагає організовувати і впорядковувати процес тестування, а також забезпечує загальне розуміння всіх сторін, як планується провести тестування.</p> <p><strong>Елементи тест-плану:</strong></p> <ol> <li> <p><strong>Вступна інформація:</strong> Вказується загальна інформація про документ, дату створення, авторів, ідентифікатор проекту і т.д.</p> </li> <li> <p><strong>Загальний огляд:</strong> Описується характеристика продукту, його призначення, основні функції, а також ціль та обсяг тестування.</p> </li> <li> <p><strong>Стратегія тестування:</strong> Пояснюється, які підходи і методи будуть використані під час тестування. Включає розподіл завдань, обрані техніки та підходи до створення тестових сценаріїв.</p> </li> <li> <p><strong>Об'єкти тестування:</strong> Вказуються компоненти, функціональність та модулі, які будуть перевірятися під час тестування.</p> </li> <li> <p><strong>Вимоги до тестування:</strong> Описуються критерії, на основі яких буде оцінюватися успішність тестування, включаючи якість, продуктивність та інші аспекти.</p> </li> <li> <p><strong>Розклад тестування:</strong> Визначається графік проведення різних етапів тестування, а також вказуються терміни для завершення кожної фази.</p> </li> <li> <p><strong>Бюджет та ресурси:</strong> Вказуються обсяги ресурсів, які будуть виділені для тестування, включаючи людські ресурси, обладнання та програмне забезпечення.</p> </li> <li> <p><strong>Ризики та припущення:</strong> Визначаються можливі ризики, які можуть вплинути на процес тестування, а також зроблені припущення, на яких будується план.</p> </li> <li> <p><strong>Критерії завершеності:</strong> Вказуються умови, які повинні бути виконані для завершення кожної фази тестування та для визначення, коли продукт готовий до випуску.</p> </li> <li> <p><strong>Вимоги до середовища:</strong> Описуються обладнання, програмне забезпечення, середовище та конфігурації, які потрібні для виконання тестування.</p> </li> <li> <p><strong>Подання результатів:</strong> Вказуються методи і формати звітності результатів тестування, а також структура документів, які будуть створені.</p> </li> <li> <p><strong>Завершення тест-плану:</strong> Вказується інформація про учасників, які розробили і переглянули тест-план, а також дати підписання та затвердження документа.</p> </li> </ol> <p><strong>Приклад тест-плану:</strong></p> <ul> <li><strong>Вступна інформація:</strong> Створено: 23.08.2023, Автор: Іван Іванов, Ідентифікатор проекту: PRJ-123.</li> <li><strong>Загальний огляд:</strong> Тестування веб-додатку "OnlineShop". Продукт призначений для покупців, які можуть вибирати товари, додавати їх у кошик, оформлювати замовлення тощо.</li> <li><strong>Стратегія тестування:</strong> Використовувати комбінацію ручного та автоматизованого тестування. Розподіл завдань між тестувальниками з різними спеціалізаціями.</li> <li><strong>Об'єкти тестування:</strong> Веб-сторінки, форми, функціональні кнопки, кошик, система реєстрації та авторизації.</li> <li><strong>Вимоги до тестування:</strong> Успішне завершення тестів на реєстрацію, вхід, додавання товарів, оформлення замовлення, відображення даних користувача.</li> <li><strong>Розклад тестування:</strong> Фаза 1 - Ручне тестування реєстрації та авторизації (з 25.08 до 28.08), Фаза 2 - Автоматизоване тестування кошика (з 29.08 до 31.08) тощо.</li> <li><strong>Бюджет та ресурси:</strong> 2 тестувальники, 1 автоматизатор. Час відведено 160 годин на ручне тестування, 80 годин на автоматизоване.</li> <li><strong>Ризики та припущення:</strong> Можливі затримки через незаплановані зміни в продукті. Припущено, що тестове середовище буде готове до 25.08.</li> <li><strong>Критерії завершеності:</strong> Успішно пройдено всі тестові сценарії для кожної фази. Більше 95% тестів повинні бути успішними.</li> <li><strong>Вимоги до середовища:</strong> Windows 10, Chrome 90+, Firefox 90+, Python 3.8+, Selenium 3.141.0.</li> <li><strong>Подання результатів:</strong> Звіти про тестування будуть складатися у вигляді XLSX-файлів і завантажуватися на спільний сервер.</li> <li><strong>Завершення тест-плану:</strong> Розробник, Тестувальник, Технічний лідер підписали документ. Дата підписання: 23.08.2023.</li> </ul> <p>Такий докладний тест-план допомагає забезпечити систематичний та структурований підхід до тестування, зменшити ризики та забезпечити якість продукту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=33->33. Яку обов'язкову інформацію має містити тест-план<a class=headerlink href=#33- title="Permanent link">&para;</a></h3> <p>Test plan – це документ, який описує весь обсяг робіт з тестування, починаючи з опису об'єкта тестування, стратегії, розкладу, критеріїв початку і закінчення тестування, до необхідного в процесі роботи обладнання, спеціальних знань, а також оцінки ризиків з варіантами їх вирішення.</p> <p><strong>Тест-план призначений для:</strong></p> <ul> <li>Врегулювання процесів тестування.</li> <li>Пріоритезації завдань.</li> <li>Планування ресурсів.</li> <li>Обліку програмного забезпечення та людських ресурсів.</li> </ul> <p>Зазвичай, тест-план складає QA-лід команди тестувальників, але його можуть редагувати також тестувальники.</p> <p><strong>Основні елементи тест-плану:</strong></p> <ol> <li> <p><strong>Що необхідно протестувати?</strong> Опис об'єкта тестування, включаючи функціональні блоки, обладнання та браузери для виконання тестів.</p> </li> <li> <p><strong>Як буде проводитися тестування?</strong> Детальний опис стратегії тестування та застосовуваних видів тестів.</p> </li> <li> <p><strong>Коли буде проводитися тестування?</strong> План проведення робіт, включаючи підготовку, тестування та аналіз результатів для кожної фази.</p> </li> <li> <p><strong>Критерії початку тестування</strong> Критерії, які визначають готовність до початку тестування, такі як готовність тестової платформи чи наявність необхідної документації.</p> </li> <li> <p><strong>Критерії закінчення тестування:</strong> Умови, які показують завершеність тестування, такі як кількість відкритих багів, успішність усіх тестів та інші.</p> </li> </ol> <p>Якщо відповісти на ці питання при складанні тест-плану, ви отримаєте чорновий варіант документа. Потім його можна доопрацювати, додавши решту необхідної інформації.</p> <p><strong>Типи тест-планів:</strong></p> <ul> <li>Майстер тест-план (Master test plan): включає високорівневу інформацію, яка рідко змінюється.</li> <li>Детальний тест-план (Test plan): гнучкий документ, що оновлюється з урахуванням реального стану проєкту.</li> <li>План приймальних випробувань (Product acceptance plan): описує приймальне тестування.</li> </ul> <p><strong>Заключення:</strong></p> <p>Тест-план – важливий елемент процесу тестування, що допомагає організувати роботу тестувальників та забезпечити якість продукту.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=34->34. Яка різниця між чеклистом і тест-кейсами<a class=headerlink href=#34- title="Permanent link">&para;</a></h3> <p><strong>Тест кейс</strong> - це послідовність дій, які потрібно перевірити.</p> <p><strong>Чек-аркуш</strong> - це коротке позначення напрямку для послідовності дій, які потрібно перевірити.</p> <p><strong>Тест кейси</strong> пишуться максимально докладно, щоб було зрозуміло будь-якій людині в команді.</p> <p><strong>Чек-листи</strong> описують коротко те, що хочемо протестувати.</p> <p>Розглянемо відмінності тест кейса від чек листа на прикладі.</p> <p>Припустимо, ми хочемо покласти товар у кошик.</p> <p><strong>Тест кейс</strong> можна написати таким чином (приклад тест кейса):</p> <p><strong>Порядковий номер:</strong> 1.</p> <p><strong>Назва:</strong> Додавання книги в кошик в інтернет-магазині.</p> <p><strong>Кроки:</strong></p> <ol> <li>Перейти на сайт test.com.</li> <li>Перейти в розділ Книги.</li> <li>Натиснути на кнопку "В кошик" біля першої книги.</li> <li>Натиснути кнопку "Перейти в кошик".</li> </ol> <p><strong>Очікуваний результат:</strong></p> <p>Відкриється сторінка "Кошик" з одним доданим товаром.</p> <p><strong>Пункт чек-листа</strong> в нашому прикладі може виглядати так (приклад пункту чек-листа):</p> <p>А. Додати книгу в кошик.</p> <p>І все, тобто ми не описуємо крок за кроком, куди натиснути, що конкретно зробити, а просто вказуємо напрямок, що потрібно зробити таку-то дію, у цьому випадку - додати товар у кошик. А як ми додамо товар у кошик, звідки додамо, куди переходитимемо до цього - це все на розсуд тестувальника, який проводить тестування за цим пунктом чек-листа.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=35-qa>35. Обязанності QA<a class=headerlink href=#35-qa title="Permanent link">&para;</a></h3> <ul> <li>вивчення та уточнення вимог до програми у замовника (у великих проєктах цим можуть займатися бізнес-аналітики)</li> <li>написання та подальше доопрацювання сценаріїв тестування</li> <li>проведення тестування функціоналу ПЗ</li> <li>внесення звітів щодо виявлених недоліків у трекінгову систему</li> <li>аналіз результатів і показників проведених тестів</li> <li>складання ТЗ на усунення знайдених після тестування недоліків</li> <li>моніторинг і відстеження правок</li> <li>проведення повторних тестів на відсутність знайдених помилок</li> <li>аналіз та оптимізація етапів розробки для усунення причин помилок та уникнення повторної їх появи</li> <li>робота з тестовою документацією</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=36>36. Що знаєте про тестування навантаження? У якому випадку слід проводити таке тестування? На якому етапі готовності продукту<a class=headerlink href=#36 title="Permanent link">&para;</a></h3> <p><em>Навантажувальне тестування (load testing)</em> - виконання програми з підвищенням навантаження, аж до досягнення запланованих характеристик, і далі з відстеженням поведінки впродовж усього періоду підвищення завантаження системи. При цьому може відбуватися: * * вимірювання часу виконання обраних операцій за певних інтенсивностей виконання цих операцій * визначення кількості користувачів, які одночасно працюють із додатком * визначення меж прийнятної продуктивності при збільшенні навантаження (при збільшенні інтенсивності виконання цих операцій)</p> <p>Проводиться в таких випадках:</p> <ul> <li>новий проєкт, який ще не проходив навантажувального тестування і настав час аудиту продуктивності</li> <li>впровадили велику зміну, яка суттєво впливає на функціонал</li> <li>планується участь у великих маркетингових акціях, які залучать великий трафік</li> <li>зміна конфігурації стендів </li> <li>оцінка можливостей наявної системи</li> </ul> <p>Зазвичай проводиться заздалегідь перед релізом або очікуваним збільшенням навантаження.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=37-decision-table>37. Decision table і як її можна використовувати<a class=headerlink href=#37-decision-table title="Permanent link">&para;</a></h3> <p><em>Таблиця рішень (Decision Table)</em> - техніка, що допомагає наочно зобразити комбінаторику умов із ТЗ. Приклад нижче.</p> <blockquote> <p><strong>СІ01. Знайти товар і зробити покупку</strong></p> <p><em>Легенда</em><br> П - користувач<br> С - система</p> <p><em>Сценарій використання</em></p> <ol> <li>П відкриває список товарів і фільтрує за категорією.</li> <li>С відображає товари обраної категорії.</li> <li>П бачить цікавий товар і переходить на його картку.</li> <li>С відображає картку товару, оцінку покупців та відгуки.</li> <li>П вивчає товар і кладе його в кошик.</li> <li>С додає товар у кошик.</li> <li>П переходить у кошик і оформляє замовлення.</li> <li>С зберігає замовлення, надсилає повідомлення на email.</li> </ol> <p><em>Альтернативні варіанти</em></p> <ul> <li>1а П фільтрує список за неіснуючою категорією. Система видає помилку. Завершення сценарію.</li> <li>2а. Товарів не знайдено. Виведення повідомлення про помилку. Завершення сценарію.</li> <li>2б. Товарів занадто багато. Система виводить перші 100 і пропонує звузити пошук.</li> <li>5а. П повертається до покупок. Перехід до кроку 1.</li> </ul> <p><em>Параметри</em><br> Категорії товарів: сукні, джинси, светри.<br> Час зберігання товару в резерві: 2 години з моменту додавання в кошик.</p> </blockquote> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=38>38. Що може бути критеріями запуску і завершення тестування<a class=headerlink href=#38 title="Permanent link">&para;</a></h3> <p>Загалом, безглуздо абстрактно говорити про критерії початку або завершення тестування, бо воно починається і завершується разом із початком і кінцем усього проєкту загалом.<br> Правильніше говорити про тестування як про підпроцес процесу розробки ПЗ. Цей підпроцес складається з цілої серії діяльностей, кожна з яких пов'язана залежностями з іншими діяльностями, зокрема такими, що не належать до тестування.</p> <p>Критеріями для початку тестування можуть бути обрані:</p> <ul> <li>завершення функціоналу, який може бути протестований</li> <li>досягнення певного етапу розробки</li> </ul> <p>Критеріями для зупинки/завершення тестування можуть бути обрані:</p> <ul> <li>закінчення часу</li> <li>спустошення бюджету</li> <li>всі тест кейси пройдено, знайдені баги виправлено і перевірено ще раз</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=39>39. Приклади підходів для тестування локалізації<a class=headerlink href=#39 title="Permanent link">&para;</a></h3> <p><strong>За наявності локалі.</strong> </p> <p>Беремо локаль і проводимо необхідний комплекс операцій для перевірки її якості.</p> <p><strong>За відсутності локалі.</strong> </p> <p><em>Техніка псевдо-локалізації (Pseudo-localization approach)</em>. У рамках цього підходу потрібно підготувати псевдо-локаль (зробити це може сам тестувальник), використовуючи будь-яку іншу мову та додавши до файлів необхідні дані, наприклад спец.символи певної мови. Також можна додати більшу кількість символів у рядки, щоб перевірити, чи буде обрізатися текст (truncate), адже текст може стати довшим після перекладу на нову локаль і не вміститися у відведений для нього простір. Ще такий підхід допоможе знайти проблему з об'єднанням рядків (concatenation) і проблеми, пов'язані з відображенням шрифту, якщо такі є. Для того, щоб такі проблеми було простіше знайти, то в початок і кінець рядка можна додати який-небудь символ. Наприклад, Microsoft використовує такий підхід ще з 90-х і вставляє квадратні дужки для позначення початку і закінчення рядка.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=40-ab>40. A/B тестування<a class=headerlink href=#40-ab title="Permanent link">&para;</a></h3> <p>A/B-тестування - експеримент, який дає змогу порівняти дві версії будь-чого, щоб перевірити гіпотези та визначити, яка версія краща. Чи повинні кнопки бути чорними або білими, яка навігація краща, який порядок проходження реєстрації найменше відлякує користувачів...<br> Користувачі випадковим чином діляться на сегменти. Один із сегментів залишається без змін - це контрольний сегмент "A", на основі даних за цим сегментом ми оцінюватимемо ефект від внесених змін. Користувачам із сегмента "B" показуємо змінену версію. Щоб отримати статистично значущий результат, дуже важливо виключити вплив сегментів один на одного.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=41-mockstub>41. Що таке mock/stub? Які знаєте інструменти для роботи з ними<a class=headerlink href=#41-mockstub title="Permanent link">&para;</a></h3> <p><em>Тестовий двійник (Test Double)</em> - це всеосяжний термін, який описує всі види фальшивих (fake) залежностей, непридатних до використання в кінцевому продукті (non-production-ready), у тестах. Така залежність має вигляд і поводиться як її аналог, призначений для production, але насправді є спрощеною версією, яка знижує складність і полегшує тестування.</p> <p>Видів тестових двійників: * Пустушка (dummy) * Стаб (stub) * Шпигун (spy) * Мок (mock) * Фейк (fake)</p> <p><img alt=image src=images/test_double.png></p> <p>Моки допомагають імітувати і вивчати вихідні (outcoming) взаємодії. Тобто виклики, що здійснюються тестованою системою (SUT) до її залежностей для зміни їхнього стану.</p> <p>Стаби допомагають імітувати вхідні (incoming) взаємодії. Тобто виклики, що здійснюються SUT до її залежностей для отримання вхідних даних.</p> <p><img alt=image src=images/mock_stub.png></p> <p><strong>Інструменти</strong> </p> <p><em>Java</em>: Mockito, EasyMock, JMockit<br> <em>Python</em>: pyDoubles, Mox, Mockito-python</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=42-pairwise>42. Коли потрібно використовувати техніку Pairwise<a class=headerlink href=#42-pairwise title="Permanent link">&para;</a></h3> <p>Коли в нас більша кількість комбінацій тестових даних і ми хочемо забезпечити максимальне покриття, протестувавши всі можливі окремі комбінації кожної пари вхідних параметрів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=43-fuzz->43. Fuzz-тестування і де його використовують<a class=headerlink href=#43-fuzz- title="Permanent link">&para;</a></h3> <p><em>Fuzz testing (фаззинг)</em> - методика тестування, за якої на вхід програми подаються невалідні, непередбачені або випадкові дані. Основна ідея такого підходу полягає в тому, щоб випадковим чином "мутувати" очікувані програмою вхідні дані в довільних місцях. Усі фаззери працюють приблизно однаково, даючи змогу задавати деякі обмеження на мутування вхідних даних певними байтами або послідовністю байтів. Широко застосовується там, де потрібен високий ступінь надійності.<br> Фаззинг можна застосовувати до будь-яких функцій, які обробляють складні дані. Наприклад, бібліотеки стиснення і розпакування, парсери HTTPS і DNS, різні десеріалізатори, мультимедіа кодеки, криптографічні бібліотеки, запити до баз даних. А також для всього, що приймає дані із зовнішнього світу, тобто з недовірених джерел.</p> <p><em>Основні види</em>:</p> <ul> <li>Випадковий фаззинг щоразу генерує повністю випадкові значення, які ніяк не залежать від минулих тестів. Випадкові фаззери є більш простими і більш швидкими. Вони можуть дати хороший результат за малу ціну.</li> <li>Фаззинг з урахуванням покриття використовує результати минулих тестів для відстеження і подальшого збільшення покриття коду. Такі фаззери можуть заглиблюватися в тестовані дані і для роботи таких фаззерів потрібні набори даних, що подаються на вхід. Ці дані називаються корпус - це мінімальний набір тестових вхідних даних, які можуть згенерувати максимальне покриття коду.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=44-regexp>44. REgexp<a class=headerlink href=#44-regexp title="Permanent link">&para;</a></h3> <p>Регулярні вирази (Regular Expressions/REgexp) - формальна мова, яка використовується для пошуку та здійснення маніпуляцій із підрядками в тексті, заснована на використанні метасимволів (символів-джокерів/wildcard characters). Для пошуку використовується рядок-зразок (pattern/шаблон, маска), що складається з символів і метасимволів і задає правило пошуку.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=45>45. Як змінюється вартість дефекту під час тестування ПЗ<a class=headerlink href=#45 title="Permanent link">&para;</a></h3> <p>Що раніше знайдено дефект, то дешевше нам обходиться його виправлення. Згодом, вартість виправлень зростає, в той час як вплив учасників проєкту на процес розробки поступово зменшується.</p> <p><img alt=image src=images/defect_price.jpg></p> <p>Якщо серйозний дефект виявляється на пізніх етапах розробки, він може залишитися невиправленим, оскільки вартість внесення змін може виявитися занадто високою. Крім того, навіть якщо готова програма відповідатиме специфікації, замовник все одно може відмовитися її приймати, якщо сама специфікація була неправильною. Проєктна команда могла розробити точно те, що було описано у вимогах, але якщо вимоги було витлумачено неправильно, замовника результат не влаштує.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=46>46. Які шляхи аналізу бізнесу клієнта? Як визначити доцільність того чи іншого функціоналу<a class=headerlink href=#46 title="Permanent link">&para;</a></h3> <p><img alt=IMG src=images/BA.webp></p> <p><em>Передпроєктні роботи (Discovery/Solution Design)</em> - фаза, на якій проводиться обґрунтування доцільності старту розробки. * Зрозуміти поточний стан бізнесу, його проблеми або можливості, яких йому не вистачає. * Зрозуміти, що саме бізнес-хоче отримати за результатами розробки та впровадження рішення. * Визначити підходи до вирішення виявлених проблем і вибрати з них той, який приносить максимальну цінність для замовника. * Визначити на високому рівні межі рішення та критерії успіху.</p> <p><em>Проектні роботи</em> - фаза, на якій триває активне розроблення та тестування. * Виявити, описати та узгодити детальні вимоги до рішення. * Управляти змінами вимог. * Проводити пріоритизацію вимог. * Організувати приймальне тестування.</p> <p><em>Постпроєктні роботи</em> - фаза оцінки отриманої цінності/користі. * Оцінити отриманий результат. * Обробити зауваження та пропозиції, отримані за результатами експлуатації. * Оновити базу знань за проєктом.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=47>47. Яке має бути відсоткове співвідношення між позитивним і негативним тестуванням на проєкті<a class=headerlink href=#47 title="Permanent link">&para;</a></h3> <p>Усі вимоги мають бути покриті позитивними сценаріями, плюс варто робити мінімум хоча б один-два негативних сценарії на кожну вимогу.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=48-bug-leakage-bug-release>48. Чи є різниця між bug leakage і bug release<a class=headerlink href=#48-bug-leakage-bug-release title="Permanent link">&para;</a></h3> <p><em>Bug release</em> - баги, які були випущені в реліз і команда розробки про них знає.</p> <p><em>Bug leakage</em> - невідомі команді розробки, баги, які знаходять користувачі після релізу.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=49->49. Що потрібно покривати тест-кейсами, а що вважається надлишковою витратою часу і грошей? Коли недоцільно писати тест-кейси<a class=headerlink href=#49- title="Permanent link">&para;</a></h3> <p>Насамперед тестами покривається основний функціонал застосунку і далі по низхідній. Однак тест-кейси пишуться з огляду на вимоги бізнесу. Можливо, що вимоги бізнесу до тестування не покриватимуть основний функціонал. У такій ситуації потрібне уточнення вимог у замовника.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=50-cyclomatic-complexity>50. Як порахувати Cyclomatic complexity<a class=headerlink href=#50-cyclomatic-complexity title="Permanent link">&para;</a></h3> <p>Цикломатична складність програми (Cyclomatic Complexity of a Program) - структурна/топологічна міра складності комп'ютерної програми. Розроблена Томасом Дж.Маккейбом у 1976 році.<br> Під час обчислення цикломатичної складності використовується граф потоку керування програми. Вузли графа відповідають неподільним групам команд програми, вони з'єднані орієнтованими ребрами, якщо групу команд, що відповідає другому вузлу, може бути виконано безпосередньо після групи команд першого вузла. Цикломатична складність може бути також обчислена для окремих функцій, модулів, методів або класів у межах програми.<br> Їй на заміну прийшла Cognitive Complexity розроблена у 2017 році компанією Sonar Source.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=51-defect-detection-percentage-defect-removal-efficiency>51. У чому основна різниця між defect detection percentage і defect removal efficiency<a class=headerlink href=#51-defect-detection-percentage-defect-removal-efficiency title="Permanent link">&para;</a></h3> <p><em>Відсоток виявлення дефектів (Defect Detection Percentage/DDP або Defect Removal Efficiency/DRE)</em> - відсоток виявлення дефектів показує міру ефективності тестування. Розраховується як відношення дефектів, виявлених до випуску і після випуску ПЗ. DDP можна визначити у вигляді такої формули:</p> <div class="language-text highlight"><pre><span></span><code>DDP = (Кількість дефектів на момент випуску версії ПЗ / Загальна кількість дефектів виявлених командою тестування і замовниками) * 100
</code></pre></div> <p><em>Ефективність виявлення дефектів (Defect Detection Efficiency/DDE)</em> - параметр, який розраховується для забезпечення якості та ефективності ПЗ. Це кількість дефектів або помилок, які були створені і були виявлені на одному етапі розробки, і поділена на загальну кількість помилок, створених на цьому етапі. Відкинуті дефекти не враховуються. DDE можна розрахувати на будь-якому етапі життєвого циклу розробки ПЗ (SDLC), коли дефекти можуть бути створені та виявлені. Фаза, в яку створено дефект, визначається шляхом аналізу. DDE можна визначити у вигляді такої формули:</p> <div class="language-text highlight"><pre><span></span><code>DDE = (Кількість дефектів, створених і виявлених на етапі / Загальна кількість дефектів, створених на цьому етапі) * 100
</code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=52-risk-based-testing>52. Які моделі risk-based testing ви знаєте<a class=headerlink href=#52-risk-based-testing title="Permanent link">&para;</a></h3> <p><em>FMEA(Failure Mode and Effect Analysis)</em> - є найбільш популярним підходом до тестування, що базується на ризиках. Це модель аналізу причин і наслідків відмов системи, яка визначає потенційні дефекти і причини їх виникнення. Робота за такою моделлю передбачає, що команда проєкту намагається визначити всі компоненти, процеси, модулі, в яких може статися збій. Цей збій з різною часткою ймовірності може призвести до погіршення якості ПЗ. Для вимірювання таких збоїв використовують 3 показники: серйозність, пріоритет і ймовірність. Кожному ризику призначається Risk Priority Number (RPN) і залежно від показників закладається глибина тестування.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=53-api>53. Тестування API? Інструменти<a class=headerlink href=#53-api title="Permanent link">&para;</a></h3> <p><em>API (програмний інтерфейс додатка)</em> - набір процедур, протоколів та інструментів для створення програмних додатків. API визначає, як додаток має взаємодіяти з іншими програмами. </p> <p>Тестування API передбачає перевірку правильності цих взаємодій.</p> <p><strong>Інструменти</strong>: Swagger, SoapUI, Postman</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=54-load-stress-stability-testing>54. Load, Stress та Stability testing? Якими інструментами користуються для їх виконання<a class=headerlink href=#54-load-stress-stability-testing title="Permanent link">&para;</a></h3> <p><em>Навантажувальне тестування (load testing)</em> - виконання програми з підвищенням навантаження, аж до досягнення запланованих характеристик, і далі з відстеження поведінки на всьому протязі підвищення завантаження системи. <img alt=IMG src=images/load_test.png></p> <p><em>Стресове тестування (stress testing)</em> - тестування, що оцінює систему на граничних значеннях робочих навантажень або за їх межами, або ж у стані обмежених ресурсів, таких як пам'ять або доступ до сервера. <img alt=IMG src=images/stress_test.png></p> <p><em>Тестування стабільності (stability testing)</em> - перевірка працездатності програми при тривалому (багатогодинному) тестуванні із середнім рівнем навантаження. Часи виконання операцій можуть грати у цьому вигляді тестування другорядну роль. У цьому перше місце виходить відсутність витоків пам'яті, перезапусків серверів під навантаженням тощо. <img alt=IMG src=images/stability_test.png></p> <p><strong>Інструменти</strong>: LoadRunner, Apache JMeter, Gatling</p> <h1 id=aqa-automation-qa><strong>AQA (Automation QA)</strong><a class=headerlink href=#aqa-automation-qa title="Permanent link">&para;</a></h1> <h1 id=selenium><em>Selenium</em><a class=headerlink href=#selenium title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=55>55. Як ви будуватимете і впроваджуватимете стратегію з автоматизації тестування<a class=headerlink href=#55 title="Permanent link">&para;</a></h3> <p><a href=https://habr.com/ua/post/275171/ >https://habr.com/ua/post/275171/</a></p> <p>3 варіанти стратегій, характерних для початку розгортання автоматизації.</p> <p><strong><em>1. Стратегія Let's try</em></strong> Застосовується в тому випадку, коли АТ ні на проекті, ні в компанії ніколи не було, і планується обережний старт з помірним виділенням ресурсів.</p> <p>Має сенс застосовувати у разі, коли: * Відсутні точні цілі автоматизації (покрити 40% коду конкретного модуля до певної дати, зменшення витрат на ручне тестування тощо). * АТ на проекті раніше ніколи не застосовувалася. * У тестувальників відсутній (або дуже малий) досвід АТ. * Виділені ресурси помірні чи низькі.</p> <p>Опис стратегії: * Більше уваги приділяти підготовчим етапам тестування (складання тест-планів, тест-кейсів тощо). * Більше уваги приділяти інструментам, які можна використовувати як допомогу у ручному тестуванні. * Більше експериментувати з технологіями та методологіями АТ. Ніхто не чекає на термінові результати і можна експериментувати. * Працювати з проектом, починаючи з верхнього рівня, спочатку не заглиблюючись в автоматизацію конкретних модулів.</p> <p><strong><em>2. Стратегія Here the target</em></strong> Особливістю стратегії є орієнтування на конкретний результат. Вибирається/визначається мета нового етапу АТ, і завдання орієнтуються досягнення цього результату.</p> <p>Має сенс застосовувати у разі, коли: * Коли на проекті вже проведено попередню роботу, є якийсь бекграунд у вигляді тест-планів, тест-кейсів, автотестів попереднього етапу АТ. * Є конкретна мета АТ (не глобальна - 80% автотестів за півроку, а скоріше 50% автотестів конкретного модуля за місяць) * Для виконання конкретної мети обрані конкретні інструменти, оптимально якщо спеціалісти мають певний технічний бекграунд по роботі з інструментами.</p> <p>Опис стратегії: * Поступальна стратегія, яка чимось нагадує Agile методології розробки. Рух вперед етапами. Покриття автотестами модуля за модулем, до виконання мета завдань виду (80% за півроку). * На кожен етап виставляється нова мета (найімовірніше продовжує останню виконану мету, але не обов'язково), і вибираються інструменти для реалізації цієї мети. * Глибоке фокусування на конкретну мету, написання тест-кейсів, автотестів, не для всього проекту, а виключно під конкретне завдання.</p> <p><strong><em>1.3 Стратегія «Operation Uranum»</em></strong> По суті, стратегія — постійна і методична робота над АТ за пріоритетами, що виставляються раз на 2-3 тижні. Оптимально - наявність постійно працює саме над автоматизацією людини, яка не особливо відволікається на сторонні завдання.</p> <p>Має сенс застосовувати у разі, коли: * Відсутні конкретні цілі, є лише загальне побажання «щоб усе було добре». Якщо Here the target нагадує за принципом роботи Agile, то дана стратегія близька за духом до методології Waterfall. * Є ресурс у вигляді хоча б одного постійно діючого на проекті людини, щільно зайнятого завданням автоматизації. * Немає чітко виражених цілей АТ, проте є побажання (пріоритети), які можна виставити на досить тривалий період часу (дані модулі більш важливі, ніж ті, більше помилок традиційно в бекенді/фронтенді, тому великі зусилля варто спрямувати на нього).</p> <p>Опис стратегії: * Ідея стратегії описана вище, постійна та методична робота з урахуванням виставлених пріоритетів. * На початку потрібен упор у базову частину, оскільки так чи інакше в рамках даної стратегії автоматизується весь проект без повного фокусування на конкретних модулях.</p> <p>Стратегія може бути представлена як у вигляді традиційно розписаного документа, так і у наочному форматі <img alt=IMG src=images/strategy.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=56-alerts>56. Як обробляти браузерні повідомлення (alerts)<a class=headerlink href=#56-alerts title="Permanent link">&para;</a></h3> <div class="language-javascript highlight"><pre><span></span><code><span id=__span-110-1><a id=__codelineno-110-1 name=__codelineno-110-1 href=#__codelineno-110-1></a><span class=nx>Alert</span><span class=w> </span><span class=nx>alert</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>driver</span><span class=p>.</span><span class=nx>switchTo</span><span class=p>().</span><span class=nx>alert</span><span class=p>();</span>
</span><span id=__span-110-2><a id=__codelineno-110-2 name=__codelineno-110-2 href=#__codelineno-110-2></a><span class=nx>alert</span><span class=p>.</span><span class=nx>getText</span><span class=p>();</span>
</span><span id=__span-110-3><a id=__codelineno-110-3 name=__codelineno-110-3 href=#__codelineno-110-3></a><span class=nx>alert</span><span class=p>.</span><span class=nx>sendkeys</span><span class=p>(</span><span class=nb>String</span><span class=w> </span><span class=nx>stringToSend</span><span class=p>);</span>
</span><span id=__span-110-4><a id=__codelineno-110-4 name=__codelineno-110-4 href=#__codelineno-110-4></a><span class=nx>alert</span><span class=p>.</span><span class=nx>accept</span><span class=p>();</span><span class=w> </span><span class=err>/ alert.dismiss();</span>
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=57-appium>57. Концепція дизайну Appium<a class=headerlink href=#57-appium title="Permanent link">&para;</a></h3> <p>Appium - HTTP-сервер, написаний на платформі Node.js, який управляє сесіями iOS та Android, використовуючи дротовий протокол WebSON JSON. Отже, перед ініціалізацією сервера Appium Node.js має бути попередньо встановлений у системі. Коли Appium завантажено та встановлено, на нашому комп'ютері налаштовується сервер, який надає REST API. Він отримує запит на підключення та команду від клієнта та виконує цю команду на мобільних пристроях (Android/iOS) Він відповідає HTTP-відповідями. Знову ж таки, щоб виконати цей запит, він використовує платформи автоматизації мобільних тестів для управління інтерфейсом додатків. Обмеження: * Інструменти Apple для iOS (інструменти доступні тільки в Xcode 3.0 або пізнішої версії з OS X v10.5 і пізнішої версії) * Google UIAutomator для Android API рівня 16 або вище * Selendroid для Android API рівня 15 або нижче</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=58-electron-selenium>58. Electron? Як використовувати Selenium для тестування програм на його основ<a class=headerlink href=#58-electron-selenium title="Permanent link">&para;</a></h3> <p><em>Electron</em> — це фреймворк для розробки настільних програм з використанням HTML, CSS та JavaScript. Такі програми можуть працювати на різних платформах. Серед них – Windows, Mac та Linux. В основі Electron лежать проекти Chromium та Node.js, об'єднані в єдине середовище, що забезпечує роботу програм. Це дає можливість використовувати веб-технології при розробці настільних програм.</p> <p><em>JS приклад для тесту Electron програми з використанням Selenium</em>: <div class="language-js highlight"><pre><span></span><code><span id=__span-111-1><a id=__codelineno-111-1 name=__codelineno-111-1 href=#__codelineno-111-1></a><span class=kd>const</span><span class=w> </span><span class=nx>webdriver</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>require</span><span class=p>(</span><span class=s1>&#39;selenium-webdriver&#39;</span><span class=p>)</span>
</span><span id=__span-111-2><a id=__codelineno-111-2 name=__codelineno-111-2 href=#__codelineno-111-2></a><span class=kd>const</span><span class=w> </span><span class=nx>driver</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>новий</span><span class=w> </span><span class=nx>webdriver</span><span class=p>.</span><span class=nx>Builder</span><span class=p>()</span>
</span><span id=__span-111-3><a id=__codelineno-111-3 name=__codelineno-111-3 href=#__codelineno-111-3></a><span class=w>   </span><span class=c1>// The &quot;9515&quot; є портом зареєстрованим ChromeDriver.</span>
</span><span id=__span-111-4><a id=__codelineno-111-4 name=__codelineno-111-4 href=#__codelineno-111-4></a><span class=w>   </span><span class=p>.</span><span class=nx>usingServer</span><span class=p>(</span><span class=s1>&#39;http://localhost:9515&#39;</span><span class=p>)</span>
</span><span id=__span-111-5><a id=__codelineno-111-5 name=__codelineno-111-5 href=#__codelineno-111-5></a><span class=w>   </span><span class=p>.</span><span class=nx>withCapabilities</span><span class=p>({</span>
</span><span id=__span-111-6><a id=__codelineno-111-6 name=__codelineno-111-6 href=#__codelineno-111-6></a><span class=w>     </span><span class=s1>&#39;goog:chromeOptions&#39;</span><span class=o>:</span><span class=w> </span><span class=p>{</span>
</span><span id=__span-111-7><a id=__codelineno-111-7 name=__codelineno-111-7 href=#__codelineno-111-7></a><span class=w>       </span><span class=c1>// Тут є шлях до нашого електронного binary.</span>
</span><span id=__span-111-8><a id=__codelineno-111-8 name=__codelineno-111-8 href=#__codelineno-111-8></a><span class=w>       </span><span class=nx>binary</span><span class=o>:</span><span class=w> </span><span class=s1>&#39;/Path-to-Your-App.app/Contents/MacOS/Electron&#39;</span>
</span><span id=__span-111-9><a id=__codelineno-111-9 name=__codelineno-111-9 href=#__codelineno-111-9></a><span class=w>     </span><span class=p>}</span>
</span><span id=__span-111-10><a id=__codelineno-111-10 name=__codelineno-111-10 href=#__codelineno-111-10></a><span class=w>   </span><span class=p>})</span>
</span><span id=__span-111-11><a id=__codelineno-111-11 name=__codelineno-111-11 href=#__codelineno-111-11></a><span class=w>   </span><span class=c1>// note: use .forBrowser(&#39;electron&#39;) for selenium-webdriver &lt;= 3.6.0</span>
</span><span id=__span-111-12><a id=__codelineno-111-12 name=__codelineno-111-12 href=#__codelineno-111-12></a><span class=w>   </span><span class=p>.</span><span class=nx>forBrowser</span><span class=p>(</span><span class=s1>&#39;chrome&#39;</span><span class=p>)</span>
</span><span id=__span-111-13><a id=__codelineno-111-13 name=__codelineno-111-13 href=#__codelineno-111-13></a><span class=w>   </span><span class=p>.</span><span class=nx>build</span><span class=p>()</span>
</span><span id=__span-111-14><a id=__codelineno-111-14 name=__codelineno-111-14 href=#__codelineno-111-14></a><span class=nx>driver</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;http://www.google.com&#39;</span><span class=p>)</span>
</span><span id=__span-111-15><a id=__codelineno-111-15 name=__codelineno-111-15 href=#__codelineno-111-15></a><span class=nx>driver</span><span class=p>.</span><span class=nx>quit</span><span class=p>()</span>
</span></code></pre></div></p> <h1 id=_5>Тестова інфраструктура<a class=headerlink href=#_5 title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=59>59. Що таке і чим відрізняються віртуальна машина, симулятор та емулятор<a class=headerlink href=#59 title="Permanent link">&para;</a></h3> <p><em>Віртуалізація</em> – приховування конкретної реалізації за універсальним стандартизованим методом звернення до ресурсів. Інакше кажучи, це створення абстракції над апаратним забезпеченням.</p> <p><em>Повна емуляція (симуляція)</em> - віртуальна машина повністю віртуалізує все апаратне забезпечення при збереженні гостьової ОС у постійному вигляді. Такий підхід дозволяє емулювати різні апаратні архітектури. Основний мінус даного підходу полягає у високій ресурсозатратності.</p> <p><em>Часткова емуляція (нативна віртуалізація)</em> - віртуальна машина віртуалізує лише необхідну кількість апаратного забезпечення, щоб вона могла бути запущена ізольовано. Цей вид віртуалізації дозволяє суттєво збільшити швидкодію гостьових систем, наближаючи його до швидкодії фізичної платформи, за рахунок застосування гіпервізора, що є сполучною ланкою між гостьовими системами та апаратурою.</p> <p><em>Гіпервізор (Virtual Machine Monitor/Монітор віртуальних машин)</em> - спеціальний «прошарок» між гостьовою ОС та обладнанням, що дозволяє гостьовій системі безпосередньо звертатися до ресурсів апаратного забезпечення.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=60>60. Контейнер і чим він відрізняється від віртуальної машини<a class=headerlink href=#60 title="Permanent link">&para;</a></h3> <p><em>Контейнер</em> - це абстракція на рівні програми, що поєднує код та залежності. Контейнери реалізуються поверх ядра ОС вузла (яке можна вважати своєрідним фундаментом ОС) і містять лише програми та деякі API-інтерфейси та служби ОС, що працюють у режимі користувача. На відміну від контейнерів, віртуальні машини працюють під керуванням повноцінної ОС із власним ядром.</p> <p><strong>Архітектура контейнера</strong></p> <p><img alt=IMG src=images/container.svg></p> <p><strong>Архітектура віртуальної машини</strong></p> <p><img alt=IMG src=images/virtual_machine.svg></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=61-iaas-paas>61. IaaS та PaaS? Приклади використання<a class=headerlink href=#61-iaas-paas title="Permanent link">&para;</a></h3> <p><em>IaaS (Infrastructure as a Service/інфраструктура як послуга)</em>.<br> Сюди відносять обчислювальні ресурси: віртуальні сервери, сховища, мережі. Це щось на зразок віртуальних «комп'ютерів», на які можна встановити будь-що: ОС, ПЗ, додатки.</p> <p>Постачальник IaaS (інфраструктури як сервісу), або хмарний провайдер, вже все купив та зібрав, забезпечив сервери електрикою та інтернетом. Вам залишається лише підключитися до цих обчислювальних потужностей через інтернет та використовувати їх для своїх цілей.</p> <p><strong>Приклади IaaS</strong>:</p> <ul> <li>Перенесення IT-систем у хмару</li> <li>Економія на інфраструктурі</li> <li>Швидкий запуск бізнесу</li> <li>Розширення інфраструктури</li> <li>Інфраструктура для компаній з стрибками попиту</li> <li>Розробка та тестування</li> </ul> <p><em>PaaS (Platform as a Service/платформа як послуга)</em> - вже налаштовані інструменти (платформи) під різні завдання.</p> <p>Ключова відмінність PaaS від IaaS в тому, що тут у вас є певні інструменти, наприклад система управління БД, середовище машинного навчання або обробки big data.<br> Їх потрібно налаштувати під потреби компанії, але не треба будувати з нуля. Що дозволяє заощаджувати час розробників.<br> Наприклад, не потрібно возитися з розробкою БД, можна просто завантажити в неї інформацію та працювати. </p> <p>При цьому немає доступу до ОС, налаштувань віртуальних серверів, що лежать в основі PaaS, а також до налаштувань низької рівня самої платформи.<br> Провайдер бере на себе їхню оптимальну конфігурацію і знімає з вас необхідність стежити за налаштуваннями, оновленнями, масштабуванням та безпекою.<br> Ви отримуєте доступ лише до інтерфейсів самої платформи.</p> <p><strong>Приклади PaaS</strong>:</p> <ul> <li>БД</li> <li>Розробка додатків у контейнерах</li> <li>Аналітика великих даних</li> <li>Машинне навчання</li> </ul> <p><em>SaaS (Software as a Service/програмне забезпечення як сервіс)</em> — повністю налаштована і готова до роботи програма, що виконує певні функції. Єдина відмінність технології SaaS від програми на смартфоні чи комп'ютері в тому, що сам софт знаходиться у хмарі.</p> <p><strong>Приклади SaaS</strong>:</p> <ul> <li>електронна пошта</li> <li>CRM-системи</li> <li>планувальники завдань</li> <li>веб-конструктори для створення сайтів</li> <li>платформи для ведення блогів</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=62-configuration-management>62. Configuration Management<a class=headerlink href=#62-configuration-management title="Permanent link">&para;</a></h3> <p><em>Configuration Management (управління конфігурацією проекту)</em> – ідентифікація, створення, підтримання та контроль конфігурації в ході проекту.</p> <p><strong>Основне завдання</strong>: у будь-який час мати доступ до 100% актуальної версії конфігураційного елемента, які необхідно використовувати, і бути впевненим, що жоден конфігураційний елемент не конфліктує з іншими конфігураційними елементами.</p> <p><strong>Етапи</strong>: </p> <ol> <li>Ідентифікація конфігурації проекту та створення початкової (базової) конфігурації проекту<ul> <li>Початкова конфігурація продукту</li> <li>Початкова конфігурація проекту</li> </ul> </li> <li>Розробка плану управління конфігурацією проекту</li> <li>Контроль зміни під час проекту</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=63-ssh>63. SSH і як ним користуватися<a class=headerlink href=#63-ssh title="Permanent link">&para;</a></h3> <p><em>SSH(Secure Shell)</em> - протокол віддаленого керування комп'ютером з ОС Linux. В основному ssh використовується для віддаленого керування серверами через термінал, але може використовуватися для доступу до будь-яких пристроїв з Linux. <strong>Підключитися</strong>:</p> <div class="language-shell highlight"><pre><span></span><code><span id=__span-112-1><a id=__codelineno-112-1 name=__codelineno-112-1 href=#__codelineno-112-1></a><span class=nv>$ssh</span><span class=w> </span>user@host
</span></code></pre></div> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=64-bash-batch>64. Bash і Batch скрипти? Для чого їх використовують<a class=headerlink href=#64-bash-batch title="Permanent link">&para;</a></h3> <p><em>Bash-скрипти (shell script)</em> - сценарії командного рядка, написані для оболонки bash для Unix-подібних ОС. <em>Batch-файл (пакетний файл/батнік)</em> — сценарії командного рядка, MS-DOS, OS/2 або Windows.</p> <p><em>Сценарії командного рядка</em> — набори тих самих команд, які можна вводити з клавіатури, зібрані у файли та об'єднані якоюсь спільною метою. У цьому результати роботи команд можуть бути або самостійну цінність, або бути вхідними даними інших команд. Є потужним способом автоматизації дій, що часто виконуються.</p> <h1 id=web><em>Web</em><a class=headerlink href=#web title="Permanent link">&para;</a></h1> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=65>65. Різниця між авторизацією та автентифікацією<a class=headerlink href=#65 title="Permanent link">&para;</a></h3> <p><em>Ідентифікація</em> — процедура, в результаті виконання якої для суб'єкта ідентифікації виявляється його ідентифікатор, який однозначно визначає цього суб'єкта в інформаційній системі.</p> <p><em>Аутентифікація</em> — процедура автентифікації, наприклад автентифікація користувача шляхом порівняння введеного ним пароля з паролем збереженим у базі даних.</p> <p><em>Авторизація</em> — надання певній особі чи групі осіб прав виконання певних дій.</p> <p><strong>Приклад</strong>: * Користувач вказує логін -&gt; система розпізнає його як існуючий (<strong><em>ідентифікація</em></strong>) * користувач вводить пароль -&gt; пароль збігся -&gt; система погоджується, що користувач, схоже, дійсно справжній (<strong><em>аутентифікація</em></strong>) * користувач правильно вводить додатковий одноразовий код -&gt; система остаточно погоджується, що це справжній власник облікового запису (<strong><em>двофакторна аутентифікація</em></strong>) * система надасть користувачеві право читати листи у його поштовій скриньці (<strong><em>авторизація</em></strong>)</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=66-400>66. Чи може сервер відправити код 400, якщо проблема на його стороні<a class=headerlink href=#66-400 title="Permanent link">&para;</a></h3> <p><em>400 (Bad Request)</em> - безпосередньо пов'язані з клієнтом (браузером, наприклад) і натякає те що, що відправлений запит із боку користувача призводить до збою ще до того, як його обробить сервер, по крайнього заходу вважає сам сервер. Найчастіше сервер відправляє цей код, коли несправність не підходить більше ні під одну категорію помилок. <strong>Через що спливає Bad Request</strong>: 1. Некоректно налаштовані HTTP-заголовки у запиті. Деякі програми та сайти моніторять заголовки щодо наявності в них чогось підозрілого. Якщо запит не відповідає очікуванням сервера, то висока ймовірність появи помилки 400 (це завжди вина користувача). 2. Якщо клієнт намагається завантажити на сервер файл надто великого розміру. На більшості сайтів є обмеження за розміром даних, що завантажуються. Причому обмеження може бути як 2 гігабайти, так і 600 кілобайт. 3. Користувач намагається отримати доступ до неіснуючої сторінки. Тобто в браузер банально ввели посилання з друкарською помилкою, некоректним доменом або піддоменом. 4. Застарілі або змінені файли cookie. Сервер може сприйняти заміну файлів cookie як спробу атакувати або скористатися дірою в безпеці. Такі запити відразу блокуються.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=67-websocket>67. Як перевірити обрив з'єднання WebSocket<a class=headerlink href=#67-websocket title="Permanent link">&para;</a></h3> <p><div class="language-js highlight"><pre><span></span><code><span id=__span-113-1><a id=__codelineno-113-1 name=__codelineno-113-1 href=#__codelineno-113-1></a><span class=c1>//Властивість</span>
</span><span id=__span-113-2><a id=__codelineno-113-2 name=__codelineno-113-2 href=#__codelineno-113-2></a><span class=nx>socket</span><span class=p>.</span><span class=nx>readyState</span>
</span></code></pre></div> * 0 – CONNECTING - з'єднання ще не встановлено * 1 - OPEN - обмін даними * 2 - CLOSING - з'єднання закривається * 3 – CLOSED - з'єднання закрите</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=68->68. Основні види вразливості веб-додатків<a class=headerlink href=#68- title="Permanent link">&para;</a></h3> <ul> <li><em>Ін'єкції</em>. Вразливості такого класу починаються SQL-ін'єкціями, у різних варіаціях, і замикаються RCE - віддаленим виконанням коду.</li> <li> <ul> <li>XSS (Міжсайтовий скриптинг) * - вразливість, що зустрічається на даний момент рідше, ніж раніше, але незважаючи на це не стала менш небезпечною. Особливо для користувачів, адже атака XSS націлена саме на них. Загалом зловмисник впроваджує скрипт у веб-додаток, який спрацьовує для кожного користувача, який відвідав шкідливу сторінку.</li> </ul> </li> <li><em>LFI/RFI</em>. Уразливості даного класу дозволяють зловмисникам через браузер включати локальні та віддалені файли на сервері у відповідь від веб-програми. Цей пролом є там, де відсутня коректна обробка вхідних даних, якою може маніпулювати зловмисник, інжектувати символи типу path traversal і включати інші файли з веб-сервера.</li> <li><em>JSON Injection</em> - Проста ін'єкція JSON на стороні сервера може бути виконана для викрадення cookie.</li> <li><em>JSON Hijacking (Захоплення JSON)</em> — атака, в певному сенсі схожа на підробку міжсайтових запитів (CSRF), коли зловмисник намагається перехопити дані JSON, надіслані веб-додатку з веб-сервера.</li> <li><em>Атака зовнішньої сутності XML (XML External Entity/XXE)</em> — тип атаки, в якому використовується широко доступна, але рідко використовується функція синтаксичних аналізаторів XML. Використовуючи XXE, зловмисник може викликати відмову в обслуговуванні (DoS), а також отримати доступ до локального та віддаленого контенту та служб. XXE може використовуватися для виконання підробки запитів на стороні сервера (SSRF), змушуючи веб-програму виконувати запити до інших програм. У деяких випадках за допомогою XXE може навіть виконати сканування портів та віддалене виконання коду.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=69-web-performance-client-side>69. Які інструменти для тестування Web performance client-side знаєте<a class=headerlink href=#69-web-performance-client-side title="Permanent link">&para;</a></h3> <p><strong><em>Playwright with Lighthouse</em></strong> <a href=https://nuancesprog.ru/p/15590/ >https://nuancesprog.ru/p/15590/</a></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=70-c>70. Cніфери? Які знаєте<a class=headerlink href=#70-c title="Permanent link">&para;</a></h3> <p><em>Аналізатор трафіку (sniffer/сніфер)</em> — програма або пристрій для перехоплення та аналізу мережевого трафіку (свого та/або чужого). <strong>Види</strong>: * апаратні * програмні * апаратно-програмні * онлайн-аплети</p> <p><strong>Відомі сніфери</strong> * Wireshark/Ethereal * ZxSniffer * IRIS</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=71-drop-truncate>71. Різниця між DROP та TRUNCATE<a class=headerlink href=#71-drop-truncate title="Permanent link">&para;</a></h3> <p><strong>Команди SQL</strong> <a href=https://tproger.ru/translations/sql-recap/ >https://tproger.ru/translations/sql-recap/</a></p> <p><em>DROP (DDL команда)</em> - видалення структури таблиці. Видаляє також всі індекси, рядки, обмеження та тригери таблиці. Функції та процедури, що залежать від таблиці, залишаться, але стануть недійсними. Тригери DML не спрацьовують. Відкат не підтримується. Не можна використовувати з оператором WHERE.</p> <p><em>DELETE (DML команда)</em> - видаляє одну чи кілька рядків з таблиці чи уявлення, у своїй ця операція завжди повністю реєструється у журналі транзакцій, тобто. кожен віддалений рядок. Виконується з використанням блокування кожного рядка, що видаляється. Може активувати тригер. Підтримка відкату. Може використовуватися з виразом WHERE.</p> <p><em>TRUNCATE (DDL команда)</em> - видаляє всі рядки в таблиці, не записуючи журнал транзакцій видалення окремих рядків даних. Видалити всі дані в таблиці, але не видалити структуру таблиці. У разі видалення всіх записів блокується вся таблиця. Не може використовуватися з оператором where. Відкат не підтримується. TRUNCATE TABLE схожа на інструкцію DELETE без пропозиції WHERE, але вона виконується швидше і вимагає менше ресурсів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=72-case>72. Функція CASE<a class=headerlink href=#72-case title="Permanent link">&para;</a></h3> <p><em>CASE</em> перевіряє істинність набору умов та залежно від результату перевірки може повертати той чи інший результат.</p> <p>Має два формати (обидва підтримують додатковий аргумент ELSE): * простий вираз CASE для визначення результату порівнює вираз із набором простих виразів * пошуковий вираз CASE для визначення результату обчислює набір логічних виразів</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=73-collation>73. Що таке collation<a class=headerlink href=#73-collation title="Permanent link">&para;</a></h3> <p><em>Collation</em> - параметр вказує SQL серверу, як потрібно сортувати та порівнювати рядки. Наприклад, різні чи ні рядки “Apple” та “apple” залежить від зазначеного Collation.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=74-graphql>74. Що таке схема GraphQL<a class=headerlink href=#74-graphql title="Permanent link">&para;</a></h3> <p><em>GraphQL Schema</em> – опис типів даних на сервері, зв'язків між ними та логіки отримання цих самих даних. <strong>Включає параметри</strong>: * <em>query</em> - для операцій отримання даних * <em>mutation</em> - для операцій зміни даних * <em>subscription</em> - для підписки на події</p> <p>Обов'язковим параметром є лише query, без нього схема просто не запуститься. <strong>Стан операцій у GraphQL</strong>: * <em>stateless</em> - всі операції в query і mutation повинні бути без стану, тобто. якщо в кластері багато машин, що обслуговують запити клієнтів, то неважливо на який із серверів прилетів запит. Його може виконати будь-яка нода. * <em>statefull</em> - має бути в операцій subscription, т.к. потрібне встановлення постійного підключення з клієнтом, зберігання даних про підписки, механізм перепідключення та відновлення даних про існуючі підписки. Пакет graphql ніяк не допомагає у вирішенні цих адмінських проблем.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=75-oltp-olap>75. Різниця між OLTP та OLAP<a class=headerlink href=#75-oltp-olap title="Permanent link">&para;</a></h3> <p><em>OLTP (Online Transaction Processing/оперативна обробка транзакцій)</em> - метод проведення транзакцій у режимі реального часу з використанням онлайнової БД, яка автоматично оновлюється в міру здійснення транзакцій. Такі підприємства, як банки, готелі та ресторани, часто використовують OLTP, щоб їхні співробітники та клієнти могли одночасно та ефективно виконувати кілька транзакцій у реальному часі, зберігаючи при цьому точність даних. У міру здійснення транзакцій системи OLTP автоматично оновлюють залишки на рахунках і зберігають іншу важливу інформацію, таку як дата і час. Зазвичай це реляційні БД.</p> <p><em>OLAP (Online Analytical Processing/оперативна аналітична обробка)</em> - сервіс для аналізу великого обсягу даних з кількох вимірів. Тут вимір відноситься до елемента певного набору даних. Наприклад, якщо компанія володіє даними про свої рекламні кампанії, включаючи такі елементи, як вплив на споживачів, тривалість реклами, дохід від продукту та вартість реклами, вона може використовувати OLAP для сортування та аналізу даних по кожному елементу. Підприємства часто використовують OLAP для складних аналітичних розрахунків, інтелектуального аналізу даних, фінансового аналізу, складання бюджету та прогнозування. Зазвичай це багатовимірні БД.</p> <p><em>Нормалізація</em> - має на увазі зберігання інформації максимально просто і не надмірно. Максимально просто: не зберігати в одному стовпці ПІБ, а зробити 3 окремі. Не надмірно: прізвище клієнта має зберігатися лише у довіднику клієнтів, і його не потрібно додавати у зроблені клієнтом замовлення. <em>Денормалізація</em> - процес протилежний нормалізації.</p> <p><strong>Ключові відмінності</strong>: * OLAP – категорія програмних інструментів, які аналізують дані, що зберігаються у БД, тоді як OLTP підтримує орієнтовані на транзакції додатки у трирівневій архітектурі. * OLAP створює єдину платформу для всіх типів потреб бізнес-аналізу, яка включає планування, бюджетування, прогнозування та аналіз, а OLTP корисний для адміністрування повсякденних транзакцій організації. OLAP характеризується великим обсягом даних, тоді як OLTP характеризується великою кількістю коротких онлайн-транзакцій. * У OLAP сховище даних створюється унікальним чином, щоб у нього можна було інтегрувати різні джерела даних для побудови консолідованої БД, тоді як OLTP використовує традиційні СУБД.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=76-sql-server>76. Типи реплікації в SQL Server?<a class=headerlink href=#76-sql-server title="Permanent link">&para;</a></h3> <p><em>Реплікація</em> - набір технологій копіювання та розповсюдження даних та об'єктів БД між БД, а також синхронізації БД для підтримки узгодженості.</p> <ul> <li>Реплікація транзакцій - зміни на видавця доставляються передплатнику в міру їх появи (майже в реальному часі). Зміни даних застосовуються на передплатнику у тому порядку й у межах транзакцій, у яких вони виконувались у видавця.</li> <li>Реплікація злиттям – дані можна змінювати як на видавці, так і на передплатнику, а також відстежувати за допомогою тригерів. Передплатник синхронізується з видавцем під час підключення до мережі та обмінюється з ним усіма рядками, які змінилися з часу останньої синхронізації видавця та передплатника.</li> <li>Реплікація моментальних знімків - моментальний знімок видавця застосовується до передплатника. Дані розповсюджуються точно у тому вигляді, в якому вони були представлені у певний момент часу. Оновлення даних не відстежується. Під час синхронізації формується моментальний знімок і надсилається передплатникам повністю.</li> <li>Однорангова реплікація - заснована на реплікації транзакцій, поширює узгоджені лише на рівні транзакцій зміни між кількома екземплярами сервера майже реальному часі.</li> <li>Двонаправлена реплікація - являє собою особливу топологію реплікації транзакцій, яка дозволяє двом серверам обмінюватися змінами один з одним: кожен сервер публікує дані, після чого підписується на публікацію з тими самими даними від іншого сервера.</li> <li>Попередні підписки - засновані на реплікації транзакцій. Коли дані для оновлюваної передплати оновлюються на передплатнику, вони спочатку поширюються на видавця, а потім на інших передплатників.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=77-self-join>77. Self Join<a class=headerlink href=#77-self-join title="Permanent link">&para;</a></h3> <p><em>SELF JOIN</em> - використовується для поєднання таблиці з нею самою таким чином, ніби це дві різні таблиці, тимчасово перейменовуючи одну з них. Потрібен тоді, коли у різних полів однієї таблиці можуть бути однакові значення. Наприклад, той самий учасник музичного гурту може бути і вокалістом, і, наприклад, клавішником.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=78>78. Що такое тестування<a class=headerlink href=#78 title="Permanent link">&para;</a></h3> <p><em>Тестування ПЗ (Software Testing)</em> - перевірка відповідності між реальною та очікуваною поведінкою програми, що здійснюється на кінцевому наборі тестів, обраному певним чином.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=79>79. Піраміда тестування<a class=headerlink href=#79 title="Permanent link">&para;</a></h3> <p><img alt=IMG src=images/pyramid.png></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=80>80. Навіщо тестувати ПЗ<a class=headerlink href=#80 title="Permanent link">&para;</a></h3> <p><em>Мета тестування</em>: * Підвищити ймовірність того, що додаток буде працювати правильно за будь-яких обставин. * Підвищити ймовірність того, що програма, буде відповідати всім описаним вимогам. * Надання актуальної інформації про стан продукту на даний момент.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=81_1>81. Етапи тестування<a class=headerlink href=#81_1 title="Permanent link">&para;</a></h3> <p><em>Етапи</em>: 1. Аналіз продукту 2. Робота з вимогами 3. Розробка стратегії тестування та планування процедур контролю якості 4. Створення тестової документації 5. Тестування прототипу 6. Основне тестування 7. Стабілізація 8. Експлуатація</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=82_1>82. Типи тестування<a class=headerlink href=#82_1 title="Permanent link">&para;</a></h3> <p><em>За цілями</em>: * Безпеки * Функціональне * Нефункціональне * UI * Сумісності * Продуктивності * Навантажувальний * Стабільності * Стрес</p> <p><em>За знанням системи</em>: * Біла скринька * Сірий ящик * Чорний ящик</p> <p><em>За хронологією виконання</em>: * Вхідний (Smoke/intake) * Повторне * Регресійне</p> <p><em>За рівнем автомтизації</em></p> <p><em>За виконанням коду</em></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=83>83. Рівні тестування<a class=headerlink href=#83 title="Permanent link">&para;</a></h3> <ul> <li> <p><em>Модульне/компонентне</em> (unit/component testing)* - тестування найменших елементів ПЗ, які можуть бути протестовані окремо (модулі, об'єкти, класи, функції). Завдання модульного тестування – виявлення локалізованих у модулі помилок реалізації алгоритмів, а також визначення ступеня готовності системи до переходу на наступний рівень розробки та тестування.</p> </li> <li> <p><em>Інтеграційне (integration testing)</em> - тестування частини системи, що складається з двох і більше модулів. Завдання інтеграційного тестування – пошук дефектів, пов'язаних з помилками реалізації та інтерпретації інтерфейсної взаємодії між модулями, а також помилок взаємодії з іншими частинами системи (ОС, обладнанням).</p> </li> <li> <p><em>Системне (system testing)</em> - процес тестування системи загалом із єдиною метою перевірки те, що вона відповідає встановленим вимогам. Завдання системного тестування - виявлення дефектів, пов'язаних із загальною роботою системи, таких як неправильне використання ресурсів системи, непередбачені комбінації даних рівня користувача, несумісність з оточенням, непередбачені сценарії використання, відсутня або неправильна функціональність, незручність у застосуванні і т.д.</p> </li> <li> <p><em>Приймальне (acceptance testing)</em> - формальний процес тестування, який перевіряє відповідність системи потребам, вимогам та бізнес процесам користувача, та проводиться для винесення рішення замовником (внутрішнім або зовнішнім) або іншою уповноваженою особою приймається додаток чи ні.</p> </li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=84->84. Техніки тест-дизайну<a class=headerlink href=#84- title="Permanent link">&para;</a></h3> <ul> <li> <p><em>Еквівалентний Поділ/Класи еквівалентності (Equivalence Partitioning - EP)</em>. Як приклад, у вас є діапазон допустимих значень від 1 до 10, ви повинні вибрати одне правильне значення всередині інтервалу, скажімо, 5, і одне неправильне значення поза інтервалом - 0, отримавши таким чином два значення, що відносяться до різних класів.</p> </li> <li> <p><em>Аналіз Граничних Значень (Boundary Value Analysis - BVA)</em>. Якщо взяти приклад вище, як значення для позитивного тестування виберемо мінімальну і максимальну межі (1 і 10), і значення більше і менше меж (0 і 11). Аналіз Граничний значень може бути застосований до полів, записів, файлів, або до будь-яких сутностей, що мають обмеження. <em>Цінність: помилки часто зустрічаються якраз на межах різних груп значень</em>.</p> </li> <li> <p><em>Попарне тестування (Pairwise Testing)</em> - техніка формування наборів тестових даних. Сформулювати суть можна так: формування таких наборів даних, в яких кожне тестоване значення кожного з параметрів, що перевіряються хоча б один раз поєднується з кожним тестованим значенням всіх інших параметрів, що перевіряються.</p> </li> <li> <p><em>Причина/Слідство (Cause/Effect - CE)</em>. Це, як правило, введення комбінацій умов (Причин) для отримання відповіді від системи (Слідство). Наприклад, ви перевіряєте можливість додавати клієнта, використовуючи певну екранну форму. Для цього вам необхідно буде ввести кілька полів, таких як "Ім'я", "Адреса", "Номер Телефону", а потім натиснути кнопку "Додати" - це "Причина". Після натискання кнопки «Додати» система додає клієнта в базу даних і показує його номер на екрані — це «Слідство».</p> </li> <li> <p><em>Предугадування помилки (Error Guessing - EG)</em>. Це коли тестувальник використовує свої знання системи та здатність до інтерпретації специфікації щодо того, щоб «передбачити» за яких вхідних умов система може видати помилку. Наприклад, специфікація каже: "користувач повинен ввести код". Тестувальник думатиме: «Що, якщо я не введу код?», «Що, якщо я введу неправильний код? ", і так далі. Це і є передбачання помилки.</p> </li> <li> <p><em>Вичерпне тестування (Exhaustive Testing - ET)</em> - крайній випадок. У межах цієї техніки ви повинні перевірити всі можливі комбінації вхідних значень, і в принципі це має знайти всі проблеми. Насправді застосування цього методу неможливо, через велику кількість вхідних значень.</p> </li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=85-regression-confirmation>85. Що таке Regression та Confirmation тестування, яка між ними різниця<a class=headerlink href=#85-regression-confirmation title="Permanent link">&para;</a></h3> <p><em>Повторне/Підтвердне тестування (re-testing/confirmation testing)</em> - тестування, під час якого виконуються тестові сценарії, що виявили помилки під час останнього запуску, для підтвердження успішності виправлення цих помилок.</p> <p><em>Регресійне тестування (regression testing)</em> - тестування вже протестованої програми після модифікації для впевненості в тому, що процес модифікації не вніс або не активізував помилки в областях, що не зазнавали змін. Проводиться після змін у коді або його оточення.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=86>86. Частота регресійного тестування<a class=headerlink href=#86 title="Permanent link">&para;</a></h3> <p>Варто робити по можливості і залежно від частоти втручання у релізи.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=87>87. Види інтеграційного тестування<a class=headerlink href=#87 title="Permanent link">&para;</a></h3> <ul> <li> <p><em>Знизу вгору (Bottom Up Integration)</em>. Усі низькорівневі модулі, процедури або функції збираються докупи і потім тестуються. Після чого збирається наступний рівень модулів щодо інтеграційного тестування. Даний підхід вважається корисним, якщо всі або практично всі модулі, що розробляється, готові. Також цей підхід допомагає визначити за результатами тестування рівень готовності програми.</p> </li> <li> <p><em>Зверху вниз (Top Down Integration)</em>. Спочатку тестуються всі високорівневі модулі і поступово один за одним додаються низькорівневі. Усі модулі нижчого рівня симулюються заглушками з аналогічною функціональністю, потім у міру готовності заміняються реальними активними компонентами. Таким чином, ми проводимо тестування зверху вниз.</p> </li> <li> <p><em>Великий вибух («Big Bang» Integration)</em>. Усі або практично всі розроблені модулі збираються разом у вигляді закінченої системи або її основної частини, а потім проводиться інтеграційне тестування. Такий підхід дуже добрий для збереження часу. Проте якщо тест кейси та його результати записані не так, то сам процес інтеграції сильно ускладниться, що стане перепоною для команди тестування при досягненні основної мети інтеграційного тестування.</p> </li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=88-configuration-testing>88. Configuration Testing<a class=headerlink href=#88-configuration-testing title="Permanent link">&para;</a></h3> <p><em>Конфігураційне тестування (configuration testing)</em> - тестування, спрямоване на перевірку роботи ПЗ при різних конфігураціях системи (заявлених платформах, драйверах, що підтримуються, при різних конфігураціях комп'ютерів і системного ПЗ і т.д.).</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=89-exploratory-testing>89. Exploratory Testing<a class=headerlink href=#89-exploratory-testing title="Permanent link">&para;</a></h3> <p><em>Дослідницьке тестування (exploratory testing)</em> - неформальний метод, у якому тестувальник активно контролює проектування тестів, тоді як ці тести виконуються, і використовує отриману інформацію для проектування нових поліпшених тестів. Таке тестування визначається як одночасне навчання, проектування тесту та його виконання.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=90-performance-testing>90. Performance Testing<a class=headerlink href=#90-performance-testing title="Permanent link">&para;</a></h3> <p><em>Тестування продуктивності (performance testing)</em> - визначення ступеня, з яким система виконує закладені в неї функції у встановлених рамках на час обробки та пропускну здатність. Досить часто під час тестування продуктивності перевіряється відразу кілька його підвидів.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=91-traceability-matrix>91. Traceability Matrix<a class=headerlink href=#91-traceability-matrix title="Permanent link">&para;</a></h3> <p><em>Матриця відповідності вимог (traceability matrix)</em> — двомірна таблиця, що містить відповідність функціональних вимог (functional requirements) продукту та підготовлених тестових сценаріїв (test cases). У заголовках колонок таблиці розміщені вимоги, а заголовках рядків — тестові сценарії. На перетині — позначка, що означає, що вимога поточної колонки покрита тестовим сценарієм поточного рядка. Матриця відповідності вимог використовується QA-інженерами для валідації покриття продукту тестами. МСТ є невід'ємною частиною тест-плану.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=92-end-to-end>92. End-to-End тест<a class=headerlink href=#92-end-to-end title="Permanent link">&para;</a></h3> <p>End-to-End тести - такі інтеграційні тести, які впливають на систему через її зовнішні інтерфейси і перевіряють очікувану реакцію системи через ці ж інтерфейси. Чому саме інтеграційні? Тому що це єдине, що можна про них напевно сказати: вони за визначенням не можуть бути модульними тестами. А все інше: чи є вони одночасно приймальними, навантажувальними чи ще якими - залежить тільки від загальних плану/стратегії тестування та тієї ролі, яку ці тести в них відіграють.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=93>93. Тестування безпеки<a class=headerlink href=#93 title="Permanent link">&para;</a></h3> <p><em>Тестування безпеки/захищеності (security testing)</em> – тестування ПЗ з метою визначити його захищеність. Основні поняття, які мають бути охоплені тестуванням: конфіденційність, цілісність та збереження даних, автентифікація, авторизація та неможливість відмови від авторства.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=94>94. Випробування на основі ризиків<a class=headerlink href=#94 title="Permanent link">&para;</a></h3> <p><em>Тестування на основі ризиків/Ризик-тестування (risk-based testing)</em> — метод тестування програмного забезпечення, який базується на ймовірності ризиків. Їхня ймовірність визначається шляхом аналізу, в якому враховуються складність програми, критичність функції для бізнесу, частота її використання та кількість можливих дефектів. При тестуванні на основі ризиків найбільший пріоритет одержує перевірка найважливіших і потенційно мають недоліки функцій.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=95>95. Динамічне тестування<a class=headerlink href=#95 title="Permanent link">&para;</a></h3> <p><em>Динамічне тестування (dynamic testing)</em> - тестування, яке проводиться під час виконання ПЗ, компонента або системи.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=96-stlc-entry-exit-criteria>96. Основні фази STLC? Дайте визначення Entry та Exit Criteria.<a class=headerlink href=#96-stlc-entry-exit-criteria title="Permanent link">&para;</a></h3> <p>Життєвий цикл тестування (STLC) визначає, які дії виконувати при тестуванні і коли їх виконувати.</p> <p><strong>Фази</strong>: 1. Аналіз вимог 2. Планування тестування 3. Дизайн тесту 4. Налаштування тестового середовища 5. Виконання тесту 6. Завершення тесту</p> <p><em>Критерії входу (Entry Criteria)</em> - містять обов'язкові елементи, які необхідно виконати, перш ніж можна буде розпочати тестування.</p> <p><em>Критерії виходу (Exit Criteria)</em> - визначають елементи, які мають бути виконані до завершення тестування.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=97->97. Атрибути баг-репорту? Які основні поля для заповнення<a class=headerlink href=#97- title="Permanent link">&para;</a></h3> <p><em>Баг Репорт (Bug Report)</em> — документ, що описує ситуацію або послідовність дій, що призвела до некоректної роботи об'єкта тестування, із зазначенням причин та очікуваного результату.</p> <p><strong>Атрибути</strong>: * Короткий опис (Summary/Title) - вижимання інформації, що явно вказує на причину і тип проблеми. * Номер версії (Version) - версія на якій було знайдено помилку * Серйозність (Severity): * S1 Блокуючий (Blocker) * S2 Критичний (Critical) * S3 Значний (Major) * S4 Незначний (Minor) * S5 Тривіальний (Trivial) * Пріоритет (Priority): * P1 Високий (High) * P2 Середній (Medium) * P3 Низький (Low) * Статус (Status) – поточний статус бага. Залежить від процедури та життєвого циклу бага (bug workflow and life cycle) * Оточення (Environment) - ОС / Браузер + версія тощо. Інформація про оточення, на якому було знайдено баг. * Кроки відтворення (Steps to Reproduce) - дії, якими можна легко відтворити ситуацію, що призвела до помилки. * Фактичний Результат (Actual Result) – результат, отриманий після проходження кроків до відтворення * Очікуваний результат (Expected Result) - очікуваний правильний результат</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=98>98. Різниця між пріоритетом і серйозністю<a class=headerlink href=#98 title="Permanent link">&para;</a></h3> <p><em>Серйозність (Severity)</em> - атрибут, що характеризує вплив дефекту на працездатність програми.</p> <p><em>Пріоритет (Priority)</em> - атрибут, що вказує на черговість виконання завдання або усунення дефекту. Більше інструмент менеджера з планування робіт. Чим вищий пріоритет, тим швидше потрібно виправити дефект</p> <p>Зазвичай Severity виставляється тестувальником, а Priority менеджером, тимлідом або замовником.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=99>99. Наведіть приклади серйозного, але не пріоритетного бага.<a class=headerlink href=#99 title="Permanent link">&para;</a></h3> <p>На Андроїді 4.4 програма при першому запуску падає. У наступні запуски працює нормально. Т.к. користувачів з цією версією ОС у нас близько 0,5%, то пріоретет можна поставити низький або взагалі проігнорувати.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=100>100. Навіщо потрібна тестова документація? Які її види<a class=headerlink href=#100 title="Permanent link">&para;</a></h3> <p><a href=https://habr.com/ua/company/otus/blog/588923/ >https://habr.com/ua/company/otus/blog/588923/</a></p> <p><em>Тестова документація</em> — набір документів, що створюються перед початком процесу тестування та безпосередньо у процесі. Ці документи описують покриття тестами та процес виконання тестів, у них вказуються необхідні для тестування речі, наводиться основна термінологія тощо. буд. У тестовій документації будь-який член команди може знайти повну інформацію про всі дії, пов'язані з тестуванням (і про вже виконані, та про заплановані). Тестова документація визначає, що для нас важливо і чому, які дії ми маємо виконати і скільки часу ми маємо. Зрештою, у документації зазначено, чого має досягти команда та що сигналізує про закінчення процесу.</p> <p>Види: * План тестування (test plan) * Чекліст (checklist) * Тестовий сценарій (Test Case) * Баг-репорт (Bug Report) * Звіт про тестування (Test Report) * Інструкція (Manual)</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=101->101. Тест-план? Які елементи має<a class=headerlink href=#101- title="Permanent link">&para;</a></h3> <p><em>План тестування (Test Plan)</em> — документ, що описує весь обсяг робіт із тестування, починаючи з опису об'єкта, стратегії, розкладу, критеріїв початку та закінчення тестування, до необхідного в процесі роботи обладнання, спеціальних знань, а також оцінки ризиків з варіантами їх дозволу.</p> <p>У стандарті IEEE 829 перераховані пункти, з яких може/має складатися тест-план: 1. Test plan identifier 2. Introduction 3. Test items 4. Features to be tested 5. Features not to be tested 6. Approach 7. Item pass/fail criteria 8. Suspension criteria and resumption requirements 9. Test deliverables 10. Testing tasks 11. Environmental needs 12. Responsibilities 13. Staffing and training needs 14. Schedule 15. Risks and contingencies 16. Approvals</p> <h2 id=-_2>Відповіді - 'Бази данних'<a class=headerlink href=#-_2 title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1_1>1. Які бувають види БД<a class=headerlink href=#1_1 title="Permanent link">&para;</a></h3> <p><a href=https://proglib.io/p/11-tipov-sovremennyh-baz-dannyh-kratkie-opisaniya-shemy-i-primery-bd-2020-01-07>https://proglib.io/p/11-tipov-sovremennyh-baz-dannyh-kratkie-opisaniya-shemy-i-primery-bd-2020-01-07</a> 1. Найпростіші типи БД * Текстові файли, csv-файли * Ієрархічні (файлові системи, DNS, LDAP) * Мережні (IDMS)</p> <ol> <li> <p>Реляційні БД (MySQL, PostgreSQL..)</p> </li> <li> <p>NoSQL БД</p> </li> <li>«Ключ-значення» (Redis, memcached)</li> <li>Документні (MongoDB, RethinkDB)</li> <li>Графові (Neo4j, Dgraph)</li> <li>Колонкові (Cassandra, HBase)</li> <li> <p>БД часових рядів (OpenTSDB, TimescaleDB)</p> </li> <li> <p>Комбіновані типи БД</p> </li> <li>NewSQL (MemSQL, VoltDB, CockroachDB)</li> <li>Багатомодельні (OrientDB, Couchbase)</li> </ol> <h2 id=-_3>Відповіді - 'Загальні питання'<a class=headerlink href=#-_3 title="Permanent link">&para;</a></h2> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=1-web-elements>1. Які знаєте Web elements<a class=headerlink href=#1-web-elements title="Permanent link">&para;</a></h3> <p>Кнопки, лейбли, поля введення, списки, що випадають, чекбокси, радіобатони, фрейми</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=2-chrome-devtools>2. Для чого необхідні інструменти розробника в браузері (Chrome DevTools) і як вони допомагають у тестуванні<a class=headerlink href=#2-chrome-devtools title="Permanent link">&para;</a></h3> <ul> <li>Перевизначення геолокації та підміна User-Agent</li> <li>Визначення JS шляху до рядка</li> <li>Зміна HTML-коду та стилів CSS у елементів</li> <li>Тестування продуктивності та невикористовуваних CSS та Javascript у верстці</li> <li>Debug JavaScript</li> <li>Імітація повільного мережевого з'єднання</li> <li>Моніторинг мережевих запитів</li> <li>Інформація про cookies у вкладці applications</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=3_1>3. Що таке кеш<a class=headerlink href=#3_1 title="Permanent link">&para;</a></h3> <p><em>Кеш</em> — проміжний буфер із швидким доступом до нього, що містить інформацію, яка може бути запитана з найбільшою ймовірністю. Доступ до даних у кеші здійснюється швидше, ніж вибірка вихідних даних з повільнішої пам'яті або віддаленого джерела, проте його обсяг істотно обмежений порівняно зі сховищем вихідних даних.</p> <p><em>Кеш браузера</em> - буфер між браузером та інтернетом, у якому зберігаються відвідані користувачем сторінки. Замість того, щоб завантажувати їх із інтернету, браузер може «дістати» сторінки з кешу, що значно скорочує швидкість завантаження сторінок. Проблема може виникнути, якщо на сервері оновиться сторінка, а браузер продовжить підвантажувати стару версію з кешу.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=4_2>4. Що таке сесія<a class=headerlink href=#4_2 title="Permanent link">&para;</a></h3> <p><em>Сесія</em> - механізм, що дозволяє однозначно ідентифікувати браузер і створює для цього браузера файл на сервері, де зберігаються змінні сеансу.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=5-cookies>5. Навіщо потрібні cookies<a class=headerlink href=#5-cookies title="Permanent link">&para;</a></h3> <p><em>Cookies</em> - текстові файли невеликого розміру зі службовою інформацією для браузера. Часто в таких файлах зберігається статистика відвідувань, логін та пароль від сайтів чи сервісів, індивідуальні налаштування користувача – регіон, дизайн оформлення та інше.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=6-iframe-selenium>6. iFrame і як з ним працювати в Selenium<a class=headerlink href=#6-iframe-selenium title="Permanent link">&para;</a></h3> <p><em>Фрейм (Frame/iFrame)</em> — самостійний документ, який відображається в окремому вікні браузера і є повністю закінченою HTML-сторінкою. Простими словами, кадр - роздільник браузерних вікон на окремі області.</p> <p>Способи перемикатися на iframe: * За індексом <code>driver.switchTo().frame(i);</code> * На ім'я або ідентифікатор <code>driver.switchTo().frame("a077aa5e");</code> * За веб-елементом <code>driver.switchTo().frame(driver.findElement(By.cssSelector("#modal&gt;iframe"));</code></p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=7-htmlcssjavascript>7. Що таке HTML/CSS/JavaScript<a class=headerlink href=#7-htmlcssjavascript title="Permanent link">&para;</a></h3> <p><em>HTML (HyperText Markup Language/мова гіпертекстової розмітки)</em> — стандартизована мова розмітки документів для перегляду веб-сторінок у браузері.</p> <p><em>CSS (Cascading Style Sheets/каскадні таблиці стилів)</em> — формальна мова опису зовнішнього вигляду документа (веб-сторінки), написаного з використанням мови розмітки (найчастіше HTML або XHTML). Також може застосовуватися до будь-яких XML-документів, наприклад SVG або XUL.</p> <p><em>JavaScript</em> — мультипарадигмова мова програмування. Підтримує об'єктно-орієнтований, імперативний та функціональний стилі. Часто використовується як вбудована мова для програмного доступу до об'єктів програм. Найширше застосування знаходить у браузерах як мову сценаріїв для надання інтерактивності веб-сторінок.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=8->8. Яку структуру має веб-сторінка<a class=headerlink href=#8- title="Permanent link">&para;</a></h3> <ul> <li>Заголовок: <code>&lt;header&gt;</code></li> <li>Навігаційне меню: <code>&lt;nav&gt;</code></li> <li>Основний вміст: <code>&lt;main&gt;</code>, з різними підрозділами вмісту, представленими елементами <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code> та <code>&lt;div&gt;</code>.</li> <li>Бічна панель: <code>&lt;aside&gt;</code>, зазвичай розташовується всередині <code>&lt;main&gt;</code>.</li> <li>Нижній колонтитул: <code>&lt;footer&gt;</code>.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=9_2>9. Навіщо чистити кеш<a class=headerlink href=#9_2 title="Permanent link">&para;</a></h3> <p>Веб-сторінки можуть відображатися некоректно через те, що в них були внесені зміни, а браузер продовжує використовувати застарілі дані з кешу. Також застарілий кеш може займати місце на залізниці.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=10-ajax>10. Що таке AJAX<a class=headerlink href=#10-ajax title="Permanent link">&para;</a></h3> <p><em>AJAX (Asynchronous JavaScript and XML/асинхронний JavaScript і XML)</em> - технологія, яка описує як можна отримувати дані з сервера у фоновому режимі та використовувати їх для оновлення сторінки (без перезавантаження). Основна мета AJAX – зробити сайти та веб-додатки більш зручними, швидкими та чуйними. Асинхронний тому, що дія виконується у фоні (не в основному потоці), таким чином, що вона не заважає користувачеві взаємодіяти зі сторінкою. JavaScript відповідає за створення та налаштування запиту, надсилання його на сервер, отримання відповіді та його розбір, оновлення сторінки.</p> <p>Переваги використання AJAX:</p> <ul> <li>зниження трафіку (зменшення обсягу переданих даних між клієнтом та сервером)</li> <li>Зменшення навантаження на сервер (перегенерується тільки частина сторінки, яку потрібно оновити)</li> <li>збільшення швидкодії та чуйності (немає необхідності у повному перезавантаженні сторінки, достатньо оновити вміст окремих блоків)</li> <li>підвищення інтерактивності (за допомогою AJAX можна відразу відображати результати та зробити ресурс більш зручним для користування)</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=11-adb>11. Що таке ADB<a class=headerlink href=#11-adb title="Permanent link">&para;</a></h3> <p><em>ADB (Android Debug Bridge)</em> - клієнт-серверна програма, яка надає доступ до працюючого емулятора або пристрою. З його допомогою можна копіювати файли, встановлювати скомпільовані програмні пакети та запускати консольні команди. Складається з трьох компонентів: * фонової служби (демона), що працює в емуляторі * сервісу, запущеного на комп'ютері розробника * клієнтської програми (на зразок DDMS), яка зв'язується зі службою через Сервіс</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=12-http->12. Які є HTTP-методи<a class=headerlink href=#12-http- title="Permanent link">&para;</a></h3> <p><em>GET</em> - запитує інформацію із зазначеного джерела та не впливає на його вміст. Запит доступний для кешування даних та додавання до закладок.</p> <p><em>POST</em> - використовується для надсилання даних, що може впливати на вміст ресурсу. На відміну від методу GET, запити POST не можуть бути кешовані, вони не залишаються в історії браузера і їх не можна додати до закладок.</p> <p><em>HEAD</em> - аналогічний методу GET, проте у відповіді сервера міститься лише заголовок, без тіла. Зазвичай застосовується для того, щоб перевірити, чи існує ресурс за вказаною адресою, а також чи не змінився з моменту останнього звернення.</p> <p><em>PUT</em> - Завантажує вміст запиту на вказаний у запиті URI. Якщо за заданим URI ресурсу немає, сервер створює його, повертаючи статус 201 (Created).</p> <p><em>PATCH</em> - Використовується для часткової зміни ресурсу. У PATCH вкладений об'єкт містить набір інструкцій, що описують, як ресурс, має бути модифікований створення нової версії. А в PUT міститься нова версія ресурсу цілком.</p> <p><em>DELETE</em> - Видаляє вказаний ресурс.</p> <p><em>OPTIONS</em> - Використовується для опису параметрів комунікації між клієнтом та сервером.</p> <p><em>CONNECT</em> - Перетворює з'єднання запиту на прозорий TCP/IP-тунель.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=13-crud>13. Розшифрування CRUD<a class=headerlink href=#13-crud title="Permanent link">&para;</a></h3> <p><em>CRUD</em> — акронім, що означає чотири базові функції, що використовуються під час роботи з постійними сховищами даних: створення (create), читання (read), модифікація (update), видалення (delete).</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=14_1>14. Як відбувається шифрування<a class=headerlink href=#14_1 title="Permanent link">&para;</a></h3> <p><em>Симетричне</em> - використовується лише один пароль/ключ. У системі шифрування передбачений математичний алгоритм. На його цифровий "вхід" подається вихідний ключ та вихідні дані. Далі інформація шифрується та надсилається. При отриманні спрацьовує зворотний алгоритм і проходить процедура дешифрування з використанням того самого ключа. Якщо знати ключ, то безпека симетричного шифрування прямує до нуля. Тому ключ повинен бути максимально складним та заплутаним. Незважаючи на певні обмеження, симетричне шифрування дуже поширене через простоту та швидкодію.</p> <p><em>Асиметричне</em> - використовуються два ключі: відкритий/публічний та закритий/приватний. Перевага асиметричного шифрування в тому, що один із ключів завжди залишається на пристрої і не передається. Схема передачі між двома суб'єктами (А і Б) виглядає так: * Суб'єкт А генерує пару ключів, публічний та приватний. * Суб'єкт А передає публічний ключ суб'єкту Б. Передача може здійснюватися незахищеними каналами. * Суб'єкт Б шифрує пакет даних за допомогою отриманого публічного ключа і передає його А. Передача може здійснюватися незахищеними каналами. * Суб'єкт А розшифровує отриману від Б інформацію з допомогою приватного ключа.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=15-api>15. Які способи взаємодії з API існують? У чому різниця між ними<a class=headerlink href=#15-api title="Permanent link">&para;</a></h3> <ul> <li> <p><em>SOAP (Simple Object Access Protocol)</em> - Простий Протокол Доступу до Об'єктів. Клієнт та сервер обмінюються повідомленнями за допомогою XML. Це менш гнучкий API, який був більш популярним у минулому.</p> </li> <li> <p><em>RPC (Remote Procedure Call)</em> - Видалений Виклик Процедур. Клієнт виконує функцію (або процедуру) на сервері, і сервер надсилає результат назад клієнту.</p> </li> <li> <p>Websocket - сучасна розробка web API, яка використовує об'єкти JSON для передачі даних. WebSocket підтримує двосторонній зв'язок між клієнтськими програмами та сервером. Сервер може надсилати повідомлення зворотного дзвінка підключеним клієнтам, що робить його ефективнішим, ніж REST.</p> </li> <li> <p>REST - на сьогоднішній день це найпопулярніші та гнучкіші API-інтерфейси в Інтернеті. Клієнт надсилає запити на сервер у вигляді даних. Сервер використовує це введення клієнта для запуску внутрішніх функцій і повертає вихідні дані назад клієнту.</p> </li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=16-api>16. Як можна протестувати API, що там потрібно перевіряти<a class=headerlink href=#16-api title="Permanent link">&para;</a></h3> <p>Переконатися, що API працює правильно, можна за допомогою функціонального тестування. Основні завдання: * переконатися, що реалізація API працює правильно, як і очікувалося * гарантувати, що реалізація API працює відповідно до специфікації вимог * запобігти регресії між написаним кодом та релізом</p> <p>Перевірка специфікації: * Ендпоінти правильно іменовані * ресурси та його типи правильно відбивають об'єктну модель * немає відсутньої або дублюючої функціональності * відносини між ресурсами правильно відображаються в API</p> <p><strong>Етапи тестування API</strong> Кожен тест складається з атомарних дій, які мають виконуватися у кожному потоці тестування API. Для кожного запиту API тест повинен виконати такі дії:</p> <ol> <li>Коригування коду стану HTTP (створення ресурсу має повертати 201 CREATED, а заборонені запити повинні повертати 403 FORBIDDEN і т.д.)</li> <li>Корисне навантаження відповіді (правильність тіла JSON, імен, типів та значень полів відповіді, у тому числі у відповідях на помилкові запити)</li> <li>Заголовки відповіді (заголовки HTTP-сервера впливають як на безпеку, так і на продуктивність)</li> <li>Правильність стану програми (застосовується в основному до ручного тестування або коли інтерфейс користувача або інший інтерфейс можна легко перевірити)</li> <li>Базова працездатність (якщо операція була завершена успішно, але зайняла невиправдано багато часу, тест не пройдено)</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=17>17. Формати передачі даних<a class=headerlink href=#17 title="Permanent link">&para;</a></h3> <ul> <li><em>JSON (JavaScript Object Notation)</em> - текстовий формат обміну даними, заснований на JavaScript, але при цьому незалежний від JS.</li> <li><em>XML (eXtensible Markup Language/розширювана мова розмітки)</em> - використовується для зберігання та передачі даних. формат рекомендований Консорціумом Всесвітньої павутини (W3C), тому часто використовується передачі даних по API. Єдино можливий формат вхідних та вихідних даних у SOAP.</li> <li><em>CSV (Comma-Separated Values/значення, розділені комами)</em> – текстовий формат, призначений для представлення табличних даних з фіксованою кількістю стовпців. Кожен рядок файлу – це один рядок таблиці.</li> <li><em>YAML (YAML Ain't markup language/YAML не мова розмітки; раніше Yet Another Markup Language)</em> - мова для серіалізації даних, яка дозволяє зберігати складноорганізовані дані в компактному та читаному форматі. Схожий на XML і JSON, але використовує більш мінімалістичний синтаксис для збереження аналогічних можливостей.</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=18-xml-json>18. Відмінності між XML та JSON<a class=headerlink href=#18-xml-json title="Permanent link">&para;</a></h3> <p><em>XML</em> - мова розмітки.</p> <p><em>JSON</em> - формат обміну даними, зазвичай реалізований, як масив даних.</p> <p><strong>Ключові відмінності</strong>:</p> <ul> <li>Об'єкт JSON має тип, тоді як об'єкти XML не містять типів</li> <li>У JSON простіше отримати об'єкт ніж у XML (дані XML повинні бути проаналізовані)</li> <li>Читабельність JSON файлу вище в порівнянні з XML</li> <li>JSON не забезпечує підтримку простору імен, в той час як XML забезпечує</li> <li>JSON не має можливостей відображення, тоді як XML має таку можливість</li> <li>JSON менш захищений, тоді як XML більш безпечний у порівнянні з JSON</li> <li>JSON підтримує лише кодування UTF-8, тоді як XML підтримує різні кодування</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=19->19. Клієнт-серверна архітектура<a class=headerlink href=#19- title="Permanent link">&para;</a></h3> <p><img alt=IMG src=images/client_server.png></p> <p>У проміжках можуть бути балансувальники, якщо використовується кілька серверів або БД.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=20-testng-junit>20. Для чого потрібні TestNG, JUnit<a class=headerlink href=#20-testng-junit title="Permanent link">&para;</a></h3> <p>Це фреймворки автоматичного тестування. Потрібні щоб не писати свій велосипед для тих самих завдань конфігурування тестів, анотацій для них, дата-провайдерів і т.д.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=21-testng-junit>21. Які інструкції використовуються в TestNG, JUnit<a class=headerlink href=#21-testng-junit title="Permanent link">&para;</a></h3> <p><em>TestNG</em>:</p> <ul> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeSuite title="GitHub User: BeforeSuite">@BeforeSuite</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterSuite title="GitHub User: AfterSuite">@AfterSuite</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeTest title="GitHub User: BeforeTest">@BeforeTest</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterTest title="GitHub User: AfterTest">@AfterTest</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeClass title="GitHub User: BeforeClass">@BeforeClass</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterClass title="GitHub User: AfterClass">@AfterClass</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeGroups title="GitHub User: BeforeGroups">@BeforeGroups</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterGroups title="GitHub User: AfterGroups">@AfterGroups</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeMethod title="GitHub User: BeforeMethod">@BeforeMethod</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterMethod title="GitHub User: AfterMethod">@AfterMethod</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Test title="GitHub User: Test">@Test</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/DataProvider title="GitHub User: DataProvider">@DataProvider</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Factory title="GitHub User: Factory">@Factory</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Parameters title="GitHub User: Parameters">@Parameters</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Listener title="GitHub User: Listener">@Listener</a></li> </ul> <p><em>jUnit 5</em>:</p> <ul> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeAll title="GitHub User: BeforeAll">@BeforeAll</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterAll title="GitHub User: AfterAll">@AfterAll</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/BeforeEach title="GitHub User: BeforeEach">@BeforeEach</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/AfterEach title="GitHub User: AfterEach">@AfterEach</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Test title="GitHub User: Test">@Test</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Disable title="GitHub User: Disable">@Disable</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Nested title="GitHub User: Nested">@Nested</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Tag title="GitHub User: Tag">@Tag</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/TestFactory title="GitHub User: TestFactory">@TestFactory</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/Suite title="GitHub User: Suite">@Suite</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/SelectClasses title="GitHub User: SelectClasses">@SelectClasses</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/SelectPackages title="GitHub User: SelectPackages">@SelectPackages</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/IncludePackages title="GitHub User: IncludePackages">@IncludePackages</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/ExcludePackages title="GitHub User: ExcludePackages">@ExcludePackages</a></li> <li><a class="magiclink magiclink-github magiclink-mention" href=https://github.com/IncludeClassNamePatterns title="GitHub User: IncludeClassNamePatterns">@IncludeClassNamePatterns</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/ExcludeClassNamePatterns title="GitHub User: ExcludeClassNamePatterns">@ExcludeClassNamePatterns</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/IncludeTags title="GitHub User: IncludeTags">@IncludeTags</a> / <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/ExcludeTags title="GitHub User: ExcludeTags">@ExcludeTags</a></li> </ul> <h3 id=22-assertions-testng-junit>22. Які assertions є в TestNG, JUnit<a class=headerlink href=#22-assertions-testng-junit title="Permanent link">&para;</a></h3> <p><em>TestNG</em>: * assertEquals() / assertNotEquals() * assertTrue() / assertFalse() * assertNull() / assertNotNull() * assertSame() / assertNotSame() * assertEqualsNoOrder() * fail()</p> <p><em>jUnit 5</em>: * assertTrue() / assertFalse() * assertEquals() / assertNotEquals() * assertArrayEquals() * assertIterableEquals() * assertLinesMatch() * assertNull() / assertNotNull() * assertSame() / assertNotSame() * assertTimeout() / assertTimeoutPreemptively() * assertThrows() * fail()</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=23-testng-junit>23. Як виконувати тести паралельно TestNG, JUnit<a class=headerlink href=#23-testng-junit title="Permanent link">&para;</a></h3> <p><strong><em>Перекласти драйвер браузера на ThreadLocal!</em></strong></p> <p><em>TestNG</em></p> <ul> <li>TestNG (xmlSuite.setParallel(XmlSuite.ParallelMode.CLASSES))</li> <li>TestNG (xmlSuite.setThreadCount(\<n>) + xmlSuite.setDataProviderThreadCount(\<m>))</li> </ul> <p><em>jUnit 5</em></p> <ul> <li>Djunit.jupiter.execution.parallel.enabled=true</li> <li>Djunit.jupiter.execution.parallel.mode.default=concurrent</li> </ul> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=24-2>24. 2 способи, що дозволяють автоматизувати капчу<a class=headerlink href=#24-2 title="Permanent link">&para;</a></h3> <ol> <li><em>Боти з підтримкою оптичного розпізнавання символів (OCR)</em> - у цьому підході КАПЧА вирішується автоматично за допомогою бота.</li> <li><em>Послуги з вирішення капчі реальними людьми</em> - у сервісі є співробітники, які постійно доступні онлайн для розв'язання капчі. Коли ви відправляєте свою КАПЧУ, компанія пересилає її працівникам, які її вирішують, та відправляє назад рішення.</li> </ol> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=25-selenium-grid>25. Що таке Selenium Grid<a class=headerlink href=#25-selenium-grid title="Permanent link">&para;</a></h3> <p><em>Selenium Grid</em> - кластер, що складається з кількох Selenium-серверів. Призначений для організації розподіленої мережі, що дозволяє паралельно запускати багато браузерів на велику кількість машин. Є виділений сервер, що зветься «хаб» чи «коммутатор», інші сервера називаються «ноди» чи «вузли».</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=26>26. Драйвер браузера<a class=headerlink href=#26 title="Permanent link">&para;</a></h3> <p><em>Драйвер браузера</em> - програмна бібліотека, що не має інтерфейсу користувача, що дозволяє різним програмам взаємодіяти з браузером, керувати його поведінкою, отримувати від браузера дані і змушувати браузер виконувати команди.</p> <p><a href=https://tendil.github.io/tjh-knowledge-base#запитання-для-співбесіди-на-теми>до змісту ⬆️</a></p> <h3 id=27_3>27. Які види локаторів сторінки існують? Які їх переваги та недоліки<a class=headerlink href=#27_3 title="Permanent link">&para;</a></h3> <p><code>id=&lt;element_id&gt;</code> - відповідає елементу, у якого атрибут id дорівнює значенню element_id. Слід зазначити, що даний вид локаторів є одним із найшвидших у знаходженні та одним із найунікальніших.</p> <p><code>name=&lt;element_name&gt;</code> - відповідає елементу, у якого атрибут name дорівнює значенню element_name. Ефективно застосовується під час роботи з полями введення форми (кнопки, текстові поля, списки, що випадають). Даний тип локаторів теж є досить швидким у знаходженні, але менш унікальним, тому що на сторінці може бути кілька форм, які можуть мати елементи з однаковим ім'ям.</p> <p><code>dom=&lt;dom_object&gt;</code> - даний тип локатора дозволяє звертатися до елемента так само, як і в DHTML, використовуючи DOM-структуру. Даний тип локатора використовується нечасто, так як зазвичай знаходяться зручніші аналоги, проте дана можливість є.</p> <p><code>link=&lt;link_text&gt;</code> - спеціально для посилань використовується окремо зарезервований тип локаторів, який знаходить потрібне посилання за його текстом. Це зроблено частково тому, що посилання зазвичай не мають таких атрибутів як ID або name. Також у посилання є фіксована частина і є частина, яка може змінюватись. У цьому випадку ми можемо використовувати wildcards, зокрема '*'.</p> <p><code>xpath=&lt;xpath_locator&gt;</code> - найбільш універсальний тип локаторів. HTML є різним поєднанням тегів, які вибудовуються в певну ієрархію, на кшталт структури каталогів у файловій системі. Завдання XPath - відобразити подібний шлях до потрібного елемента з урахуванням ієрархії. XPath має багато зручностей, але є і основний недолік - низька швидкість знаходження об'єкта. У таких випадках рекомендується скористатися CSS-локаторами, але в деяких випадках від XPath піти не вдасться.</p> <p><code>css=&lt;css_path&gt;</code> - даний тип локаторів ґрунтується на описах таблиць стилів (CSS). На відміну від локаторів по ID, імені або тексту посилання, даний тип локаторів може враховувати ієрархію об'єктів, а також значення атрибутів, що робить його найближчим аналогом XPath. А тому, що об'єкт знаходиться по даному локатору швидше, ніж XPath, рекомендується вдаватися до допомоги CSS замість XPath.</p> </article> </div> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": ".", "features": [], "search": "assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=assets/javascripts/bundle.dff1b7c8.min.js></script> </body> </html>